CCS PCH C Compiler, Version 5.008, 5967               08-Nov-14 16:10

               Filename:   C:\Users\Matt\Documents\Projects\Wedding\LED Centerpiece\Code\Centerpiece_16F1788.X\build\18F25K22\production\main.lst

               ROM used:   5108 bytes (16%)
                           Largest free fragment is 27660
               RAM used:   232 (15%) at main() level
                           324 (21%) worst case
               Stack used: 9 locations (3 in main + 6 for interrupts)
               Stack size: 31

*
0000:  GOTO   1288
.................... /*  
....................  * File:   main.c 
....................  * Author: Matt Wasserman 
....................  * Control Wedding LED Centerpieces 
....................  * 
....................  * Created on September 1, 2014, 5:54 PM 
....................  */ 
....................  
.................... //#include <16F1788.h> 
.................... #include <18F25K22.h> 
.................... //////// Standard Header file for the PIC18F25K22 device //////////////// 
.................... #device PIC18F25K22 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA C9,00
0016:  DATA D0,00
0018:  DATA D7,00
001A:  DATA DE,00
*
0496:  MOVLB  1
0498:  MOVF   x2F,W
049A:  MULWF  x31
049C:  MOVFF  FF3,01
04A0:  MOVFF  FF4,00
04A4:  MULWF  x32
04A6:  MOVF   FF3,W
04A8:  ADDWF  00,F
04AA:  MOVF   x30,W
04AC:  MULWF  x31
04AE:  MOVF   FF3,W
04B0:  ADDWFC 00,W
04B2:  MOVWF  02
04B4:  MOVLB  0
04B6:  RETURN 0
04B8:  CLRF   01
04BA:  CLRF   02
04BC:  CLRF   00
04BE:  CLRF   03
04C0:  MOVLB  1
04C2:  MOVF   x33,W
04C4:  BNZ   04CA
04C6:  MOVF   x32,W
04C8:  BZ    04FA
04CA:  MOVLW  10
04CC:  MOVWF  x34
04CE:  BCF    FD8.0
04D0:  RLCF   x30,F
04D2:  RLCF   x31,F
04D4:  RLCF   00,F
04D6:  RLCF   03,F
04D8:  MOVF   x33,W
04DA:  SUBWF  03,W
04DC:  BNZ   04E2
04DE:  MOVF   x32,W
04E0:  SUBWF  00,W
04E2:  BNC   04F2
04E4:  MOVF   x32,W
04E6:  SUBWF  00,F
04E8:  BTFSS  FD8.0
04EA:  DECF   03,F
04EC:  MOVF   x33,W
04EE:  SUBWF  03,F
04F0:  BSF    FD8.0
04F2:  RLCF   01,F
04F4:  RLCF   02,F
04F6:  DECFSZ x34,F
04F8:  BRA    04CE
04FA:  MOVLB  0
04FC:  RETURN 0
*
06B0:  MOVLB  1
06B2:  CLRF   x35
06B4:  CLRF   x36
06B6:  MOVLW  01
06B8:  MOVWF  x37
06BA:  CLRF   FDA
06BC:  CLRF   FD9
06BE:  MOVWF  x3A
06C0:  MOVLW  2D
06C2:  MOVWF  x39
06C4:  MOVLW  01
06C6:  MOVWF  FEA
06C8:  MOVLW  31
06CA:  MOVWF  FE9
06CC:  MOVFF  13A,FE2
06D0:  MOVFF  139,FE1
06D4:  MOVFF  137,138
06D8:  BCF    FD8.0
06DA:  MOVF   FE5,W
06DC:  MULWF  FEE
06DE:  MOVF   FF3,W
06E0:  ADDWFC x35,F
06E2:  MOVF   FF4,W
06E4:  ADDWFC x36,F
06E6:  DECFSZ x38,F
06E8:  BRA    06D8
06EA:  MOVFF  135,FDE
06EE:  MOVFF  136,135
06F2:  CLRF   x36
06F4:  BTFSC  FD8.0
06F6:  INCF   x36,F
06F8:  INCF   x39,F
06FA:  BTFSC  FD8.2
06FC:  INCF   x3A,F
06FE:  INCF   x37,F
0700:  MOVF   x37,W
0702:  SUBLW  05
0704:  BNZ   06C4
0706:  MOVLB  0
0708:  GOTO   0732 (RETURN)
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOMCLR, NOBROWNOUT, NOWDT, PUT 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
070C:  MOVFF  09,130
0710:  MOVFF  08,12F
0714:  MOVFF  07,12E
0718:  MOVFF  06,12D
071C:  MOVLW  41
071E:  MOVLB  1
0720:  MOVWF  x34
0722:  MOVLW  C6
0724:  MOVWF  x33
0726:  MOVLW  4E
0728:  MOVWF  x32
072A:  MOVLW  6D
072C:  MOVWF  x31
072E:  MOVLB  0
0730:  BRA    06B0
0732:  MOVLW  39
0734:  MOVLB  1
0736:  ADDWF  00,W
0738:  MOVWF  06
073A:  MOVLW  30
073C:  ADDWFC 01,W
073E:  MOVWF  07
0740:  MOVLW  00
0742:  ADDWFC 02,W
0744:  MOVWF  08
0746:  MOVLW  00
0748:  ADDWFC 03,W
074A:  MOVWF  09
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
074C:  MOVFF  08,00
0750:  MOVFF  09,01
0754:  CLRF   02
0756:  CLRF   03
0758:  MOVFF  09,12F
075C:  MOVFF  08,12E
0760:  MOVFF  09,131
0764:  MOVFF  08,130
0768:  MOVLW  7F
076A:  MOVWF  x33
076C:  SETF   x32
076E:  MOVLB  0
0770:  RCALL  04B8
0772:  MOVFF  00,01
0776:  MOVFF  03,02
077A:  RETURN 0
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "Globals.h" 
.................... /* 
....................  * File:   Globals.h 
....................  * Author: Matt Wasserman 
....................  * Header file with all global vars and defines 
....................  */ 
....................  
.................... /* DEFINES FOR VERSION*/ 
.................... //#define BOARD_V1_1 
.................... #define BOARD_V1_2 
....................  
.................... #define WS2801 
.................... //#define WS2811 
....................  
.................... /* DEFINES */ 
.................... #define TDOTS 43 // number of LEDs on the strip 
.................... #define NUM_INTERNAL_TIMER 1 
.................... #define NUM_PATTERN_POSITION 2 
.................... #define NUM_PATTERNS 12 
.................... #define DELAY_TIME_MS_JUMP 50 
.................... #define LED_ON_PIN PIN_A7 
....................  
.................... //defines for buttons 
.................... #define POWER_BUTTON_PIN PIN_A0 
.................... #define UP_BUTTON_PIN PIN_A1 
.................... #define DOWN_BUTTON_PIN PIN_A2 
.................... #define LEFT_BUTTON_PIN PIN_A3 
.................... #define RIGHT_BUTTON_PIN PIN_A4 
.................... #define CENTER_BUTTON_PIN PIN_A5 
.................... #define POWER_BUTTON_BIT 0 
.................... #define UP_BUTTON_BIT 1 
.................... #define DOWN_BUTTON_BIT 2 
.................... #define LEFT_BUTTON_BIT 3 
.................... #define RIGHT_BUTTON_BIT 4 
.................... #define CENTER_BUTTON_BIT 5 
....................  
.................... //Debug functions 
.................... //#define DEBUG_SERIAL 1 
....................  
.................... struct rtos_stats { 
....................    int32 task_total_ticks;       // number of ticks the task has used 
....................    int16 task_min_ticks;         // the minimum number of ticks used 
....................    int16 task_max_ticks;         // the maximum number of ticks ueed 
....................    int16 hns_per_tick;           // us = (ticks*hns_per_tic)/10 
.................... }; 
....................  
....................  
.................... /* GLOBAL VARIABLES*/ 
.................... unsigned int32 node_list[TDOTS]; 
.................... unsigned int32 internal_timer[NUM_INTERNAL_TIMER]; 
.................... unsigned int16 pattern_position[NUM_PATTERN_POSITION]; //used to track current position within a patten 
.................... unsigned int16 current_pattern; 
.................... int1 pattern_set; 
.................... int1 continue_pattern_calling; 
.................... int1 led_power_status; 
.................... int16 timer_flags_counter; 
.................... unsigned int8 button_status; 
.................... unsigned int8 button_counter; 
.................... int autochange_pattern; 
.................... int16 delay_time_ms; 
....................  
....................  
....................  
.................... #USE DELAY(clock=32MHZ) 
*
0138:  MOVLW  02
013A:  MOVLB  1
013C:  SUBWF  x36,F
013E:  BNC   0158
0140:  MOVLW  01
0142:  MOVWF  FEA
0144:  MOVLW  36
0146:  MOVWF  FE9
0148:  MOVF   FEF,W
014A:  BZ    0158
014C:  BRA    0154
014E:  BRA    0150
0150:  BRA    0152
0152:  NOP   
0154:  DECFSZ FEF,F
0156:  BRA    014E
0158:  MOVLB  0
015A:  GOTO   0244 (RETURN)
*
0E68:  MOVLW  01
0E6A:  MOVWF  FEA
0E6C:  MOVLW  28
0E6E:  MOVWF  FE9
0E70:  MOVF   FEF,W
0E72:  BZ    0E8E
0E74:  MOVLW  0A
0E76:  MOVWF  01
0E78:  CLRF   00
0E7A:  DECFSZ 00,F
0E7C:  BRA    0E7A
0E7E:  DECFSZ 01,F
0E80:  BRA    0E78
0E82:  MOVLW  5F
0E84:  MOVWF  00
0E86:  DECFSZ 00,F
0E88:  BRA    0E86
0E8A:  DECFSZ FEF,F
0E8C:  BRA    0E74
0E8E:  RETURN 0
....................  
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BITS=8, STOP=1, PARITY=N, INVERT) 
.................... #use rtos(timer=1) 
....................  
....................  
.................... /* TASK FUNCTIONS */ 
.................... #task(rate=30s,max=5ms) 
.................... void Pattern_Selector(); 
....................  
.................... #task(rate=10ms,max=5ms) 
.................... void Update_Pattern(); 
....................  
.................... #task(rate=10ms,max=5ms) 
.................... void Button_Checker(); 
....................  
.................... #task(rate=1ms,max=1ms) 
.................... void Timer_Tic(); 
....................  
.................... /* 
.................... #task(rate=100ms,max=1ms) 
.................... void Timer_Check(); 
.................... */ 
....................  
.................... /*Additonal Includes*/ 
....................  
.................... #include "Timer_Flags.c" 
.................... //FILE NAME = Timer_Flags.c 
.................... // functions to avoid using delay calls 
....................  
.................... void Timer_Clear_Timer(int timer){ 
....................     if(timer < NUM_INTERNAL_TIMER){ 
*
03E8:  MOVLB  1
03EA:  MOVF   x2F,F
03EC:  BNZ   0412
....................         internal_timer[timer] = 0; 
03EE:  MOVF   x2F,W
03F0:  MULLW  04
03F2:  MOVF   FF3,W
03F4:  CLRF   03
03F6:  ADDLW  B6
03F8:  MOVWF  FE9
03FA:  MOVLW  00
03FC:  ADDWFC 03,W
03FE:  MOVWF  FEA
0400:  MOVF   FEE,F
0402:  MOVF   FEE,F
0404:  CLRF   FEC
0406:  MOVF   FED,F
0408:  CLRF   FEF
040A:  MOVF   FED,F
040C:  CLRF   FEF
040E:  MOVF   FED,F
0410:  CLRF   FEF
....................     } 
0412:  MOVLB  0
0414:  RETURN 0
.................... } 
....................  
.................... void Timer_Clear_All_Timer(){ 
....................     int i; 
....................     rtos_disable(Timer_Tic); 
*
1252:  BSF    xDE.7
....................     for (i=0;i<NUM_INTERNAL_TIMER;i++){ 
1254:  CLRF   xE8
1256:  MOVF   xE8,F
1258:  BNZ   1282
....................         internal_timer[i] = 0; 
125A:  MOVF   xE8,W
125C:  MULLW  04
125E:  MOVF   FF3,W
1260:  CLRF   03
1262:  ADDLW  B6
1264:  MOVWF  FE9
1266:  MOVLW  00
1268:  ADDWFC 03,W
126A:  MOVWF  FEA
126C:  MOVF   FEE,F
126E:  MOVF   FEE,F
1270:  CLRF   FEC
1272:  MOVF   FED,F
1274:  CLRF   FEF
1276:  MOVF   FED,F
1278:  CLRF   FEF
127A:  MOVF   FED,F
127C:  CLRF   FEF
127E:  INCF   xE8,F
1280:  BRA    1256
....................     } 
....................     rtos_enable(Timer_Tic); 
1282:  BCF    xDE.7
1284:  GOTO   131A (RETURN)
.................... } 
....................  
.................... int32 Timer_Get_Timer(int timer){ 
....................     if(timer < NUM_INTERNAL_TIMER){ 
*
031A:  MOVLB  1
031C:  MOVF   x2F,F
031E:  BNZ   0346
....................         return internal_timer[timer]; 
0320:  MOVF   x2F,W
0322:  MULLW  04
0324:  MOVF   FF3,W
0326:  CLRF   03
0328:  ADDLW  B6
032A:  MOVWF  FE9
032C:  MOVLW  00
032E:  ADDWFC 03,W
0330:  MOVWF  FEA
0332:  MOVFF  FEF,00
0336:  MOVFF  FEC,01
033A:  MOVFF  FEC,02
033E:  MOVFF  FEC,03
0342:  BRA    034E
....................     }else{ 
0344:  BRA    034E
....................         return 0; 
0346:  CLRF   00
0348:  CLRF   01
034A:  CLRF   02
034C:  CLRF   03
....................     } 
034E:  MOVLB  0
0350:  RETURN 0
.................... } 
....................  
.................... void Timer_Tic(){ 
....................     //OUTPUT_HIGH(PIN_C4); 
....................     int i; 
....................     for (i=0;i<NUM_INTERNAL_TIMER;i++){ 
*
001C:  MOVLB  1
001E:  CLRF   x27
0020:  MOVF   x27,F
0022:  BNZ   0046
....................         internal_timer[i]++; 
0024:  MOVF   x27,W
0026:  MULLW  04
0028:  MOVF   FF3,W
002A:  CLRF   03
002C:  ADDLW  B6
002E:  MOVWF  FE9
0030:  MOVLW  00
0032:  ADDWFC 03,W
0034:  MOVWF  FEA
0036:  MOVLW  01
0038:  ADDWF  FEE,F
003A:  MOVLW  00
003C:  ADDWFC FEE,F
003E:  ADDWFC FEE,F
0040:  ADDWFC FED,F
0042:  INCF   x27,F
0044:  BRA    0020
....................     } 
0046:  MOVLW  1C
0048:  MOVLB  0
004A:  MOVWF  xE3
004C:  MOVLW  00
004E:  MOVWF  xE4
0050:  GOTO   13DE
0054:  RETURN 0
....................     //OUTPUT_LOW(PIN_C4); 
.................... } 
....................  
.................... void Timer_Check() { 
....................     int i; 
....................     for (i = 0; i < NUM_INTERNAL_TIMER; i++) { 
.................... #ifdef DEBUG_SERIAL 
....................         printf("Timer %i = %Lu\n\r",i,internal_timer[i]); 
.................... #endif 
....................     } 
....................  
.................... } 
....................  
.................... #ifdef WS2801 
....................     #include "WS2801_SPI.c" 
.................... //FILE NAME = WS2801_SPI.c 
.................... //File to output controls to a WS2801 led strip using PIC SPI commands 
....................  
.................... //needed Constant 
.................... //nDots - number of nodes in the chain 
....................  
.................... //needed Globel Vars 
.................... //node_list - 32bit array where all node colors are stored 
....................  
.................... //*****************Function List*****************// 
.................... //void send_frame(void) 
.................... 	//Update the chain of WS2801 Nodes 
.................... //******************Functions*******************// 
....................  
.................... //use SPI to sent out all frames 
.................... void send_frame(void) {   // NOTE this strip takes data in BLUE, GREEN, RED order 
....................   unsigned int16 i; 
....................   unsigned int8 red,green,blue; 
....................  
....................   for(i=0;i<TDOTS;i++) { 
*
015E:  MOVLB  1
0160:  CLRF   x31
0162:  CLRF   x30
0164:  MOVF   x31,F
0166:  BNZ   0238
0168:  MOVF   x30,W
016A:  SUBLW  2A
016C:  BNC   0238
....................     red = node_list[i] & 0xFF; 
016E:  RLCF   x30,W
0170:  MOVWF  02
0172:  RLCF   x31,W
0174:  MOVWF  03
0176:  RLCF   02,F
0178:  RLCF   03,F
017A:  MOVLW  FC
017C:  ANDWF  02,F
017E:  MOVF   02,W
0180:  ADDLW  0A
0182:  MOVWF  FE9
0184:  MOVLW  00
0186:  ADDWFC 03,W
0188:  MOVWF  FEA
018A:  MOVFF  FEF,135
018E:  MOVFF  FEC,136
0192:  MOVFF  FEC,137
0196:  MOVFF  FEC,138
019A:  MOVFF  135,132
....................     green = (node_list[i] >> 8) & 0xFF; 
019E:  RLCF   x30,W
01A0:  MOVWF  02
01A2:  RLCF   x31,W
01A4:  MOVWF  03
01A6:  RLCF   02,F
01A8:  RLCF   03,F
01AA:  MOVLW  FC
01AC:  ANDWF  02,F
01AE:  MOVF   02,W
01B0:  ADDLW  0A
01B2:  MOVWF  FE9
01B4:  MOVLW  00
01B6:  ADDWFC 03,W
01B8:  MOVWF  FEA
01BA:  MOVFF  FEF,135
01BE:  MOVFF  FEC,136
01C2:  MOVFF  FEC,137
01C6:  MOVFF  FEC,138
01CA:  MOVFF  136,135
01CE:  MOVFF  137,136
01D2:  MOVFF  138,137
01D6:  MOVFF  135,133
....................     blue = (node_list[i] >> 16) & 0xFF; 
01DA:  RLCF   x30,W
01DC:  MOVWF  02
01DE:  RLCF   x31,W
01E0:  MOVWF  03
01E2:  RLCF   02,F
01E4:  RLCF   03,F
01E6:  MOVLW  FC
01E8:  ANDWF  02,F
01EA:  MOVF   02,W
01EC:  ADDLW  0A
01EE:  MOVWF  FE9
01F0:  MOVLW  00
01F2:  ADDWFC 03,W
01F4:  MOVWF  FEA
01F6:  MOVFF  FEF,135
01FA:  MOVFF  FEC,136
01FE:  MOVFF  FEC,137
0202:  MOVFF  FEC,138
0206:  MOVFF  137,135
020A:  MOVFF  138,136
020E:  MOVFF  135,134
....................     spi_write(blue); 
0212:  MOVF   FC9,W
0214:  MOVFF  134,FC9
0218:  RRCF   FC7,W
021A:  BNC   0218
....................     spi_write(green); 
021C:  MOVF   FC9,W
021E:  MOVFF  133,FC9
0222:  RRCF   FC7,W
0224:  BNC   0222
....................     spi_write(red); 
0226:  MOVF   FC9,W
0228:  MOVFF  132,FC9
022C:  RRCF   FC7,W
022E:  BNC   022C
0230:  INCF   x30,F
0232:  BTFSC  FD8.2
0234:  INCF   x31,F
0236:  BRA    0164
....................   } 
....................   delay_us(500);    // delay 500us to latch the IC 
0238:  MOVLW  02
023A:  MOVWF  x35
023C:  MOVLW  FA
023E:  MOVWF  x36
0240:  MOVLB  0
0242:  BRA    0138
0244:  MOVLB  1
0246:  DECFSZ x35,F
0248:  BRA    023C
024A:  MOVLB  0
024C:  RETURN 0
.................... } 
....................  
....................  
.................... #endif 
.................... #ifdef WS2811 
....................     #include "WS2811_SPI.c" 
.................... #endif 
.................... #include "LED_Array.c" 
.................... //FILE NAME = LED_Array.c 
.................... //Functions to generate 24bit colors patterns and manipulate them 
....................  
.................... //void addRandom(void) 
.................... 	//shifts all dots one to the right and adds 1 random value 
....................  
.................... //int32 Color(int r, int g, int b) 
.................... 	// Create a 24 bit color value from R,G,B 
....................  
.................... //int32 Wheel(int16 WheelPos){ 
.................... 	//Input a value 0 to 767 to get a color value. 
.................... 	//The colours are a transition r - g -b - back to r 
....................  
.................... //void MakeAllColor(int32 color_set) 
.................... 	//make all LEDS one color (overloaded function) 
....................  
.................... //void MakeAllColor(int red, int green, int blue) 
.................... 	//make all LEDS one color, overloaded to accept red, green blue inputs 
....................  
.................... //void setup() 
.................... 	////Clear out the array 
....................  
.................... //NOT IN THE FILE ANYMORE 
....................  
.................... //void ShiftRight(int16 newval) 
.................... 	//Shift right, Shift the node_list one to the right 
.................... 	//[i] -> [i+1]. Insert newval in node_list[0] 
....................  
.................... //void ShiftRight(int32 newval) 
.................... 	//Shift right, Shift the node_list one to the right 
.................... 	//[i] -> [i+1]. Insert newval in node_list[0] 
....................  
.................... void addRandom(void) { 
*
077C:  MOVLB  1
077E:  CLRF   x2C
0780:  CLRF   x2B
0782:  CLRF   x2A
0784:  CLRF   x29
....................   unsigned int16 x; 
....................   unsigned int32 new_color = 0; 
....................  
....................   //First, shuffle all the current colors down one spot on the strip 
....................   for(x = (TDOTS - 1) ; x > 0 ; x--) 
0786:  CLRF   x28
0788:  MOVLW  2A
078A:  MOVWF  x27
078C:  MOVF   x27,F
078E:  BNZ   0794
0790:  MOVF   x28,F
0792:  BZ    0820
....................     node_list[x] = node_list[x - 1]; 
0794:  RLCF   x27,W
0796:  MOVWF  02
0798:  RLCF   x28,W
079A:  MOVWF  03
079C:  RLCF   02,F
079E:  RLCF   03,F
07A0:  MOVLW  FC
07A2:  ANDWF  02,F
07A4:  MOVF   02,W
07A6:  ADDLW  0A
07A8:  MOVWF  01
07AA:  MOVLW  00
07AC:  ADDWFC 03,F
07AE:  MOVFF  01,12D
07B2:  MOVFF  03,12E
07B6:  MOVLW  01
07B8:  SUBWF  x27,W
07BA:  MOVWF  x2F
07BC:  MOVLW  00
07BE:  SUBWFB x28,W
07C0:  MOVWF  x30
07C2:  RLCF   x2F,W
07C4:  MOVWF  02
07C6:  RLCF   x30,W
07C8:  MOVWF  03
07CA:  RLCF   02,F
07CC:  RLCF   03,F
07CE:  MOVLW  FC
07D0:  ANDWF  02,F
07D2:  MOVF   02,W
07D4:  ADDLW  0A
07D6:  MOVWF  FE9
07D8:  MOVLW  00
07DA:  ADDWFC 03,W
07DC:  MOVWF  FEA
07DE:  MOVFF  FEF,00
07E2:  MOVFF  FEC,01
07E6:  MOVFF  FEC,02
07EA:  MOVFF  FEC,03
07EE:  MOVFF  03,132
07F2:  MOVFF  02,131
07F6:  MOVFF  01,130
07FA:  MOVFF  00,12F
07FE:  MOVFF  12E,FEA
0802:  MOVFF  12D,FE9
0806:  MOVFF  00,FEF
080A:  MOVFF  01,FEC
080E:  MOVFF  02,FEC
0812:  MOVFF  03,FEC
0816:  MOVF   x27,W
0818:  BTFSC  FD8.2
081A:  DECF   x28,F
081C:  DECF   x27,F
081E:  BRA    078C
....................  
....................   //Now form a new RGB color 
....................   for(x = 0 ; x < 3 ; x++){ 
0820:  CLRF   x28
0822:  CLRF   x27
0824:  MOVF   x28,F
0826:  BNZ   0852
0828:  MOVF   x27,W
082A:  SUBLW  02
082C:  BNC   0852
....................     new_color <<= 8; 
082E:  MOVFF  12B,12C
0832:  MOVFF  12A,12B
0836:  MOVFF  129,12A
083A:  CLRF   x29
....................     new_color |= rand(); //Give me a number from 0 to 0xFF 
083C:  MOVLB  0
083E:  RCALL  070C
0840:  MOVF   01,W
0842:  MOVLB  1
0844:  IORWF  x29,F
0846:  MOVF   02,W
0848:  IORWF  x2A,F
084A:  INCF   x27,F
084C:  BTFSC  FD8.2
084E:  INCF   x28,F
0850:  BRA    0824
....................   } 
....................   node_list[0] = new_color; //Add the new random color to the strip 
0852:  MOVFF  12C,0D
0856:  MOVFF  12B,0C
085A:  MOVFF  12A,0B
085E:  MOVFF  129,0A
0862:  MOVLB  0
0864:  GOTO   08AA (RETURN)
.................... } 
....................  
.................... // Create a 24 bit color value from R,G,B 
.................... int32 Color(int r, int g, int b){ 
....................   //Take the lowest 8bits of each value and append them end to end 
....................   	return( ((int32)(b & 0xFF)<<16) | ((int32)(g & 0xFF)<<8) | (int32)(r & 0xFF) ); 
*
00D8:  MOVLB  1
00DA:  MOVF   x39,W
00DC:  CLRF   x3D
00DE:  CLRF   x3C
00E0:  CLRF   x3B
00E2:  MOVWF  x3A
00E4:  MOVFF  13B,13D
00E8:  MOVWF  x3C
00EA:  CLRF   x3A
00EC:  CLRF   x3B
00EE:  MOVF   x38,W
00F0:  CLRF   x41
00F2:  CLRF   x40
00F4:  MOVWF  x3F
00F6:  MOVFF  141,03
00FA:  MOVFF  140,02
00FE:  MOVWF  01
0100:  CLRF   00
0102:  MOVF   00,W
0104:  IORWF  x3A,F
0106:  MOVF   x3F,W
0108:  IORWF  x3B,F
010A:  MOVF   x40,W
010C:  IORWF  x3C,F
010E:  MOVF   x41,W
0110:  IORWF  x3D,F
0112:  MOVFF  137,00
0116:  CLRF   01
0118:  CLRF   02
011A:  CLRF   03
011C:  MOVF   x37,W
011E:  IORWF  x3A,W
0120:  MOVWF  00
0122:  MOVF   01,W
0124:  IORWF  x3B,W
0126:  MOVWF  01
0128:  MOVF   02,W
012A:  IORWF  x3C,W
012C:  MOVWF  02
012E:  MOVF   03,W
0130:  IORWF  x3D,W
0132:  MOVWF  03
0134:  MOVLB  0
0136:  RETURN 0
.................... } 
....................  
.................... //Input a value 0 to 767 to get a color value. 
.................... //The colours are a transition r - g -b - back to r 
.................... int32 Wheel(int16 WheelPos){ 
....................   int16 r; 
....................   int16 g; 
....................   int16 b; 
....................   switch(WheelPos >> 8)  { 
*
0352:  MOVLB  1
0354:  MOVF   x30,W
0356:  CLRF   03
0358:  MOVWF  00
035A:  MOVF   03,W
035C:  BNZ   0366
035E:  MOVF   00,F
0360:  MOVLB  0
0362:  BZ    0384
0364:  MOVLB  1
0366:  MOVF   03,W
0368:  BNZ   0374
036A:  MOVLW  01
036C:  SUBWF  00,W
036E:  MOVLB  0
0370:  BZ    03A0
0372:  MOVLB  1
0374:  MOVF   03,W
0376:  BNZ   0382
0378:  MOVLW  02
037A:  SUBWF  00,W
037C:  MOVLB  0
037E:  BZ    03BC
0380:  MOVLB  1
0382:  BRA    03D6
....................     case 0: 
....................       r=255- WheelPos % 256;   //Red down 
0384:  MOVLB  1
0386:  CLRF   03
0388:  MOVF   x2F,W
038A:  SUBLW  FF
038C:  MOVWF  x31
038E:  MOVLW  00
0390:  SUBFWB 03,W
0392:  MOVWF  x32
....................       g=WheelPos % 256;      // Green up 
0394:  MOVFF  12F,133
0398:  CLRF   x34
....................       b=0;                  //blue off 
039A:  CLRF   x36
039C:  CLRF   x35
....................       break; 
039E:  BRA    03D6
....................     case 1: 
....................       g=255- WheelPos % 256;  //green down 
03A0:  MOVLB  1
03A2:  CLRF   03
03A4:  MOVF   x2F,W
03A6:  SUBLW  FF
03A8:  MOVWF  x33
03AA:  MOVLW  00
03AC:  SUBFWB 03,W
03AE:  MOVWF  x34
....................       b=WheelPos % 256;      //blue up 
03B0:  MOVFF  12F,135
03B4:  CLRF   x36
....................       r=0;                  //red off 
03B6:  CLRF   x32
03B8:  CLRF   x31
....................       break; 
03BA:  BRA    03D6
....................     case 2: 
....................       b=255- WheelPos % 256;  //blue down 
03BC:  MOVLB  1
03BE:  CLRF   03
03C0:  MOVF   x2F,W
03C2:  SUBLW  FF
03C4:  MOVWF  x35
03C6:  MOVLW  00
03C8:  SUBFWB 03,W
03CA:  MOVWF  x36
....................       r=WheelPos % 256;      //red up 
03CC:  MOVFF  12F,131
03D0:  CLRF   x32
....................       g=0;                  //green off 
03D2:  CLRF   x34
03D4:  CLRF   x33
....................       break; 
....................   } 
....................   return(Color(r,g,b)); 
03D6:  MOVFF  131,137
03DA:  MOVFF  133,138
03DE:  MOVFF  135,139
03E2:  MOVLB  0
03E4:  RCALL  00D8
03E6:  RETURN 0
.................... } 
....................  
.................... //make all LEDS one color (overloaded function) 
.................... void MakeAllColor(int32 color_set){ 
.................... 	int i; 
.................... 	for(i=0; i<TDOTS; i++) 
*
024E:  MOVLB  1
0250:  CLRF   x2F
0252:  MOVF   x2F,W
0254:  SUBLW  2A
0256:  BNC   027E
.................... 	{ 
....................             node_list[i] = color_set; 
0258:  MOVF   x2F,W
025A:  MULLW  04
025C:  MOVF   FF3,W
025E:  CLRF   03
0260:  ADDLW  0A
0262:  MOVWF  FE9
0264:  MOVLW  00
0266:  ADDWFC 03,W
0268:  MOVWF  FEA
026A:  MOVFF  12B,FEF
026E:  MOVFF  12C,FEC
0272:  MOVFF  12D,FEC
0276:  MOVFF  12E,FEC
027A:  INCF   x2F,F
027C:  BRA    0252
.................... 	} 
.................... 	send_frame(); 
027E:  MOVLB  0
0280:  RCALL  015E
0282:  RETURN 0
.................... } 
....................  
.................... //make all LEDS one color, overloaded to accept red, green blue inputs 
.................... void MakeAllColor(int red, int green, int blue) { 
.................... 	int i; 
.................... 	for(i=0; i<TDOTS; i++) 
.................... 	{ 
....................             node_list[i] = color(red, green, blue); 
.................... 	} 
.................... 	send_frame(); 
.................... } 
....................  
.................... void setup() { 
....................     int x; 
....................     //Clear out the array 
....................     for(x = 0; x < TDOTS ; x++){ 
*
121A:  CLRF   xE8
121C:  MOVF   xE8,W
121E:  SUBLW  2A
1220:  BNC   124A
....................         node_list[x] = 0; 
1222:  MOVF   xE8,W
1224:  MULLW  04
1226:  MOVF   FF3,W
1228:  CLRF   03
122A:  ADDLW  0A
122C:  MOVWF  FE9
122E:  MOVLW  00
1230:  ADDWFC 03,W
1232:  MOVWF  FEA
1234:  MOVF   FEE,F
1236:  MOVF   FEE,F
1238:  CLRF   FEC
123A:  MOVF   FED,F
123C:  CLRF   FEF
123E:  MOVF   FED,F
1240:  CLRF   FEF
1242:  MOVF   FED,F
1244:  CLRF   FEF
1246:  INCF   xE8,F
1248:  BRA    121C
....................     } 
....................     send_frame(); 
124A:  CALL   015E
124E:  GOTO   12EE (RETURN)
.................... } 
....................  
.................... void ShiftRight(int32 newval){ 
....................         int newPosition; 
.................... 	for(newPosition = (TDOTS)-1; newPosition > 0; newPosition--) { 
*
08BC:  MOVLW  2A
08BE:  MOVLB  1
08C0:  MOVWF  x37
08C2:  MOVF   x37,F
08C4:  BZ    091E
....................             node_list[newPosition] = node_list[newPosition - 1]; 
08C6:  MOVF   x37,W
08C8:  MULLW  04
08CA:  MOVF   FF3,W
08CC:  CLRF   03
08CE:  ADDLW  0A
08D0:  MOVWF  01
08D2:  MOVLW  00
08D4:  ADDWFC 03,F
08D6:  MOVFF  01,138
08DA:  MOVFF  03,139
08DE:  MOVLW  01
08E0:  SUBWF  x37,W
08E2:  MULLW  04
08E4:  MOVF   FF3,W
08E6:  CLRF   03
08E8:  ADDLW  0A
08EA:  MOVWF  FE9
08EC:  MOVLW  00
08EE:  ADDWFC 03,W
08F0:  MOVWF  FEA
08F2:  MOVFF  FEF,00
08F6:  MOVFF  FEC,01
08FA:  MOVFF  FEC,02
08FE:  MOVFF  FEC,03
0902:  MOVFF  139,FEA
0906:  MOVFF  138,FE9
090A:  MOVFF  00,FEF
090E:  MOVFF  01,FEC
0912:  MOVFF  02,FEC
0916:  MOVFF  03,FEC
091A:  DECF   x37,F
091C:  BRA    08C2
.................... 	} 
.................... 	node_list[0] = newval; // fill the gap 
091E:  MOVFF  136,0D
0922:  MOVFF  135,0C
0926:  MOVFF  134,0B
092A:  MOVFF  133,0A
092E:  MOVLB  0
0930:  RETURN 0
.................... } 
....................  
.................... void ShiftLeft(int32 newval){ 
....................         int newPosition; 
.................... 	for(newPosition = 0; newPosition < (TDOTS - 1); newPosition++) { 
....................             node_list[newPosition] = node_list[newPosition + 1]; 
.................... 	} 
.................... 	node_list[TDOTS - 1] = newval; // fill the gap 
.................... } 
....................  
.................... #include "LED_Patterns.c" 
.................... //FILE NAME = LED_Patterns.h 
.................... // A Collection of patterns to run using WS2801 leds using the RTOS system 
....................  
.................... void MakeAllRed(){ 
....................     MakeAllColor(Color(255, 0, 0)); 
*
0284:  MOVLB  1
0286:  SETF   x37
0288:  CLRF   x38
028A:  CLRF   x39
028C:  MOVLB  0
028E:  RCALL  00D8
0290:  MOVFF  03,12A
0294:  MOVFF  02,129
0298:  MOVFF  01,128
029C:  MOVFF  00,127
02A0:  MOVFF  03,12E
02A4:  MOVFF  02,12D
02A8:  MOVFF  01,12C
02AC:  MOVFF  00,12B
02B0:  RCALL  024E
02B2:  GOTO   0C3C (RETURN)
.................... } 
....................  
.................... void MakeAllGreen(){ 
....................     MakeAllColor(Color(0, 255, 0)); 
02B6:  MOVLB  1
02B8:  CLRF   x37
02BA:  SETF   x38
02BC:  CLRF   x39
02BE:  MOVLB  0
02C0:  RCALL  00D8
02C2:  MOVFF  03,12A
02C6:  MOVFF  02,129
02CA:  MOVFF  01,128
02CE:  MOVFF  00,127
02D2:  MOVFF  03,12E
02D6:  MOVFF  02,12D
02DA:  MOVFF  01,12C
02DE:  MOVFF  00,12B
02E2:  RCALL  024E
02E4:  GOTO   0C46 (RETURN)
.................... } 
....................  
.................... void MakeAllBlue(){ 
....................     MakeAllColor(Color(0, 0, 255)); 
02E8:  MOVLB  1
02EA:  CLRF   x37
02EC:  CLRF   x38
02EE:  SETF   x39
02F0:  MOVLB  0
02F2:  RCALL  00D8
02F4:  MOVFF  03,12A
02F8:  MOVFF  02,129
02FC:  MOVFF  01,128
0300:  MOVFF  00,127
0304:  MOVFF  03,12E
0308:  MOVFF  02,12D
030C:  MOVFF  01,12C
0310:  MOVFF  00,12B
0314:  RCALL  024E
0316:  GOTO   0C50 (RETURN)
.................... } 
....................  
.................... void All_Rainbow_Fade_200ms() { 
....................     //Slow fade all colors       
....................     if (pattern_position[0] < 768) { 
*
0416:  MOVF   xBB,W
0418:  SUBLW  02
041A:  BNC   048A
....................         if (Timer_Get_Timer(0) > 200) { 
041C:  MOVLB  1
041E:  CLRF   x2F
0420:  MOVLB  0
0422:  RCALL  031A
0424:  MOVFF  03,12A
0428:  MOVFF  02,129
042C:  MOVFF  01,128
0430:  MOVFF  00,127
0434:  MOVLB  1
0436:  MOVF   x2A,F
0438:  BNZ   0448
043A:  MOVF   x29,F
043C:  BNZ   0448
043E:  MOVF   x28,F
0440:  BNZ   0448
0442:  MOVF   x27,W
0444:  SUBLW  C8
0446:  BC    0486
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
.................... #endif 
....................             MakeAllColor(Wheel(pattern_position[0])); 
0448:  MOVFF  BB,130
044C:  MOVFF  BA,12F
0450:  MOVLB  0
0452:  RCALL  0352
0454:  MOVFF  03,12A
0458:  MOVFF  02,129
045C:  MOVFF  01,128
0460:  MOVFF  00,127
0464:  MOVFF  03,12E
0468:  MOVFF  02,12D
046C:  MOVFF  01,12C
0470:  MOVFF  00,12B
0474:  RCALL  024E
....................             pattern_position[0]++; 
0476:  INCF   xBA,F
0478:  BTFSC  FD8.2
047A:  INCF   xBB,F
....................             Timer_Clear_Timer(0); 
047C:  MOVLB  1
047E:  CLRF   x2F
0480:  MOVLB  0
0482:  RCALL  03E8
0484:  MOVLB  1
....................         } 
....................     } else { 
0486:  BRA    0490
0488:  MOVLB  0
....................         pattern_position[0] = 0; 
048A:  CLRF   xBB
048C:  CLRF   xBA
048E:  MOVLB  1
....................     } 
0490:  MOVLB  0
0492:  GOTO   0C5C (RETURN)
.................... } 
....................  
.................... void Dot_Rainbow_Fade() { 
....................     int16 i; 
....................     int32 temp_color; 
....................     // 3 cycles of all 768 colors in the wheel 
....................     if (pattern_position[0] < 768) { 
*
04FE:  MOVF   xBB,W
0500:  SUBLW  02
0502:  BTFSS  FD8.0
0504:  BRA    0612
....................         if (Timer_Get_Timer(0) > delay_time_ms) { 
0506:  MOVLB  1
0508:  CLRF   x2F
050A:  MOVLB  0
050C:  RCALL  031A
050E:  MOVFF  03,130
0512:  MOVFF  02,12F
0516:  MOVFF  01,12E
051A:  MOVFF  00,12D
051E:  MOVLB  1
0520:  MOVF   x30,F
0522:  BNZ   0544
0524:  MOVF   x2F,F
0526:  BNZ   0544
0528:  MOVLB  0
052A:  MOVF   xC7,W
052C:  MOVLB  1
052E:  SUBWF  x2E,W
0530:  BNC   060E
0532:  BNZ   0544
0534:  MOVF   x2D,W
0536:  MOVLB  0
0538:  SUBWF  xC6,W
053A:  BTFSS  FD8.0
053C:  BRA    0542
053E:  MOVLB  1
0540:  BRA    060E
0542:  MOVLB  1
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
.................... #endif 
....................             for (i = 0; i < TDOTS; i++) { 
0544:  CLRF   x28
0546:  CLRF   x27
0548:  MOVF   x28,F
054A:  BNZ   05FA
054C:  MOVF   x27,W
054E:  SUBLW  2A
0550:  BNC   05FA
....................                 temp_color = Wheel(((i * 20) + (pattern_position[0] * 10)) % 768); 
0552:  MOVFF  128,130
0556:  MOVFF  127,12F
055A:  CLRF   x32
055C:  MOVLW  14
055E:  MOVWF  x31
0560:  MOVLB  0
0562:  RCALL  0496
0564:  MOVFF  02,12E
0568:  MOVFF  01,12D
056C:  MOVFF  BB,130
0570:  MOVFF  BA,12F
0574:  MOVLB  1
0576:  CLRF   x32
0578:  MOVLW  0A
057A:  MOVWF  x31
057C:  MOVLB  0
057E:  RCALL  0496
0580:  MOVFF  02,03
0584:  MOVF   01,W
0586:  MOVLB  1
0588:  ADDWF  x2D,F
058A:  MOVF   02,W
058C:  ADDWFC x2E,F
058E:  MOVFF  12E,131
0592:  MOVFF  12D,130
0596:  MOVLW  03
0598:  MOVWF  x33
059A:  CLRF   x32
059C:  MOVLB  0
059E:  RCALL  04B8
05A0:  MOVFF  00,12D
05A4:  MOVFF  03,12E
05A8:  MOVFF  03,130
05AC:  MOVFF  00,12F
05B0:  MOVLB  0
05B2:  RCALL  0352
05B4:  MOVFF  03,12C
05B8:  MOVFF  02,12B
05BC:  MOVFF  01,12A
05C0:  MOVFF  00,129
....................                 node_list[i] = temp_color; 
05C4:  MOVLB  1
05C6:  RLCF   x27,W
05C8:  MOVWF  02
05CA:  RLCF   x28,W
05CC:  MOVWF  03
05CE:  RLCF   02,F
05D0:  RLCF   03,F
05D2:  MOVLW  FC
05D4:  ANDWF  02,F
05D6:  MOVF   02,W
05D8:  ADDLW  0A
05DA:  MOVWF  FE9
05DC:  MOVLW  00
05DE:  ADDWFC 03,W
05E0:  MOVWF  FEA
05E2:  MOVFF  129,FEF
05E6:  MOVFF  12A,FEC
05EA:  MOVFF  12B,FEC
05EE:  MOVFF  12C,FEC
05F2:  INCF   x27,F
05F4:  BTFSC  FD8.2
05F6:  INCF   x28,F
05F8:  BRA    0548
....................             } 
....................             send_frame(); 
05FA:  MOVLB  0
05FC:  RCALL  015E
....................             pattern_position[0]++; 
05FE:  INCF   xBA,F
0600:  BTFSC  FD8.2
0602:  INCF   xBB,F
....................             Timer_Clear_Timer(0); 
0604:  MOVLB  1
0606:  CLRF   x2F
0608:  MOVLB  0
060A:  RCALL  03E8
060C:  MOVLB  1
....................         } 
....................     } else { 
060E:  BRA    0618
0610:  MOVLB  0
....................         pattern_position[0] = 0; 
0612:  CLRF   xBB
0614:  CLRF   xBA
0616:  MOVLB  1
....................     } 
0618:  MOVLB  0
061A:  GOTO   0C64 (RETURN)
.................... } 
....................  
.................... void All_Rainbow_Fade() { 
....................     //Slow fade all colors 
....................     if (pattern_position[0] < 768) { 
061E:  MOVF   xBB,W
0620:  SUBLW  02
0622:  BNC   06A4
....................         if (Timer_Get_Timer(0) > delay_time_ms) { 
0624:  MOVLB  1
0626:  CLRF   x2F
0628:  MOVLB  0
062A:  RCALL  031A
062C:  MOVFF  03,12A
0630:  MOVFF  02,129
0634:  MOVFF  01,128
0638:  MOVFF  00,127
063C:  MOVLB  1
063E:  MOVF   x2A,F
0640:  BNZ   0662
0642:  MOVF   x29,F
0644:  BNZ   0662
0646:  MOVLB  0
0648:  MOVF   xC7,W
064A:  MOVLB  1
064C:  SUBWF  x28,W
064E:  BNC   06A0
0650:  BNZ   0662
0652:  MOVF   x27,W
0654:  MOVLB  0
0656:  SUBWF  xC6,W
0658:  BTFSS  FD8.0
065A:  BRA    0660
065C:  MOVLB  1
065E:  BRA    06A0
0660:  MOVLB  1
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
.................... #endif 
....................             MakeAllColor(Wheel(pattern_position[0])); 
0662:  MOVFF  BB,130
0666:  MOVFF  BA,12F
066A:  MOVLB  0
066C:  RCALL  0352
066E:  MOVFF  03,12A
0672:  MOVFF  02,129
0676:  MOVFF  01,128
067A:  MOVFF  00,127
067E:  MOVFF  03,12E
0682:  MOVFF  02,12D
0686:  MOVFF  01,12C
068A:  MOVFF  00,12B
068E:  RCALL  024E
....................             pattern_position[0]++; 
0690:  INCF   xBA,F
0692:  BTFSC  FD8.2
0694:  INCF   xBB,F
....................             Timer_Clear_Timer(0); 
0696:  MOVLB  1
0698:  CLRF   x2F
069A:  MOVLB  0
069C:  RCALL  03E8
069E:  MOVLB  1
....................         } 
....................     } else { 
06A0:  BRA    06AA
06A2:  MOVLB  0
....................         pattern_position[0] = 0; 
06A4:  CLRF   xBB
06A6:  CLRF   xBA
06A8:  MOVLB  1
....................     } 
06AA:  MOVLB  0
06AC:  GOTO   0C6C (RETURN)
.................... } 
....................  
.................... void Random_Chain() { 
....................     //Start with random colors then push random colors down 
....................     if (Timer_Get_Timer(0) > delay_time_ms*2) { 
*
0868:  MOVLB  1
086A:  CLRF   x2F
086C:  MOVLB  0
086E:  RCALL  031A
0870:  MOVFF  03,12A
0874:  MOVFF  02,129
0878:  MOVFF  01,128
087C:  MOVFF  00,127
0880:  BCF    FD8.0
0882:  RLCF   xC6,W
0884:  MOVWF  02
0886:  RLCF   xC7,W
0888:  MOVWF  03
088A:  MOVFF  02,01
088E:  MOVLB  1
0890:  MOVF   x2A,F
0892:  BNZ   08A6
0894:  MOVF   x29,F
0896:  BNZ   08A6
0898:  MOVF   03,W
089A:  SUBWF  x28,W
089C:  BNC   08B6
089E:  BNZ   08A6
08A0:  MOVF   x27,W
08A2:  SUBWF  01,W
08A4:  BC    08B6
....................         addRandom(); 
08A6:  MOVLB  0
08A8:  BRA    077C
....................         send_frame(); 
08AA:  RCALL  015E
....................         Timer_Clear_Timer(0); 
08AC:  MOVLB  1
08AE:  CLRF   x2F
08B0:  MOVLB  0
08B2:  RCALL  03E8
08B4:  MOVLB  1
....................     } 
08B6:  MOVLB  0
08B8:  GOTO   0C74 (RETURN)
.................... } 
....................  
.................... //push in 3 leds of color selected than shift it 1 led each time, 3 blanks 
.................... void ShiftThreeColorThreeBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
0932:  MOVLB  1
0934:  CLRF   x2F
0936:  MOVLB  0
0938:  RCALL  031A
093A:  MOVFF  03,132
093E:  MOVFF  02,131
0942:  MOVFF  01,130
0946:  MOVFF  00,12F
094A:  MOVLB  1
094C:  MOVF   x32,F
094E:  BNZ   0970
0950:  MOVF   x31,F
0952:  BNZ   0970
0954:  MOVLB  0
0956:  MOVF   xC7,W
0958:  MOVLB  1
095A:  SUBWF  x30,W
095C:  BNC   0A02
095E:  BNZ   0970
0960:  MOVF   x2F,W
0962:  MOVLB  0
0964:  SUBWF  xC6,W
0966:  BTFSS  FD8.0
0968:  BRA    096E
096A:  MOVLB  1
096C:  BRA    0A02
096E:  MOVLB  1
....................         if (pattern_position[0] >= 6) { 
0970:  MOVLB  0
0972:  MOVF   xBB,F
0974:  BNZ   097C
0976:  MOVF   xBA,W
0978:  SUBLW  05
097A:  BC    0980
....................             pattern_position[0] = 0; 
097C:  CLRF   xBB
097E:  CLRF   xBA
....................         } 
....................         if (pattern_position[0] % 6 < 3) { 
0980:  MOVFF  BB,131
0984:  MOVFF  BA,130
0988:  MOVLB  1
098A:  CLRF   x33
098C:  MOVLW  06
098E:  MOVWF  x32
0990:  MOVLB  0
0992:  RCALL  04B8
0994:  MOVFF  00,12F
0998:  MOVLB  1
099A:  MOVFF  03,130
099E:  MOVF   x30,F
09A0:  BNZ   09C0
09A2:  MOVF   x2F,W
09A4:  SUBLW  02
09A6:  BNC   09C0
....................             ShiftRight(color_set); 
09A8:  MOVFF  12E,136
09AC:  MOVFF  12D,135
09B0:  MOVFF  12C,134
09B4:  MOVFF  12B,133
09B8:  MOVLB  0
09BA:  RCALL  08BC
....................         } else { 
09BC:  BRA    09EE
09BE:  MOVLB  1
....................             ShiftRight(color(0, 0, 0)); 
09C0:  CLRF   x37
09C2:  CLRF   x38
09C4:  CLRF   x39
09C6:  MOVLB  0
09C8:  CALL   00D8
09CC:  MOVFF  03,132
09D0:  MOVFF  02,131
09D4:  MOVFF  01,130
09D8:  MOVFF  00,12F
09DC:  MOVFF  03,136
09E0:  MOVFF  02,135
09E4:  MOVFF  01,134
09E8:  MOVFF  00,133
09EC:  RCALL  08BC
....................         } 
....................         send_frame(); 
09EE:  CALL   015E
....................         pattern_position[0]++; 
09F2:  INCF   xBA,F
09F4:  BTFSC  FD8.2
09F6:  INCF   xBB,F
....................         Timer_Clear_Timer(0); 
09F8:  MOVLB  1
09FA:  CLRF   x2F
09FC:  MOVLB  0
09FE:  RCALL  03E8
0A00:  MOVLB  1
....................     } 
0A02:  MOVLB  0
0A04:  RETURN 0
.................... } 
....................  
.................... //push in 1 leds of color selected than shift it 1 led each time, 1 blank 
.................... void ShiftOneColorOneBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
0A06:  MOVLB  1
0A08:  CLRF   x2F
0A0A:  MOVLB  0
0A0C:  RCALL  031A
0A0E:  MOVFF  03,132
0A12:  MOVFF  02,131
0A16:  MOVFF  01,130
0A1A:  MOVFF  00,12F
0A1E:  MOVLB  1
0A20:  MOVF   x32,F
0A22:  BNZ   0A44
0A24:  MOVF   x31,F
0A26:  BNZ   0A44
0A28:  MOVLB  0
0A2A:  MOVF   xC7,W
0A2C:  MOVLB  1
0A2E:  SUBWF  x30,W
0A30:  BNC   0AC0
0A32:  BNZ   0A44
0A34:  MOVF   x2F,W
0A36:  MOVLB  0
0A38:  SUBWF  xC6,W
0A3A:  BTFSS  FD8.0
0A3C:  BRA    0A42
0A3E:  MOVLB  1
0A40:  BRA    0AC0
0A42:  MOVLB  1
....................         if (pattern_position[0] >= 2) { 
0A44:  MOVLB  0
0A46:  MOVF   xBB,F
0A48:  BNZ   0A50
0A4A:  MOVF   xBA,W
0A4C:  SUBLW  01
0A4E:  BC    0A54
....................             pattern_position[0] = 0; 
0A50:  CLRF   xBB
0A52:  CLRF   xBA
....................         } 
....................         if (pattern_position[0] % 2 < 1) { 
0A54:  MOVF   xBA,W
0A56:  ANDLW  01
0A58:  MOVLB  1
0A5A:  MOVWF  x2F
0A5C:  CLRF   x30
0A5E:  MOVF   x2F,F
0A60:  BNZ   0A7E
0A62:  MOVF   x30,F
0A64:  BNZ   0A7E
....................             ShiftRight(color_set); 
0A66:  MOVFF  12E,136
0A6A:  MOVFF  12D,135
0A6E:  MOVFF  12C,134
0A72:  MOVFF  12B,133
0A76:  MOVLB  0
0A78:  RCALL  08BC
....................         } else { 
0A7A:  BRA    0AAC
0A7C:  MOVLB  1
....................             ShiftRight(color(0, 0, 0)); 
0A7E:  CLRF   x37
0A80:  CLRF   x38
0A82:  CLRF   x39
0A84:  MOVLB  0
0A86:  CALL   00D8
0A8A:  MOVFF  03,132
0A8E:  MOVFF  02,131
0A92:  MOVFF  01,130
0A96:  MOVFF  00,12F
0A9A:  MOVFF  03,136
0A9E:  MOVFF  02,135
0AA2:  MOVFF  01,134
0AA6:  MOVFF  00,133
0AAA:  RCALL  08BC
....................         } 
....................         send_frame(); 
0AAC:  CALL   015E
....................         pattern_position[0]++; 
0AB0:  INCF   xBA,F
0AB2:  BTFSC  FD8.2
0AB4:  INCF   xBB,F
....................         Timer_Clear_Timer(0); 
0AB6:  MOVLB  1
0AB8:  CLRF   x2F
0ABA:  MOVLB  0
0ABC:  RCALL  03E8
0ABE:  MOVLB  1
....................     } 
0AC0:  MOVLB  0
0AC2:  GOTO   0D74 (RETURN)
.................... } 
....................  
.................... //push in 1 leds of color selected than shift it 1 led each time, 1 blank 
.................... void ShiftOneColorTwoBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
0AC6:  MOVLB  1
0AC8:  CLRF   x2F
0ACA:  MOVLB  0
0ACC:  RCALL  031A
0ACE:  MOVFF  03,132
0AD2:  MOVFF  02,131
0AD6:  MOVFF  01,130
0ADA:  MOVFF  00,12F
0ADE:  MOVLB  1
0AE0:  MOVF   x32,F
0AE2:  BNZ   0B04
0AE4:  MOVF   x31,F
0AE6:  BNZ   0B04
0AE8:  MOVLB  0
0AEA:  MOVF   xC7,W
0AEC:  MOVLB  1
0AEE:  SUBWF  x30,W
0AF0:  BNC   0B94
0AF2:  BNZ   0B04
0AF4:  MOVF   x2F,W
0AF6:  MOVLB  0
0AF8:  SUBWF  xC6,W
0AFA:  BTFSS  FD8.0
0AFC:  BRA    0B02
0AFE:  MOVLB  1
0B00:  BRA    0B94
0B02:  MOVLB  1
....................         if (pattern_position[0] >= 3) { 
0B04:  MOVLB  0
0B06:  MOVF   xBB,F
0B08:  BNZ   0B10
0B0A:  MOVF   xBA,W
0B0C:  SUBLW  02
0B0E:  BC    0B14
....................             pattern_position[0] = 0; 
0B10:  CLRF   xBB
0B12:  CLRF   xBA
....................         } 
....................         if (pattern_position[0] % 3 < 1) { 
0B14:  MOVFF  BB,131
0B18:  MOVFF  BA,130
0B1C:  MOVLB  1
0B1E:  CLRF   x33
0B20:  MOVLW  03
0B22:  MOVWF  x32
0B24:  MOVLB  0
0B26:  RCALL  04B8
0B28:  MOVFF  00,12F
0B2C:  MOVLB  1
0B2E:  MOVFF  03,130
0B32:  MOVF   x2F,F
0B34:  BNZ   0B52
0B36:  MOVF   x30,F
0B38:  BNZ   0B52
....................             ShiftRight(color_set); 
0B3A:  MOVFF  12E,136
0B3E:  MOVFF  12D,135
0B42:  MOVFF  12C,134
0B46:  MOVFF  12B,133
0B4A:  MOVLB  0
0B4C:  RCALL  08BC
....................         } else { 
0B4E:  BRA    0B80
0B50:  MOVLB  1
....................             ShiftRight(color(0, 0, 0)); 
0B52:  CLRF   x37
0B54:  CLRF   x38
0B56:  CLRF   x39
0B58:  MOVLB  0
0B5A:  CALL   00D8
0B5E:  MOVFF  03,132
0B62:  MOVFF  02,131
0B66:  MOVFF  01,130
0B6A:  MOVFF  00,12F
0B6E:  MOVFF  03,136
0B72:  MOVFF  02,135
0B76:  MOVFF  01,134
0B7A:  MOVFF  00,133
0B7E:  RCALL  08BC
....................         } 
....................         send_frame(); 
0B80:  CALL   015E
....................         pattern_position[0]++; 
0B84:  INCF   xBA,F
0B86:  BTFSC  FD8.2
0B88:  INCF   xBB,F
....................         Timer_Clear_Timer(0); 
0B8A:  MOVLB  1
0B8C:  CLRF   x2F
0B8E:  MOVLB  0
0B90:  RCALL  03E8
0B92:  MOVLB  1
....................     } 
0B94:  MOVLB  0
0B96:  GOTO   0DAA (RETURN)
.................... } 
....................  
....................  
....................  
.................... void Clear_Pattern_Positions() { 
....................     int i; 
....................     for (i = 0; i < NUM_PATTERN_POSITION; i++) { 
*
0056:  MOVLB  1
0058:  CLRF   x27
005A:  MOVF   x27,W
005C:  SUBLW  01
005E:  BNC   007A
....................         pattern_position[i] = 0; 
0060:  BCF    FD8.0
0062:  RLCF   x27,W
0064:  CLRF   03
0066:  ADDLW  BA
0068:  MOVWF  FE9
006A:  MOVLW  00
006C:  ADDWFC 03,W
006E:  MOVWF  FEA
0070:  CLRF   FEC
0072:  MOVF   FED,F
0074:  CLRF   FEF
0076:  INCF   x27,F
0078:  BRA    005A
....................     } 
007A:  MOVLB  0
007C:  RETURN 0
.................... } 
....................  
.................... void Next_Pattern() { 
....................     if ((current_pattern + 1) >= NUM_PATTERNS) { 
*
0DBE:  MOVLW  01
0DC0:  ADDWF  xBE,W
0DC2:  MOVLB  1
0DC4:  MOVWF  x27
0DC6:  MOVLW  00
0DC8:  MOVLB  0
0DCA:  ADDWFC xBF,W
0DCC:  MOVLB  1
0DCE:  MOVWF  x28
0DD0:  MOVF   x28,F
0DD2:  BNZ   0DDA
0DD4:  MOVF   x27,W
0DD6:  SUBLW  0B
0DD8:  BC    0DE8
....................         Clear_Pattern_Positions(); 
0DDA:  MOVLB  0
0DDC:  CALL   0056
....................         current_pattern = 0; 
0DE0:  CLRF   xBF
0DE2:  CLRF   xBE
....................     }else{ 
0DE4:  BRA    0DF4
0DE6:  MOVLB  1
....................         Clear_Pattern_Positions(); 
0DE8:  MOVLB  0
0DEA:  CALL   0056
....................         current_pattern++; 
0DEE:  INCF   xBE,F
0DF0:  BTFSC  FD8.2
0DF2:  INCF   xBF,F
....................     } 
....................     pattern_set = 0; 
0DF4:  BCF    xC0.0
0DF6:  GOTO   0DFC (RETURN)
.................... } 
....................  
.................... void Previous_Pattern() { 
....................     if (current_pattern == 0){ 
*
0E00:  MOVF   xBE,F
0E02:  BNZ   0E14
0E04:  MOVF   xBF,F
0E06:  BNZ   0E14
....................         Clear_Pattern_Positions(); 
0E08:  CALL   0056
....................         current_pattern = NUM_PATTERNS - 1; 
0E0C:  CLRF   xBF
0E0E:  MOVLW  0B
0E10:  MOVWF  xBE
....................     }else{ 
0E12:  BRA    0E20
....................         Clear_Pattern_Positions(); 
0E14:  CALL   0056
....................         current_pattern--; 
0E18:  MOVF   xBE,W
0E1A:  BTFSC  FD8.2
0E1C:  DECF   xBF,F
0E1E:  DECF   xBE,F
....................     } 
....................     pattern_set = 0; 
0E20:  BCF    xC0.0
0E22:  GOTO   0E28 (RETURN)
.................... } 
....................  
.................... void Speed_Up_Pattern() { 
....................     if(delay_time_ms < 3000){ 
*
0E2C:  MOVF   xC7,W
0E2E:  SUBLW  0B
0E30:  BNC   0E42
0E32:  BNZ   0E3A
0E34:  MOVF   xC6,W
0E36:  SUBLW  B7
0E38:  BNC   0E42
....................         delay_time_ms = delay_time_ms + DELAY_TIME_MS_JUMP; 
0E3A:  MOVLW  32
0E3C:  ADDWF  xC6,F
0E3E:  MOVLW  00
0E40:  ADDWFC xC7,F
....................     } 
0E42:  GOTO   0E48 (RETURN)
.................... } 
....................  
.................... void Slow_Down_Pattern() { 
....................     if(delay_time_ms >= DELAY_TIME_MS_JUMP){ 
*
0E4C:  MOVF   xC7,F
0E4E:  BNZ   0E56
0E50:  MOVF   xC6,W
0E52:  SUBLW  31
0E54:  BC    0E5E
....................         delay_time_ms = delay_time_ms - DELAY_TIME_MS_JUMP; 
0E56:  MOVLW  32
0E58:  SUBWF  xC6,F
0E5A:  MOVLW  00
0E5C:  SUBWFB xC7,F
....................     } 
0E5E:  GOTO   0E64 (RETURN)
.................... } 
....................  
.................... void Toggle_Autochange_Pattern() { 
....................     if (autochange_pattern == 0) { 
*
0E90:  MOVF   xC5,F
0E92:  BTFSS  FD8.2
0E94:  BRA    0FB8
....................         //blink green twice 
....................         pattern_set = 1; 
0E96:  BSF    xC0.0
....................         continue_pattern_calling = 0; 
0E98:  BCF    xC0.1
....................         //make all green 
....................         MakeAllColor(Color(0, 255, 0)); 
0E9A:  MOVLB  1
0E9C:  CLRF   x37
0E9E:  SETF   x38
0EA0:  CLRF   x39
0EA2:  MOVLB  0
0EA4:  CALL   00D8
0EA8:  MOVFF  03,12A
0EAC:  MOVFF  02,129
0EB0:  MOVFF  01,128
0EB4:  MOVFF  00,127
0EB8:  MOVFF  03,12E
0EBC:  MOVFF  02,12D
0EC0:  MOVFF  01,12C
0EC4:  MOVFF  00,12B
0EC8:  CALL   024E
....................         delay_ms(500); 
0ECC:  MOVLW  02
0ECE:  MOVLB  1
0ED0:  MOVWF  x27
0ED2:  MOVLW  FA
0ED4:  MOVWF  x28
0ED6:  MOVLB  0
0ED8:  RCALL  0E68
0EDA:  MOVLB  1
0EDC:  DECFSZ x27,F
0EDE:  BRA    0ED2
....................         MakeAllColor(Color(0, 0, 0)); 
0EE0:  CLRF   x37
0EE2:  CLRF   x38
0EE4:  CLRF   x39
0EE6:  MOVLB  0
0EE8:  CALL   00D8
0EEC:  MOVFF  03,12A
0EF0:  MOVFF  02,129
0EF4:  MOVFF  01,128
0EF8:  MOVFF  00,127
0EFC:  MOVFF  03,12E
0F00:  MOVFF  02,12D
0F04:  MOVFF  01,12C
0F08:  MOVFF  00,12B
0F0C:  CALL   024E
....................         delay_ms(500); 
0F10:  MOVLW  02
0F12:  MOVLB  1
0F14:  MOVWF  x27
0F16:  MOVLW  FA
0F18:  MOVWF  x28
0F1A:  MOVLB  0
0F1C:  RCALL  0E68
0F1E:  MOVLB  1
0F20:  DECFSZ x27,F
0F22:  BRA    0F16
....................         MakeAllColor(Color(0, 255, 0)); 
0F24:  CLRF   x37
0F26:  SETF   x38
0F28:  CLRF   x39
0F2A:  MOVLB  0
0F2C:  CALL   00D8
0F30:  MOVFF  03,12A
0F34:  MOVFF  02,129
0F38:  MOVFF  01,128
0F3C:  MOVFF  00,127
0F40:  MOVFF  03,12E
0F44:  MOVFF  02,12D
0F48:  MOVFF  01,12C
0F4C:  MOVFF  00,12B
0F50:  CALL   024E
....................         delay_ms(500); 
0F54:  MOVLW  02
0F56:  MOVLB  1
0F58:  MOVWF  x27
0F5A:  MOVLW  FA
0F5C:  MOVWF  x28
0F5E:  MOVLB  0
0F60:  RCALL  0E68
0F62:  MOVLB  1
0F64:  DECFSZ x27,F
0F66:  BRA    0F5A
....................         MakeAllColor(Color(0, 0, 0)); 
0F68:  CLRF   x37
0F6A:  CLRF   x38
0F6C:  CLRF   x39
0F6E:  MOVLB  0
0F70:  CALL   00D8
0F74:  MOVFF  03,12A
0F78:  MOVFF  02,129
0F7C:  MOVFF  01,128
0F80:  MOVFF  00,127
0F84:  MOVFF  03,12E
0F88:  MOVFF  02,12D
0F8C:  MOVFF  01,12C
0F90:  MOVFF  00,12B
0F94:  CALL   024E
....................         delay_ms(500); 
0F98:  MOVLW  02
0F9A:  MOVLB  1
0F9C:  MOVWF  x27
0F9E:  MOVLW  FA
0FA0:  MOVWF  x28
0FA2:  MOVLB  0
0FA4:  RCALL  0E68
0FA6:  MOVLB  1
0FA8:  DECFSZ x27,F
0FAA:  BRA    0F9E
....................         autochange_pattern = 1; 
0FAC:  MOVLW  01
0FAE:  MOVLB  0
0FB0:  MOVWF  xC5
....................         pattern_set = 0; 
0FB2:  BCF    xC0.0
....................         continue_pattern_calling = 1; 
0FB4:  BSF    xC0.1
....................     } else { 
0FB6:  BRA    10D6
....................         //blink green twice 
....................         pattern_set = 1; 
0FB8:  BSF    xC0.0
....................         continue_pattern_calling = 0; 
0FBA:  BCF    xC0.1
....................         //make all green 
....................         MakeAllColor(Color(255, 0, 0)); 
0FBC:  MOVLB  1
0FBE:  SETF   x37
0FC0:  CLRF   x38
0FC2:  CLRF   x39
0FC4:  MOVLB  0
0FC6:  CALL   00D8
0FCA:  MOVFF  03,12A
0FCE:  MOVFF  02,129
0FD2:  MOVFF  01,128
0FD6:  MOVFF  00,127
0FDA:  MOVFF  03,12E
0FDE:  MOVFF  02,12D
0FE2:  MOVFF  01,12C
0FE6:  MOVFF  00,12B
0FEA:  CALL   024E
....................         delay_ms(500); 
0FEE:  MOVLW  02
0FF0:  MOVLB  1
0FF2:  MOVWF  x27
0FF4:  MOVLW  FA
0FF6:  MOVWF  x28
0FF8:  MOVLB  0
0FFA:  RCALL  0E68
0FFC:  MOVLB  1
0FFE:  DECFSZ x27,F
1000:  BRA    0FF4
....................         MakeAllColor(Color(0, 0, 0)); 
1002:  CLRF   x37
1004:  CLRF   x38
1006:  CLRF   x39
1008:  MOVLB  0
100A:  CALL   00D8
100E:  MOVFF  03,12A
1012:  MOVFF  02,129
1016:  MOVFF  01,128
101A:  MOVFF  00,127
101E:  MOVFF  03,12E
1022:  MOVFF  02,12D
1026:  MOVFF  01,12C
102A:  MOVFF  00,12B
102E:  CALL   024E
....................         delay_ms(500); 
1032:  MOVLW  02
1034:  MOVLB  1
1036:  MOVWF  x27
1038:  MOVLW  FA
103A:  MOVWF  x28
103C:  MOVLB  0
103E:  RCALL  0E68
1040:  MOVLB  1
1042:  DECFSZ x27,F
1044:  BRA    1038
....................         MakeAllColor(Color(255, 0, 0)); 
1046:  SETF   x37
1048:  CLRF   x38
104A:  CLRF   x39
104C:  MOVLB  0
104E:  CALL   00D8
1052:  MOVFF  03,12A
1056:  MOVFF  02,129
105A:  MOVFF  01,128
105E:  MOVFF  00,127
1062:  MOVFF  03,12E
1066:  MOVFF  02,12D
106A:  MOVFF  01,12C
106E:  MOVFF  00,12B
1072:  CALL   024E
....................         delay_ms(500); 
1076:  MOVLW  02
1078:  MOVLB  1
107A:  MOVWF  x27
107C:  MOVLW  FA
107E:  MOVWF  x28
1080:  MOVLB  0
1082:  RCALL  0E68
1084:  MOVLB  1
1086:  DECFSZ x27,F
1088:  BRA    107C
....................         MakeAllColor(Color(0, 0, 0)); 
108A:  CLRF   x37
108C:  CLRF   x38
108E:  CLRF   x39
1090:  MOVLB  0
1092:  CALL   00D8
1096:  MOVFF  03,12A
109A:  MOVFF  02,129
109E:  MOVFF  01,128
10A2:  MOVFF  00,127
10A6:  MOVFF  03,12E
10AA:  MOVFF  02,12D
10AE:  MOVFF  01,12C
10B2:  MOVFF  00,12B
10B6:  CALL   024E
....................         delay_ms(500); 
10BA:  MOVLW  02
10BC:  MOVLB  1
10BE:  MOVWF  x27
10C0:  MOVLW  FA
10C2:  MOVWF  x28
10C4:  MOVLB  0
10C6:  RCALL  0E68
10C8:  MOVLB  1
10CA:  DECFSZ x27,F
10CC:  BRA    10C0
....................         autochange_pattern = 0; 
10CE:  MOVLB  0
10D0:  CLRF   xC5
....................         pattern_set = 0; 
10D2:  BCF    xC0.0
....................         continue_pattern_calling = 1; 
10D4:  BSF    xC0.1
....................     } 
10D6:  GOTO   10DC (RETURN)
.................... } 
....................  
.................... #include "Buttons.c" 
.................... //FILE NAME = Buttons.h 
.................... //Functions to deal with buttons being pressed 
....................  
.................... void Power_Button_Function() { 
.................... #ifdef TEST 
*
0DBA:  GOTO   11A6 (RETURN)
....................     if (led_power_status == 0) { //turning on 
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Turning on Power to LEDs\n\r"); 
.................... #endif 
....................         OUTPUT_LOW(LED_ON_PIN); 
....................         led_power_status = 1; //LED IS ON 
....................         delay_us(100); 
....................         send_frame(); 
....................     } else { //turning off 
....................         OUTPUT_HIGH(LED_ON_PIN); 
....................         led_power_status = 0; //LEDS are off 
....................         disable_interrupts(GLOBAL); 
.................... /*for 16f 
....................         clear_interrupt(INT_IOC_A0_L2H); 
....................         delay_us(200); 
....................         enable_interrupts(INT_IOC_A0_L2H); 
....................  */ 
.................... //for 18f         
....................         clear_interrupt(INT_EXT_L2H); 
....................         delay_us(200); 
....................         enable_interrupts(INT_EXT_L2H); 
....................  
....................  
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Going to Sleep\n\r"); 
.................... #endif 
....................         sleep(); 
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Wake Up\n\r"); 
.................... #endif 
....................  
....................         delay_cycles(1); 
.................... /*for 16f 
....................         disable_interrupts(INT_IOC_A0_L2H); 
....................  */ 
....................  
.................... // for 18f 
....................         disable_interrupts(INT_EXT_L2H); 
....................          
....................         rtos_disable(Button_Checker); 
....................         OUTPUT_LOW(LED_ON_PIN); 
....................         led_power_status = 1; //LED IS ON 
....................         delay_ms(50); 
....................         send_frame(); 
....................         delay_ms(300); 
....................         rtos_enable(Button_Checker); 
....................     } 
.................... #endif 
.................... } 
....................  
.................... void Up_Button_Function() { 
....................     Next_Pattern(); 
*
0DFA:  BRA    0DBE
0DFC:  GOTO   11BA (RETURN)
.................... } 
....................  
.................... void Down_Button_Function() { 
....................     Previous_Pattern(); 
*
0E26:  BRA    0E00
0E28:  GOTO   11CE (RETURN)
.................... } 
....................  
.................... void Left_Button_Function() { 
....................     Speed_Up_Pattern(); 
*
0E46:  BRA    0E2C
0E48:  GOTO   11E2 (RETURN)
.................... } 
....................  
.................... void Right_Button_Function() { 
....................     Slow_Down_Pattern(); 
*
0E62:  BRA    0E4C
0E64:  GOTO   11F6 (RETURN)
.................... } 
....................  
.................... void Center_Button_Function() { 
....................     Toggle_Autochange_Pattern(); 
*
10DA:  BRA    0E90
10DC:  GOTO   120A (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include "RTOS_Functions.c" 
.................... //FILE NAME = LED_Patterns.h 
.................... // A Collection of functions to be called by the RTOS 
....................  
.................... void Pattern_Selector() { 
....................     switch (autochange_pattern) { 
*
007E:  MOVF   xC5,W
0080:  XORLW  00
0082:  BZ    008A
0084:  XORLW  01
0086:  BZ    008E
0088:  BRA    0092
....................         case 0: 
....................             rtos_disable(Pattern_Selector); 
008A:  BSF    xC9.7
....................             break; 
008C:  BRA    0092
....................         case 1: 
....................             rtos_enable(Pattern_Selector); 
008E:  BCF    xC9.7
....................             break; 
0090:  BRA    0092
....................         default: 
....................             break; 
....................     } 
....................     if (autochange_pattern) { 
0092:  MOVF   xC5,F
0094:  BZ    00CA
....................         if ((current_pattern + 1) == NUM_PATTERNS) { 
0096:  MOVLW  01
0098:  ADDWF  xBE,W
009A:  MOVLB  1
009C:  MOVWF  x27
009E:  MOVLW  00
00A0:  MOVLB  0
00A2:  ADDWFC xBF,W
00A4:  MOVLB  1
00A6:  MOVWF  x28
00A8:  MOVF   x27,W
00AA:  SUBLW  0C
00AC:  BNZ   00BE
00AE:  MOVF   x28,F
00B0:  BNZ   00BE
....................             current_pattern = 0; 
00B2:  MOVLB  0
00B4:  CLRF   xBF
00B6:  CLRF   xBE
....................             Clear_Pattern_Positions(); 
00B8:  RCALL  0056
....................         } else { 
00BA:  BRA    00C8
00BC:  MOVLB  1
....................             current_pattern++; 
00BE:  MOVLB  0
00C0:  INCF   xBE,F
00C2:  BTFSC  FD8.2
00C4:  INCF   xBF,F
....................             Clear_Pattern_Positions(); 
00C6:  RCALL  0056
....................         } 
....................         pattern_set = 0; 
00C8:  BCF    xC0.0
....................         //rtos_disable(Pattern_Selector); 
....................     } 
00CA:  MOVLW  7E
00CC:  MOVWF  xCE
00CE:  MOVLW  00
00D0:  MOVWF  xCF
00D2:  GOTO   13DE
00D6:  RETURN 0
.................... } 
....................  
.................... void Update_Pattern() { 
.................... #ifdef DEBUG_SERIAL 
....................     if (pattern_set == 0) { 
....................         printf("Changing Pattern to %Lu\n\r", current_pattern); 
....................     } 
.................... #endif 
....................  
....................     switch (autochange_pattern) { 
*
0B9A:  MOVF   xC5,W
0B9C:  XORLW  00
0B9E:  BZ    0BA6
0BA0:  XORLW  01
0BA2:  BZ    0BAA
0BA4:  BRA    0BAE
....................         case 0: 
....................             rtos_disable(Pattern_Selector); 
0BA6:  BSF    xC9.7
....................             break; 
0BA8:  BRA    0BAE
....................         case 1: 
....................             rtos_enable(Pattern_Selector); 
0BAA:  BCF    xC9.7
....................             break; 
0BAC:  BRA    0BAE
....................         default: 
....................             break; 
....................     } 
....................      
....................     if (pattern_set == 0 || continue_pattern_calling == 1) { 
0BAE:  BTFSS  xC0.0
0BB0:  BRA    0BB6
0BB2:  BTFSS  xC0.1
0BB4:  BRA    0DAC
....................         switch (current_pattern) { 
0BB6:  MOVFF  BE,00
0BBA:  MOVF   xBF,W
0BBC:  MOVWF  03
0BBE:  BNZ   0BC4
0BC0:  MOVF   00,F
0BC2:  BZ    0C38
0BC4:  MOVF   03,W
0BC6:  BNZ   0BCE
0BC8:  MOVLW  01
0BCA:  SUBWF  00,W
0BCC:  BZ    0C42
0BCE:  MOVF   03,W
0BD0:  BNZ   0BD8
0BD2:  MOVLW  02
0BD4:  SUBWF  00,W
0BD6:  BZ    0C4C
0BD8:  MOVF   03,W
0BDA:  BNZ   0BE2
0BDC:  MOVLW  03
0BDE:  SUBWF  00,W
0BE0:  BZ    0C56
0BE2:  MOVF   03,W
0BE4:  BNZ   0BEC
0BE6:  MOVLW  04
0BE8:  SUBWF  00,W
0BEA:  BZ    0C60
0BEC:  MOVF   03,W
0BEE:  BNZ   0BF6
0BF0:  MOVLW  05
0BF2:  SUBWF  00,W
0BF4:  BZ    0C68
0BF6:  MOVF   03,W
0BF8:  BNZ   0C00
0BFA:  MOVLW  06
0BFC:  SUBWF  00,W
0BFE:  BZ    0C70
0C00:  MOVF   03,W
0C02:  BNZ   0C0A
0C04:  MOVLW  07
0C06:  SUBWF  00,W
0C08:  BZ    0C78
0C0A:  MOVF   03,W
0C0C:  BNZ   0C14
0C0E:  MOVLW  08
0C10:  SUBWF  00,W
0C12:  BZ    0CAE
0C14:  MOVF   03,W
0C16:  BNZ   0C1E
0C18:  MOVLW  09
0C1A:  SUBWF  00,W
0C1C:  BZ    0CE4
0C1E:  MOVF   03,W
0C20:  BNZ   0C2A
0C22:  MOVLW  0A
0C24:  SUBWF  00,W
0C26:  BTFSC  FD8.2
0C28:  BRA    0D42
0C2A:  MOVF   03,W
0C2C:  BNZ   0C36
0C2E:  MOVLW  0B
0C30:  SUBWF  00,W
0C32:  BTFSC  FD8.2
0C34:  BRA    0D78
0C36:  BRA    0DAC
....................             case 0: // All Red 
....................                 MakeAllRed(); 
0C38:  GOTO   0284
....................                 pattern_set = 1; 
0C3C:  BSF    xC0.0
....................                 continue_pattern_calling = 0; 
0C3E:  BCF    xC0.1
....................                 break; 
0C40:  BRA    0DAC
....................             case 1: //All Green 
....................                 MakeAllGreen(); 
0C42:  GOTO   02B6
....................                 pattern_set = 1; 
0C46:  BSF    xC0.0
....................                 continue_pattern_calling = 0; 
0C48:  BCF    xC0.1
....................                 break; 
0C4A:  BRA    0DAC
....................             case 2: //All Blue 
....................                 MakeAllBlue(); 
0C4C:  GOTO   02E8
....................                 pattern_set = 1; 
0C50:  BSF    xC0.0
....................                 continue_pattern_calling = 0; 
0C52:  BCF    xC0.1
....................                 break; 
0C54:  BRA    0DAC
....................             case 3: //Slow Rainbow Fade on all Leds 
....................                 continue_pattern_calling = 1; 
0C56:  BSF    xC0.1
....................                 All_Rainbow_Fade_200ms(); 
0C58:  GOTO   0416
....................                 pattern_set = 1; 
0C5C:  BSF    xC0.0
....................                 break; 
0C5E:  BRA    0DAC
....................             case 4: 
....................                 continue_pattern_calling = 1; 
0C60:  BSF    xC0.1
....................                 Dot_Rainbow_Fade(); 
0C62:  BRA    04FE
....................                 pattern_set = 1; 
0C64:  BSF    xC0.0
....................                 break; 
0C66:  BRA    0DAC
....................             case 5: 
....................                 continue_pattern_calling = 1; 
0C68:  BSF    xC0.1
....................                 All_Rainbow_Fade(); 
0C6A:  BRA    061E
....................                 pattern_set = 1; 
0C6C:  BSF    xC0.0
....................                 break; 
0C6E:  BRA    0DAC
....................             case 6: 
....................                 continue_pattern_calling = 1; 
0C70:  BSF    xC0.1
....................                 Random_Chain(); 
0C72:  BRA    0868
....................                 pattern_set = 1; 
0C74:  BSF    xC0.0
....................                 break; 
0C76:  BRA    0DAC
....................             case 7: 
....................                 continue_pattern_calling = 1; 
0C78:  BSF    xC0.1
....................                 ShiftThreeColorThreeBlank(Color(255,0,0)); 
0C7A:  MOVLB  1
0C7C:  SETF   x37
0C7E:  CLRF   x38
0C80:  CLRF   x39
0C82:  MOVLB  0
0C84:  CALL   00D8
0C88:  MOVFF  03,12A
0C8C:  MOVFF  02,129
0C90:  MOVFF  01,128
0C94:  MOVFF  00,127
0C98:  MOVFF  03,12E
0C9C:  MOVFF  02,12D
0CA0:  MOVFF  01,12C
0CA4:  MOVFF  00,12B
0CA8:  RCALL  0932
....................                 pattern_set = 1; 
0CAA:  BSF    xC0.0
....................                 break; 
0CAC:  BRA    0DAC
....................             case 8: 
....................                 continue_pattern_calling = 1; 
0CAE:  BSF    xC0.1
....................                 ShiftThreeColorThreeBlank(Color(0,255,255)); 
0CB0:  MOVLB  1
0CB2:  CLRF   x37
0CB4:  SETF   x38
0CB6:  SETF   x39
0CB8:  MOVLB  0
0CBA:  CALL   00D8
0CBE:  MOVFF  03,12A
0CC2:  MOVFF  02,129
0CC6:  MOVFF  01,128
0CCA:  MOVFF  00,127
0CCE:  MOVFF  03,12E
0CD2:  MOVFF  02,12D
0CD6:  MOVFF  01,12C
0CDA:  MOVFF  00,12B
0CDE:  RCALL  0932
....................                 pattern_set = 1; 
0CE0:  BSF    xC0.0
....................                 break; 
0CE2:  BRA    0DAC
....................             case 9: 
....................                 continue_pattern_calling = 1; 
0CE4:  BSF    xC0.1
....................                 ShiftThreeColorThreeBlank(Wheel(rand()%767)); 
0CE6:  RCALL  070C
0CE8:  MOVFF  02,128
0CEC:  MOVFF  01,127
0CF0:  MOVFF  02,131
0CF4:  MOVFF  01,130
0CF8:  MOVLW  02
0CFA:  MOVLB  1
0CFC:  MOVWF  x33
0CFE:  SETF   x32
0D00:  MOVLB  0
0D02:  CALL   04B8
0D06:  MOVFF  00,127
0D0A:  MOVFF  03,128
0D0E:  MOVFF  03,130
0D12:  MOVFF  00,12F
0D16:  MOVLB  0
0D18:  CALL   0352
0D1C:  MOVFF  03,12A
0D20:  MOVFF  02,129
0D24:  MOVFF  01,128
0D28:  MOVFF  00,127
0D2C:  MOVFF  03,12E
0D30:  MOVFF  02,12D
0D34:  MOVFF  01,12C
0D38:  MOVFF  00,12B
0D3C:  RCALL  0932
....................                 pattern_set = 1; 
0D3E:  BSF    xC0.0
....................                 break; 
0D40:  BRA    0DAC
....................             case 10: 
....................                 continue_pattern_calling = 1; 
0D42:  BSF    xC0.1
....................                 ShiftOneColorOneBlank(Color(0,0,255)); 
0D44:  MOVLB  1
0D46:  CLRF   x37
0D48:  CLRF   x38
0D4A:  SETF   x39
0D4C:  MOVLB  0
0D4E:  CALL   00D8
0D52:  MOVFF  03,12A
0D56:  MOVFF  02,129
0D5A:  MOVFF  01,128
0D5E:  MOVFF  00,127
0D62:  MOVFF  03,12E
0D66:  MOVFF  02,12D
0D6A:  MOVFF  01,12C
0D6E:  MOVFF  00,12B
0D72:  BRA    0A06
....................                 pattern_set = 1; 
0D74:  BSF    xC0.0
....................                 break; 
0D76:  BRA    0DAC
....................             case 11: 
....................                 continue_pattern_calling = 1; 
0D78:  BSF    xC0.1
....................                 ShiftOneColorTwoBlank(Color(0,0,255)); 
0D7A:  MOVLB  1
0D7C:  CLRF   x37
0D7E:  CLRF   x38
0D80:  SETF   x39
0D82:  MOVLB  0
0D84:  CALL   00D8
0D88:  MOVFF  03,12A
0D8C:  MOVFF  02,129
0D90:  MOVFF  01,128
0D94:  MOVFF  00,127
0D98:  MOVFF  03,12E
0D9C:  MOVFF  02,12D
0DA0:  MOVFF  01,12C
0DA4:  MOVFF  00,12B
0DA8:  BRA    0AC6
....................                 pattern_set = 1; 
0DAA:  BSF    xC0.0
....................                 break; 
....................  
....................         } 
....................     } 
0DAC:  MOVLW  9A
0DAE:  MOVWF  xD5
0DB0:  MOVLW  0B
0DB2:  MOVWF  xD6
0DB4:  GOTO   13DE
0DB8:  RETURN 0
.................... } 
....................  
.................... void Button_Checker() { 
....................     //check if any button is pressed 
....................     if (button_status == 0) { //no buttons have been pressed 
*
10E0:  MOVF   xC3,F
10E2:  BNZ   1122
....................  
....................         //Power Button 
....................         if (input(POWER_BUTTON_PIN) == 0) { //button is pressed 
10E4:  BSF    F92.0
10E6:  BTFSC  F80.0
10E8:  BRA    10EE
....................             bit_set(button_status, POWER_BUTTON_BIT); 
10EA:  BSF    xC3.0
....................             button_counter = 0; 
10EC:  CLRF   xC4
....................         } 
....................  
....................         //Up Button 
....................         if (input(UP_BUTTON_PIN) == 0) { //button is pressed 
10EE:  BSF    F92.1
10F0:  BTFSC  F80.1
10F2:  BRA    10F8
....................             bit_set(button_status, UP_BUTTON_BIT); 
10F4:  BSF    xC3.1
....................             button_counter = 0; 
10F6:  CLRF   xC4
....................         } 
....................  
....................         //Down Button 
....................         if (input(DOWN_BUTTON_PIN) == 0) { //button is pressed 
10F8:  BSF    F92.2
10FA:  BTFSC  F80.2
10FC:  BRA    1102
....................             bit_set(button_status, DOWN_BUTTON_BIT); 
10FE:  BSF    xC3.2
....................             button_counter = 0; 
1100:  CLRF   xC4
....................         } 
....................  
....................         //Left Button 
....................         if (input(LEFT_BUTTON_PIN) == 0) { //button is pressed 
1102:  BSF    F92.3
1104:  BTFSC  F80.3
1106:  BRA    110C
....................             bit_set(button_status, LEFT_BUTTON_BIT); 
1108:  BSF    xC3.3
....................             button_counter = 0; 
110A:  CLRF   xC4
....................         }       
....................          
....................         //Right Button 
....................         if (input(RIGHT_BUTTON_PIN) == 0) { //button is pressed 
110C:  BSF    F92.4
110E:  BTFSC  F80.4
1110:  BRA    1116
....................             bit_set(button_status, RIGHT_BUTTON_BIT); 
1112:  BSF    xC3.4
....................             button_counter = 0; 
1114:  CLRF   xC4
....................         } 
....................  
....................         //Center Button 
....................         if (input(CENTER_BUTTON_PIN) == 0) { //button is pressed 
1116:  BSF    F92.5
1118:  BTFSC  F80.5
111A:  BRA    1120
....................             bit_set(button_status, CENTER_BUTTON_BIT); 
111C:  BSF    xC3.5
....................             button_counter = 0; 
111E:  CLRF   xC4
....................         } 
....................  
....................  
....................  
....................     } else { //a button has been pressed, lets see if it's still pressed 
1120:  BRA    118E
....................  
....................         //Power Button 
....................         if (bit_test(button_status, POWER_BUTTON_BIT)) { 
1122:  BTFSS  xC3.0
1124:  BRA    1134
....................             if (input(POWER_BUTTON_PIN) == 0) { 
1126:  BSF    F92.0
1128:  BTFSC  F80.0
112A:  BRA    1130
....................                 button_counter++; 
112C:  INCF   xC4,F
....................             } else { 
112E:  BRA    1134
....................                 button_counter = 0; 
1130:  CLRF   xC4
....................                 bit_clear(button_status, POWER_BUTTON_BIT); 
1132:  BCF    xC3.0
....................             } 
....................         } 
....................  
....................         //Up Button 
....................         if (bit_test(button_status, UP_BUTTON_BIT)) { 
1134:  BTFSS  xC3.1
1136:  BRA    1146
....................             if (input(UP_BUTTON_PIN) == 0) { 
1138:  BSF    F92.1
113A:  BTFSC  F80.1
113C:  BRA    1142
....................                 button_counter++; 
113E:  INCF   xC4,F
....................             } else { 
1140:  BRA    1146
....................                 button_counter = 0; 
1142:  CLRF   xC4
....................                 bit_clear(button_status, UP_BUTTON_BIT); 
1144:  BCF    xC3.1
....................             } 
....................         } 
....................  
....................         //Down Button 
....................         if (bit_test(button_status, DOWN_BUTTON_BIT)) { 
1146:  BTFSS  xC3.2
1148:  BRA    1158
....................             if (input(DOWN_BUTTON_PIN) == 0) { 
114A:  BSF    F92.2
114C:  BTFSC  F80.2
114E:  BRA    1154
....................                 button_counter++; 
1150:  INCF   xC4,F
....................             } else { 
1152:  BRA    1158
....................                 button_counter = 0; 
1154:  CLRF   xC4
....................                 bit_clear(button_status, DOWN_BUTTON_BIT); 
1156:  BCF    xC3.2
....................             } 
....................         } 
....................  
....................         //Left Button 
....................         if (bit_test(button_status, LEFT_BUTTON_BIT)) { 
1158:  BTFSS  xC3.3
115A:  BRA    116A
....................             if (input(LEFT_BUTTON_PIN) == 0) { 
115C:  BSF    F92.3
115E:  BTFSC  F80.3
1160:  BRA    1166
....................                 button_counter++; 
1162:  INCF   xC4,F
....................             } else { 
1164:  BRA    116A
....................                 button_counter = 0; 
1166:  CLRF   xC4
....................                 bit_clear(button_status, LEFT_BUTTON_BIT); 
1168:  BCF    xC3.3
....................             } 
....................         } 
....................  
....................         //Right Button 
....................         if (bit_test(button_status, RIGHT_BUTTON_BIT)) { 
116A:  BTFSS  xC3.4
116C:  BRA    117C
....................             if (input(RIGHT_BUTTON_PIN) == 0) { 
116E:  BSF    F92.4
1170:  BTFSC  F80.4
1172:  BRA    1178
....................                 button_counter++; 
1174:  INCF   xC4,F
....................             } else { 
1176:  BRA    117C
....................                 button_counter = 0; 
1178:  CLRF   xC4
....................                 bit_clear(button_status, RIGHT_BUTTON_BIT); 
117A:  BCF    xC3.4
....................             } 
....................         } 
....................  
....................         //Center Button 
....................         if (bit_test(button_status, CENTER_BUTTON_BIT)) { 
117C:  BTFSS  xC3.5
117E:  BRA    118E
....................             if (input(CENTER_BUTTON_PIN) == 0) { 
1180:  BSF    F92.5
1182:  BTFSC  F80.5
1184:  BRA    118A
....................                 button_counter++; 
1186:  INCF   xC4,F
....................             } else { 
1188:  BRA    118E
....................                 button_counter = 0; 
118A:  CLRF   xC4
....................                 bit_clear(button_status, CENTER_BUTTON_BIT); 
118C:  BCF    xC3.5
....................             } 
....................         } 
....................  
....................     } 
....................  
....................     if (button_counter > 5) { 
118E:  MOVF   xC4,W
1190:  SUBLW  05
1192:  BC    120C
....................  
....................         //Power Button 
....................         if (bit_test(button_status, POWER_BUTTON_BIT)) { 
1194:  BTFSS  xC3.0
1196:  BRA    11A8
....................             while (input(POWER_BUTTON_PIN) == 0) { //wait untill the button is released 
1198:  BSF    F92.0
119A:  BTFSC  F80.0
119C:  BRA    11A2
....................                 rtos_disable(Button_Checker); 
119E:  BSF    xD7.7
11A0:  BRA    1198
....................             } 
....................             rtos_enable(Button_Checker); 
11A2:  BCF    xD7.7
....................             Power_Button_Function(); 
11A4:  BRA    0DBA
....................             button_status = 0; 
11A6:  CLRF   xC3
....................         } 
....................  
....................         //Up Button 
....................         if (bit_test(button_status, UP_BUTTON_BIT)) { 
11A8:  BTFSS  xC3.1
11AA:  BRA    11BC
....................             while (input(UP_BUTTON_PIN) == 0) { //wait untill the button is released 
11AC:  BSF    F92.1
11AE:  BTFSC  F80.1
11B0:  BRA    11B6
....................                 rtos_disable(Button_Checker); 
11B2:  BSF    xD7.7
11B4:  BRA    11AC
....................             } 
....................             rtos_enable(Button_Checker); 
11B6:  BCF    xD7.7
....................             Up_Button_Function(); 
11B8:  BRA    0DFA
....................             button_status = 0; 
11BA:  CLRF   xC3
....................         } 
....................  
....................         //Down Button 
....................         if (bit_test(button_status, DOWN_BUTTON_BIT)) { 
11BC:  BTFSS  xC3.2
11BE:  BRA    11D0
....................             while (input(DOWN_BUTTON_PIN) == 0) { //wait untill the button is released 
11C0:  BSF    F92.2
11C2:  BTFSC  F80.2
11C4:  BRA    11CA
....................                 rtos_disable(Button_Checker); 
11C6:  BSF    xD7.7
11C8:  BRA    11C0
....................             } 
....................             rtos_enable(Button_Checker); 
11CA:  BCF    xD7.7
....................             Down_Button_Function(); 
11CC:  BRA    0E26
....................             button_status = 0; 
11CE:  CLRF   xC3
....................         } 
....................  
....................         //Left Button 
....................         if (bit_test(button_status, LEFT_BUTTON_BIT)) { 
11D0:  BTFSS  xC3.3
11D2:  BRA    11E4
....................             while (input(LEFT_BUTTON_PIN) == 0) { //wait untill the button is released 
11D4:  BSF    F92.3
11D6:  BTFSC  F80.3
11D8:  BRA    11DE
....................                 rtos_disable(Button_Checker); 
11DA:  BSF    xD7.7
11DC:  BRA    11D4
....................             } 
....................             rtos_enable(Button_Checker); 
11DE:  BCF    xD7.7
....................             Left_Button_Function(); 
11E0:  BRA    0E46
....................             button_status = 0; 
11E2:  CLRF   xC3
....................         } 
....................  
....................         //Right Button 
....................         if (bit_test(button_status, RIGHT_BUTTON_BIT)) { 
11E4:  BTFSS  xC3.4
11E6:  BRA    11F8
....................             while (input(RIGHT_BUTTON_PIN) == 0) { //wait untill the button is released 
11E8:  BSF    F92.4
11EA:  BTFSC  F80.4
11EC:  BRA    11F2
....................                 rtos_disable(Button_Checker); 
11EE:  BSF    xD7.7
11F0:  BRA    11E8
....................             } 
....................             rtos_enable(Button_Checker); 
11F2:  BCF    xD7.7
....................             Right_Button_Function(); 
11F4:  BRA    0E62
....................             button_status = 0; 
11F6:  CLRF   xC3
....................         } 
....................  
....................         //Center Button 
....................         if (bit_test(button_status, CENTER_BUTTON_BIT)) { 
11F8:  BTFSS  xC3.5
11FA:  BRA    120C
....................             while (input(CENTER_BUTTON_PIN) == 0) { //wait untill the button is released 
11FC:  BSF    F92.5
11FE:  BTFSC  F80.5
1200:  BRA    1206
....................                 rtos_disable(Button_Checker); 
1202:  BSF    xD7.7
1204:  BRA    11FC
....................             } 
....................             rtos_enable(Button_Checker); 
1206:  BCF    xD7.7
....................             Center_Button_Function(); 
1208:  BRA    10DA
....................             button_status = 0; 
120A:  CLRF   xC3
....................         } 
....................  
....................     } 
120C:  MOVLW  E0
120E:  MOVWF  xDC
1210:  MOVLW  10
1212:  MOVWF  xDD
1214:  GOTO   13DE
1218:  RETURN 0
.................... } 
....................  
....................  
.................... /*MAIN FUNCTION*/ 
.................... void main(int argc, char** argv) { 
*
1288:  CLRF   FF8
128A:  BCF    FD0.7
128C:  MOVLW  60
128E:  MOVWF  FD3
1290:  BSF    F9B.6
1292:  BCF    F9B.7
1294:  BSF    FB8.3
1296:  BSF    FB8.4
1298:  MOVLW  8A
129A:  MOVWF  FAF
129C:  MOVLW  00
129E:  MOVWF  FB0
12A0:  MOVLW  A6
12A2:  MOVWF  FAC
12A4:  MOVLW  90
12A6:  MOVWF  FAB
12A8:  MOVF   FC1,W
12AA:  ANDLW  F0
12AC:  MOVWF  FC1
12AE:  MOVLW  00
12B0:  MOVLB  F
12B2:  MOVWF  x38
12B4:  MOVWF  x39
12B6:  MOVWF  x3A
12B8:  CLRF   F77
12BA:  CLRF   F78
12BC:  CLRF   F79
12BE:  CLRF   04
12C0:  CLRF   05
....................     //setup the IC 
....................     setup_oscillator(OSC_8MHZ | OSC_PLL_ON); //32MHZ 
12C2:  MOVLW  60
12C4:  MOVWF  FD3
12C6:  BSF    F9B.6
12C8:  BCF    F9B.7
....................     set_tris_a(0b01111111); 
12CA:  MOVLW  7F
12CC:  MOVWF  F92
....................     set_tris_b(0b00000000); 
12CE:  MOVLW  00
12D0:  MOVWF  F93
....................     set_tris_c(0b00000000); 
12D2:  MOVWF  F94
.................... //   PORT_A_PULLUPS(0b01111111); 
.................... //   PORT_A_PULLUPS(TRUE); 
.................... //    PORT_B_PULLUPS(0b00000000); 
....................  
.................... #ifdef BOARD_V1_1 
....................     #ifdef WS2801 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_DO_B5 | SPI_SCK_B7 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
....................     #endif 
....................     #ifdef WS2811 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_16 | SPI_DO_B5 | SPI_SCK_B7 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
....................     #endif 
.................... #endif 
....................  
.................... #ifdef BOARD_V1_2 
....................     #ifdef WS2801 
....................         //setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_DO_C5 | SPI_SCK_C3 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
12D4:  BCF    FC6.5
12D6:  BCF    F94.5
12D8:  BSF    F94.4
12DA:  BCF    F94.3
12DC:  MOVLW  20
12DE:  MOVWF  FC6
12E0:  MOVLW  40
12E2:  MOVWF  FC7
....................     #endif 
....................     #ifdef WS2811 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_16 | SPI_DO_C5 | SPI_SCK_C3 | SPI_L_TO_H); 
....................     #endif 
.................... #endif 
....................  
....................     //turn on the leds 
....................     OUTPUT_LOW(LED_ON_PIN); 
12E4:  BCF    F92.7
12E6:  BCF    F89.7
....................     led_power_status = 1; //LED IS ON 
12E8:  MOVLB  0
12EA:  BSF    xC0.2
....................      
....................     //clear the led_strup_colors variable 
....................     setup(); 
12EC:  BRA    121A
....................     send_frame(); 
12EE:  CALL   015E
....................     delay_ms(100); 
12F2:  MOVLW  64
12F4:  MOVLB  1
12F6:  MOVWF  x28
12F8:  MOVLB  0
12FA:  RCALL  0E68
....................  
....................     //setup global variables 
....................     autochange_pattern = 0; 
12FC:  CLRF   xC5
....................     current_pattern = 4; 
12FE:  CLRF   xBF
1300:  MOVLW  04
1302:  MOVWF  xBE
....................     button_status = 0; 
1304:  CLRF   xC3
....................     timer_flags_counter = 0; 
1306:  CLRF   xC2
1308:  CLRF   xC1
....................     pattern_set = 0; 
130A:  BCF    xC0.0
....................     continue_pattern_calling = 0; 
130C:  BCF    xC0.1
....................     delay_time_ms = 50; 
130E:  CLRF   xC7
1310:  MOVLW  32
1312:  MOVWF  xC6
....................     Clear_Pattern_Positions(); 
1314:  CALL   0056
....................              
....................  
.................... #ifdef DEBUG_SERIAL 
....................     printf("System Started\n\r"); 
.................... #endif 
....................  
.................... /* 
.................... //Test code when checking LED programs 
....................     while (1) { 
....................         //startup test of all colors 
....................         //make all red 
....................         MakeAllColor(Color(255, 0, 0)); 
....................         delay_ms(1000); 
....................         //make all green 
....................         MakeAllColor(Color(0, 255, 0)); 
....................         delay_ms(1000); 
....................         //make all blue 
....................         MakeAllColor(Color(0, 0, 255)); 
....................         delay_ms(1000); 
....................     } 
.................... */ 
....................      
....................     Timer_Clear_All_Timer(); 
1318:  BRA    1252
....................              
.................... #ifdef DEBUG_SERIAL 
....................     printf("Starting RTOS\n\r"); 
.................... #endif 
....................      
....................     rtos_run(); 
131A:  CLRF   xC9
131C:  MOVLW  75
131E:  MOVWF  xCB
1320:  MOVLW  30
1322:  MOVWF  xCA
1324:  CLRF   xCD
1326:  MOVLW  02
1328:  MOVWF  xCC
132A:  MOVLW  7E
132C:  MOVWF  xCE
132E:  MOVLW  00
1330:  MOVWF  xCF
1332:  CLRF   xD0
1334:  CLRF   xD2
1336:  MOVLW  0A
1338:  MOVWF  xD1
133A:  CLRF   xD4
133C:  CLRF   xD3
133E:  MOVLW  9A
1340:  MOVWF  xD5
1342:  MOVLW  0B
1344:  MOVWF  xD6
1346:  CLRF   xD7
1348:  CLRF   xD9
134A:  MOVLW  0A
134C:  MOVWF  xD8
134E:  CLRF   xDB
1350:  MOVLW  01
1352:  MOVWF  xDA
1354:  MOVLW  E0
1356:  MOVWF  xDC
1358:  MOVLW  10
135A:  MOVWF  xDD
135C:  CLRF   xDE
135E:  CLRF   xE0
1360:  MOVLW  01
1362:  MOVWF  xDF
1364:  CLRF   xE2
1366:  CLRF   xE1
1368:  MOVLW  1C
136A:  MOVWF  xE3
136C:  MOVLW  00
136E:  MOVWF  xE4
1370:  CLRF   xC8
1372:  MOVLW  05
1374:  MOVWF  FCD
1376:  CLRF   FCC
1378:  MOVLW  E0
137A:  MOVWF  FCF
137C:  MOVLW  C0
137E:  MOVWF  FCE
1380:  BCF    F9E.0
1382:  BCF    FD8.0
1384:  RLCF   xC8,W
1386:  MOVWF  00
1388:  CALL   0004
138C:  MOVWF  02
138E:  MOVLW  01
1390:  ADDWF  00,W
1392:  CALL   0004
1396:  MOVWF  03
1398:  MOVFF  03,FEA
139C:  MOVFF  02,FE9
13A0:  MOVFF  FEF,02
13A4:  INCF   FE9,F
13A6:  MOVFF  FEF,00
13AA:  MOVFF  FEC,01
13AE:  INCF   FEC,F
13B0:  MOVFF  FEF,03
13B4:  BNZ   13BA
13B6:  INCF   FEC,F
13B8:  MOVF   FED,F
13BA:  MOVF   FEC,W
13BC:  SUBWF  01,W
13BE:  BNZ   13E0
13C0:  MOVF   00,W
13C2:  SUBWF  03,W
13C4:  BNZ   13E0
13C6:  MOVF   FED,F
13C8:  CLRF   FEE
13CA:  CLRF   FEF
13CC:  BTFSC  02.7
13CE:  BRA    13E0
13D0:  MOVF   FEC,F
13D2:  MOVFF  FEC,FFA
13D6:  MOVF   FED,F
13D8:  MOVFF  FEF,FE8
13DC:  MOVWF  FF9
13DE:  MOVLB  0
13E0:  INCF   xC8,F
13E2:  MOVLW  04
13E4:  SUBWF  xC8,W
13E6:  BNZ   1382
13E8:  CLRF   xC8
13EA:  BTFSC  F9E.0
13EC:  BRA    1378
13EE:  BRA    13EA
13F0:  SETF   xC8
.................... } 
13F2:  SLEEP 

Configuration Fuses:
   Word  1: F800   INTRC_IO PLLEN PRIMARY FCMEN IESO
   Word  2: 3C18   PUT NOBROWNOUT BORV19 NOWDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

CCS PCM C Compiler, Version 5.008, 5967               07-Nov-14 19:10

               Filename:   C:\Users\Matt\Documents\Projects\Wedding\LED Centerpiece\Code\Centerpiece_16F1788.X\build\default\production\main.lst

               ROM used:   2947 words (18%)
                           Largest free fragment is 2048
               RAM used:   233 (11%) at main() level
                           327 (16%) worst case
               Stack used: 7 locations (3 in main + 4 for interrupts)
               Stack size: 16

*
0000:  MOVLP  08
0001:  GOTO   2C6
0002:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: Matt Wasserman 
....................  * Control Wedding LED Centerpieces 
....................  * 
....................  * Created on September 1, 2014, 5:54 PM 
....................  */ 
....................  
.................... #include <16F1788.h> 
.................... //////// Standard Header file for the PIC16F1788 device //////////////// 
.................... #device PIC16F1788 
0003:  BRW
0004:  RETLW  BC
0005:  RETLW  20
0006:  RETLW  C3
0007:  RETLW  20
0008:  RETLW  CA
0009:  RETLW  20
000A:  RETLW  D1
000B:  RETLW  20
*
01FB:  MOVLW  10
01FC:  MOVLB  03
01FD:  MOVWF  56
01FE:  CLRF   77
01FF:  CLRF   7A
0200:  RRF    53,F
0201:  RRF    52,F
0202:  BTFSS  03.0
0203:  GOTO   20A
0204:  MOVF   54,W
0205:  ADDWF  77,F
0206:  BTFSC  03.0
0207:  INCF   7A,F
0208:  MOVF   55,W
0209:  ADDWF  7A,F
020A:  RRF    7A,F
020B:  RRF    77,F
020C:  RRF    79,F
020D:  RRF    78,F
020E:  DECFSZ 56,F
020F:  GOTO   200
0210:  MOVLB  00
0211:  RETURN
0212:  CLRF   78
0213:  CLRF   79
0214:  CLRF   77
0215:  CLRF   7A
0216:  MOVLB  03
0217:  MOVF   56,W
0218:  BTFSS  03.2
0219:  GOTO   21D
021A:  MOVF   55,W
021B:  BTFSC  03.2
021C:  GOTO   237
021D:  MOVLW  10
021E:  MOVWF  57
021F:  BCF    03.0
0220:  RLF    53,F
0221:  RLF    54,F
0222:  RLF    77,F
0223:  RLF    7A,F
0224:  MOVF   56,W
0225:  SUBWF  7A,W
0226:  BTFSS  03.2
0227:  GOTO   22A
0228:  MOVF   55,W
0229:  SUBWF  77,W
022A:  BTFSS  03.0
022B:  GOTO   233
022C:  MOVF   55,W
022D:  SUBWF  77,F
022E:  BTFSS  03.0
022F:  DECF   7A,F
0230:  MOVF   56,W
0231:  SUBWF  7A,F
0232:  BSF    03.0
0233:  RLF    78,F
0234:  RLF    79,F
0235:  DECFSZ 57,F
0236:  GOTO   21F
0237:  MOVLB  00
0238:  RETURN
*
0250:  MOVLW  20
0251:  MOVWF  5C
0252:  CLRF   58
0253:  CLRF   59
0254:  CLRF   5A
0255:  CLRF   5B
0256:  MOVF   53,W
0257:  MOVWF  7A
0258:  MOVF   52,W
0259:  MOVWF  79
025A:  MOVF   51,W
025B:  MOVWF  78
025C:  MOVF   50,W
025D:  MOVWF  77
025E:  BCF    03.0
025F:  BTFSS  77.0
0260:  GOTO   26F
0261:  MOVF   54,W
0262:  ADDWF  58,F
0263:  MOVF   55,W
0264:  BTFSC  03.0
0265:  INCFSZ 55,W
0266:  ADDWF  59,F
0267:  MOVF   56,W
0268:  BTFSC  03.0
0269:  INCFSZ 56,W
026A:  ADDWF  5A,F
026B:  MOVF   57,W
026C:  BTFSC  03.0
026D:  INCFSZ 57,W
026E:  ADDWF  5B,F
026F:  RRF    5B,F
0270:  RRF    5A,F
0271:  RRF    59,F
0272:  RRF    58,F
0273:  RRF    7A,F
0274:  RRF    79,F
0275:  RRF    78,F
0276:  RRF    77,F
0277:  DECFSZ 5C,F
0278:  GOTO   25E
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOMCLR, NOBROWNOUT, NOWDT, PUT 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0239:  MOVF   25,W
023A:  MOVLB  03
023B:  MOVWF  53
023C:  MOVLB  00
023D:  MOVF   24,W
023E:  MOVLB  03
023F:  MOVWF  52
0240:  MOVLB  00
0241:  MOVF   23,W
0242:  MOVLB  03
0243:  MOVWF  51
0244:  MOVLB  00
0245:  MOVF   22,W
0246:  MOVLB  03
0247:  MOVWF  50
0248:  MOVLW  41
0249:  MOVWF  57
024A:  MOVLW  C6
024B:  MOVWF  56
024C:  MOVLW  4E
024D:  MOVWF  55
024E:  MOVLW  6D
024F:  MOVWF  54
*
0279:  MOVF   7A,W
027A:  MOVWF  53
027B:  MOVF   79,W
027C:  MOVWF  52
027D:  MOVF   78,W
027E:  MOVWF  51
027F:  MOVF   77,W
0280:  MOVWF  50
0281:  MOVLW  39
0282:  ADDWF  50,W
0283:  MOVLB  00
0284:  MOVWF  22
0285:  MOVLW  30
0286:  MOVLB  03
0287:  ADDWFC 51,W
0288:  MOVLB  00
0289:  MOVWF  23
028A:  MOVLW  00
028B:  MOVLB  03
028C:  ADDWFC 52,W
028D:  MOVLB  00
028E:  MOVWF  24
028F:  MOVLW  00
0290:  MOVLB  03
0291:  ADDWFC 53,W
0292:  MOVLB  00
0293:  MOVWF  25
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0294:  MOVF   24,W
0295:  MOVWF  77
0296:  MOVF   25,W
0297:  MOVWF  78
0298:  CLRF   79
0299:  CLRF   7A
029A:  MOVF   25,W
029B:  MOVLB  03
029C:  MOVWF  52
029D:  MOVF   77,W
029E:  MOVWF  51
029F:  MOVF   52,W
02A0:  MOVWF  54
02A1:  MOVF   51,W
02A2:  MOVWF  53
02A3:  MOVLW  7F
02A4:  MOVWF  56
02A5:  MOVLW  FF
02A6:  MOVWF  55
02A7:  MOVLB  00
02A8:  CALL   212
02A9:  MOVF   77,W
02AA:  MOVWF  78
02AB:  MOVF   7A,W
02AC:  MOVWF  79
02AD:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "Globals.h" 
.................... /* 
....................  * File:   Globals.h 
....................  * Author: Matt Wasserman 
....................  * Header file with all global vars and defines 
....................  */ 
....................  
.................... /* DEFINES FOR VERSION*/ 
.................... #define BOARD_V1_1 
.................... //#define BOARD_V1_2 
....................  
.................... #define WS2801 
.................... //#define WS2811 
....................  
.................... /* DEFINES */ 
.................... #define TDOTS 43 // number of LEDs on the strip 
.................... #define NUM_INTERNAL_TIMER 1 
.................... #define NUM_PATTERN_POSITION 2 
.................... #define NUM_PATTERNS 12 
.................... #define DELAY_TIME_MS_JUMP 50 
.................... #define LED_ON_PIN PIN_A7 
....................  
.................... //defines for buttons 
.................... #define POWER_BUTTON_PIN PIN_A0 
.................... #define UP_BUTTON_PIN PIN_A1 
.................... #define DOWN_BUTTON_PIN PIN_A2 
.................... #define LEFT_BUTTON_PIN PIN_A3 
.................... #define RIGHT_BUTTON_PIN PIN_A4 
.................... #define CENTER_BUTTON_PIN PIN_A5 
.................... #define POWER_BUTTON_BIT 0 
.................... #define UP_BUTTON_BIT 1 
.................... #define DOWN_BUTTON_BIT 2 
.................... #define LEFT_BUTTON_BIT 3 
.................... #define RIGHT_BUTTON_BIT 4 
.................... #define CENTER_BUTTON_BIT 5 
....................  
.................... //Debug functions 
.................... //#define DEBUG_SERIAL 1 
....................  
.................... struct rtos_stats { 
....................    int32 task_total_ticks;       // number of ticks the task has used 
....................    int16 task_min_ticks;         // the minimum number of ticks used 
....................    int16 task_max_ticks;         // the maximum number of ticks ueed 
....................    int16 hns_per_tick;           // us = (ticks*hns_per_tic)/10 
.................... }; 
....................  
....................  
.................... /* GLOBAL VARIABLES*/ 
.................... unsigned int32 node_list[TDOTS]; 
.................... unsigned int32 internal_timer[NUM_INTERNAL_TIMER]; 
.................... unsigned int16 pattern_position[NUM_PATTERN_POSITION]; //used to track current position within a patten 
.................... unsigned int16 current_pattern; 
.................... int1 pattern_set; 
.................... int1 continue_pattern_calling; 
.................... int1 led_power_status; 
.................... int16 timer_flags_counter; 
.................... unsigned int8 button_status; 
.................... unsigned int8 button_counter; 
.................... int autochange_pattern; 
.................... int16 delay_time_ms; 
....................  
....................  
....................  
.................... #USE DELAY(clock=32MHZ) 
*
00AF:  MOVLW  02
00B0:  MOVLB  03
00B1:  SUBWF  59,F
00B2:  BTFSS  03.0
00B3:  GOTO   0C1
00B4:  MOVLW  21
00B5:  MOVWF  05
00B6:  MOVLW  29
00B7:  MOVWF  04
00B8:  MOVF   00,W
00B9:  BTFSC  03.2
00BA:  GOTO   0C1
00BB:  GOTO   0BF
00BC:  GOTO   0BD
00BD:  GOTO   0BE
00BE:  NOP
00BF:  DECFSZ 00,F
00C0:  GOTO   0BC
00C1:  MOVLB  00
00C2:  RETURN
*
0795:  MOVLW  21
0796:  MOVWF  05
0797:  MOVLW  1B
0798:  MOVWF  04
0799:  MOVF   00,W
079A:  BTFSC  03.2
079B:  GOTO   7A9
079C:  MOVLW  0A
079D:  MOVWF  78
079E:  CLRF   77
079F:  DECFSZ 77,F
07A0:  GOTO   79F
07A1:  DECFSZ 78,F
07A2:  GOTO   79E
07A3:  MOVLW  5F
07A4:  MOVWF  77
07A5:  DECFSZ 77,F
07A6:  GOTO   7A5
07A7:  DECFSZ 00,F
07A8:  GOTO   79C
07A9:  RETURN
....................  
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BITS=8, STOP=1, PARITY=N, INVERT) 
.................... #use rtos(timer=1) 
....................  
....................  
.................... /* TASK FUNCTIONS */ 
.................... #task(rate=30s,max=5ms) 
.................... void Pattern_Selector(); 
....................  
.................... #task(rate=10ms,max=5ms) 
.................... void Update_Pattern(); 
....................  
.................... #task(rate=10ms,max=5ms) 
.................... void Button_Checker(); 
....................  
.................... #task(rate=1ms,max=1ms) 
.................... void Timer_Tic(); 
....................  
.................... /* 
.................... #task(rate=100ms,max=1ms) 
.................... void Timer_Check(); 
.................... */ 
....................  
.................... /*Additonal Includes*/ 
....................  
.................... #include "Timer_Flags.c" 
.................... //FILE NAME = Timer_Flags.c 
.................... // functions to avoid using delay calls 
....................  
.................... void Timer_Clear_Timer(int timer){ 
....................     if(timer < NUM_INTERNAL_TIMER){ 
*
01E2:  MOVLB  03
01E3:  MOVF   52,F
01E4:  BTFSS  03.2
01E5:  GOTO   1F9
....................         internal_timer[timer] = 0; 
01E6:  RLF    52,W
01E7:  MOVWF  77
01E8:  RLF    77,F
01E9:  MOVLW  FC
01EA:  ANDWF  77,F
01EB:  MOVF   77,W
01EC:  ADDLW  B4
01ED:  MOVWF  04
01EE:  MOVLW  20
01EF:  MOVWF  05
01F0:  BTFSC  03.0
01F1:  INCF   05,F
01F2:  CLRF   00
01F3:  ADDFSR 01,FSR0
01F4:  CLRF   00
01F5:  ADDFSR 01,FSR0
01F6:  CLRF   00
01F7:  ADDFSR 01,FSR0
01F8:  CLRF   00
....................     } 
01F9:  MOVLB  00
01FA:  RETURN
.................... } 
....................  
.................... void Timer_Clear_All_Timer(){ 
....................     int i; 
....................     rtos_disable(Timer_Tic); 
*
07C9:  MOVLB  02
07CA:  BSF    51.7
....................     for (i=0;i<NUM_INTERNAL_TIMER;i++){ 
07CB:  CLRF   5B
07CC:  MOVF   5B,F
07CD:  BTFSS  03.2
07CE:  GOTO   7E4
....................         internal_timer[i] = 0; 
07CF:  RLF    5B,W
07D0:  MOVWF  77
07D1:  RLF    77,F
07D2:  MOVLW  FC
07D3:  ANDWF  77,F
07D4:  MOVF   77,W
07D5:  ADDLW  B4
07D6:  MOVWF  04
07D7:  MOVLW  20
07D8:  MOVWF  05
07D9:  BTFSC  03.0
07DA:  INCF   05,F
07DB:  CLRF   00
07DC:  ADDFSR 01,FSR0
07DD:  CLRF   00
07DE:  ADDFSR 01,FSR0
07DF:  CLRF   00
07E0:  ADDFSR 01,FSR0
07E1:  CLRF   00
07E2:  INCF   5B,F
07E3:  GOTO   7CC
....................     } 
....................     rtos_enable(Timer_Tic); 
07E4:  BCF    51.7
07E5:  MOVLP  08
07E6:  MOVLB  00
07E7:  GOTO   31E (RETURN)
.................... } 
....................  
.................... int32 Timer_Get_Timer(int timer){ 
....................     if(timer < NUM_INTERNAL_TIMER){ 
*
016A:  MOVLB  03
016B:  MOVF   52,F
016C:  BTFSS  03.2
016D:  GOTO   188
....................         return internal_timer[timer]; 
016E:  RLF    52,W
016F:  MOVWF  77
0170:  RLF    77,F
0171:  MOVLW  FC
0172:  ANDWF  77,F
0173:  MOVF   77,W
0174:  ADDLW  B4
0175:  MOVWF  04
0176:  MOVLW  20
0177:  MOVWF  05
0178:  BTFSC  03.0
0179:  INCF   05,F
017A:  MOVF   00,W
017B:  MOVWF  77
017C:  ADDFSR 01,FSR0
017D:  MOVF   00,W
017E:  MOVWF  78
017F:  ADDFSR 01,FSR0
0180:  MOVF   00,W
0181:  MOVWF  79
0182:  ADDFSR 01,FSR0
0183:  MOVF   00,W
0184:  MOVWF  7A
0185:  ADDFSR 3D,FSR0
0186:  GOTO   18C
....................     }else{ 
0187:  GOTO   18C
....................         return 0; 
0188:  CLRF   77
0189:  CLRF   78
018A:  CLRF   79
018B:  CLRF   7A
....................     } 
018C:  MOVLB  00
018D:  RETURN
.................... } 
....................  
.................... void Timer_Tic(){ 
....................     //OUTPUT_HIGH(PIN_C4); 
....................     int i; 
....................     for (i=0;i<NUM_INTERNAL_TIMER;i++){ 
*
000C:  MOVLB  03
000D:  CLRF   4A
000E:  MOVF   4A,F
000F:  BTFSS  03.2
0010:  GOTO   028
....................         internal_timer[i]++; 
0011:  RLF    4A,W
0012:  MOVWF  77
0013:  RLF    77,F
0014:  MOVLW  FC
0015:  ANDWF  77,F
0016:  MOVF   77,W
0017:  ADDLW  B4
0018:  MOVWF  04
0019:  MOVLW  20
001A:  MOVWF  05
001B:  BTFSC  03.0
001C:  INCF   05,F
001D:  MOVLW  01
001E:  ADDWF  00,F
001F:  ADDFSR 01,FSR0
0020:  MOVLW  00
0021:  ADDWFC 00,F
0022:  ADDFSR 01,FSR0
0023:  ADDWFC 00,F
0024:  ADDFSR 01,FSR0
0025:  ADDWFC 00,F
0026:  INCF   4A,F
0027:  GOTO   00E
....................     } 
0028:  MOVLW  0C
0029:  MOVLB  02
002A:  MOVWF  56
002B:  MOVLW  00
002C:  MOVWF  57
002D:  MOVLP  08
002E:  MOVLB  00
002F:  GOTO   38E
0030:  RETURN
....................     //OUTPUT_LOW(PIN_C4); 
.................... } 
....................  
.................... void Timer_Check() { 
....................     int i; 
....................     for (i = 0; i < NUM_INTERNAL_TIMER; i++) { 
.................... #ifdef DEBUG_SERIAL 
....................         printf("Timer %i = %Lu\n\r",i,internal_timer[i]); 
.................... #endif 
....................     } 
....................  
.................... } 
....................  
.................... #ifdef WS2801 
....................     #include "WS2801_SPI.c" 
.................... //FILE NAME = WS2801_SPI.c 
.................... //File to output controls to a WS2801 led strip using PIC SPI commands 
....................  
.................... //needed Constant 
.................... //nDots - number of nodes in the chain 
....................  
.................... //needed Globel Vars 
.................... //node_list - 32bit array where all node colors are stored 
....................  
.................... //*****************Function List*****************// 
.................... //void send_frame(void) 
.................... 	//Update the chain of WS2801 Nodes 
.................... //******************Functions*******************// 
....................  
.................... //use SPI to sent out all frames 
.................... void send_frame(void) {   // NOTE this strip takes data in BLUE, GREEN, RED order 
....................   unsigned int16 i; 
....................   unsigned int8 red,green,blue; 
....................  
....................   for(i=0;i<TDOTS;i++) { 
*
00C3:  MOVLB  03
00C4:  CLRF   54
00C5:  CLRF   53
00C6:  MOVF   54,F
00C7:  BTFSS  03.2
00C8:  GOTO   140
00C9:  MOVF   53,W
00CA:  SUBLW  2A
00CB:  BTFSS  03.0
00CC:  GOTO   140
....................     red = node_list[i] & 0xFF; 
00CD:  RLF    53,W
00CE:  MOVWF  79
00CF:  RLF    54,W
00D0:  MOVWF  7A
00D1:  RLF    79,F
00D2:  RLF    7A,F
00D3:  MOVLW  FC
00D4:  ANDWF  79,F
00D5:  MOVF   79,W
00D6:  ADDLW  08
00D7:  MOVWF  04
00D8:  MOVLW  20
00D9:  ADDWFC 7A,W
00DA:  MOVWF  05
00DB:  MOVF   00,W
00DC:  MOVWF  58
00DD:  MOVIW  [FSR0+01],W
00DE:  MOVWF  59
00DF:  MOVIW  [FSR0+02],W
00E0:  MOVWF  5A
00E1:  MOVIW  [FSR0+03],W
00E2:  MOVWF  5B
00E3:  MOVF   58,W
00E4:  MOVWF  55
....................     green = (node_list[i] >> 8) & 0xFF; 
00E5:  RLF    53,W
00E6:  MOVWF  79
00E7:  RLF    54,W
00E8:  MOVWF  7A
00E9:  RLF    79,F
00EA:  RLF    7A,F
00EB:  MOVLW  FC
00EC:  ANDWF  79,F
00ED:  MOVF   79,W
00EE:  ADDLW  08
00EF:  MOVWF  04
00F0:  MOVLW  20
00F1:  ADDWFC 7A,W
00F2:  MOVWF  05
00F3:  MOVF   00,W
00F4:  MOVWF  58
00F5:  MOVIW  [FSR0+01],W
00F6:  MOVWF  59
00F7:  MOVIW  [FSR0+02],W
00F8:  MOVWF  5A
00F9:  MOVIW  [FSR0+03],W
00FA:  MOVWF  5B
00FB:  MOVF   59,W
00FC:  MOVWF  58
00FD:  MOVF   5A,W
00FE:  MOVWF  59
00FF:  MOVF   5B,W
0100:  MOVWF  5A
0101:  CLRF   5B
0102:  MOVF   58,W
0103:  MOVWF  56
....................     blue = (node_list[i] >> 16) & 0xFF; 
0104:  RLF    53,W
0105:  MOVWF  79
0106:  RLF    54,W
0107:  MOVWF  7A
0108:  RLF    79,F
0109:  RLF    7A,F
010A:  MOVLW  FC
010B:  ANDWF  79,F
010C:  MOVF   79,W
010D:  ADDLW  08
010E:  MOVWF  04
010F:  MOVLW  20
0110:  ADDWFC 7A,W
0111:  MOVWF  05
0112:  MOVF   00,W
0113:  MOVWF  58
0114:  MOVIW  [FSR0+01],W
0115:  MOVWF  59
0116:  MOVIW  [FSR0+02],W
0117:  MOVWF  5A
0118:  MOVIW  [FSR0+03],W
0119:  MOVWF  5B
011A:  MOVF   5A,W
011B:  MOVWF  58
011C:  MOVF   5B,W
011D:  MOVWF  59
011E:  CLRF   5A
011F:  CLRF   5B
0120:  MOVF   58,W
0121:  MOVWF  57
....................     spi_write(blue); 
0122:  MOVLB  04
0123:  MOVF   11,W
0124:  MOVLB  03
0125:  MOVF   57,W
0126:  MOVLB  04
0127:  MOVWF  11
0128:  RRF    14,W
0129:  BTFSS  03.0
012A:  GOTO   128
....................     spi_write(green); 
012B:  MOVF   11,W
012C:  MOVLB  03
012D:  MOVF   56,W
012E:  MOVLB  04
012F:  MOVWF  11
0130:  RRF    14,W
0131:  BTFSS  03.0
0132:  GOTO   130
....................     spi_write(red); 
0133:  MOVF   11,W
0134:  MOVLB  03
0135:  MOVF   55,W
0136:  MOVLB  04
0137:  MOVWF  11
0138:  RRF    14,W
0139:  BTFSS  03.0
013A:  GOTO   138
013B:  MOVLB  03
013C:  INCF   53,F
013D:  BTFSC  03.2
013E:  INCF   54,F
013F:  GOTO   0C6
....................   } 
....................   delay_us(500);    // delay 500us to latch the IC 
0140:  MOVLW  02
0141:  MOVWF  58
0142:  MOVLW  FA
0143:  MOVWF  59
0144:  MOVLB  00
0145:  CALL   0AF
0146:  MOVLB  03
0147:  DECFSZ 58,F
0148:  GOTO   142
0149:  MOVLB  00
014A:  RETURN
.................... } 
....................  
....................  
.................... #endif 
.................... #ifdef WS2811 
....................     #include "WS2811_SPI.c" 
.................... #endif 
.................... #include "LED_Array.c" 
.................... //FILE NAME = LED_Array.c 
.................... //Functions to generate 24bit colors patterns and manipulate them 
....................  
.................... //void addRandom(void) 
.................... 	//shifts all dots one to the right and adds 1 random value 
....................  
.................... //int32 Color(int r, int g, int b) 
.................... 	// Create a 24 bit color value from R,G,B 
....................  
.................... //int32 Wheel(int16 WheelPos){ 
.................... 	//Input a value 0 to 767 to get a color value. 
.................... 	//The colours are a transition r - g -b - back to r 
....................  
.................... //void MakeAllColor(int32 color_set) 
.................... 	//make all LEDS one color (overloaded function) 
....................  
.................... //void MakeAllColor(int red, int green, int blue) 
.................... 	//make all LEDS one color, overloaded to accept red, green blue inputs 
....................  
.................... //void setup() 
.................... 	////Clear out the array 
....................  
.................... //NOT IN THE FILE ANYMORE 
....................  
.................... //void ShiftRight(int16 newval) 
.................... 	//Shift right, Shift the node_list one to the right 
.................... 	//[i] -> [i+1]. Insert newval in node_list[0] 
....................  
.................... //void ShiftRight(int32 newval) 
.................... 	//Shift right, Shift the node_list one to the right 
.................... 	//[i] -> [i+1]. Insert newval in node_list[0] 
....................  
.................... void addRandom(void) { 
*
058F:  CLRF   4F
0590:  CLRF   4E
0591:  CLRF   4D
0592:  CLRF   4C
....................   unsigned int16 x; 
....................   unsigned int32 new_color = 0; 
....................  
....................   //First, shuffle all the current colors down one spot on the strip 
....................   for(x = (TDOTS - 1) ; x > 0 ; x--) 
0593:  CLRF   4B
0594:  MOVLW  2A
0595:  MOVWF  4A
0596:  MOVF   4A,F
0597:  BTFSS  03.2
0598:  GOTO   59C
0599:  MOVF   4B,F
059A:  BTFSC  03.2
059B:  GOTO   5EA
....................     node_list[x] = node_list[x - 1]; 
059C:  RLF    4A,W
059D:  MOVWF  79
059E:  RLF    4B,W
059F:  MOVWF  7A
05A0:  RLF    79,F
05A1:  RLF    7A,F
05A2:  MOVLW  FC
05A3:  ANDWF  79,F
05A4:  MOVF   79,W
05A5:  ADDLW  08
05A6:  MOVWF  78
05A7:  MOVLW  20
05A8:  ADDWFC 7A,F
05A9:  MOVF   78,W
05AA:  MOVWF  50
05AB:  MOVF   7A,W
05AC:  MOVWF  51
05AD:  MOVLW  01
05AE:  SUBWF  4A,W
05AF:  MOVWF  52
05B0:  MOVLW  00
05B1:  SUBWFC 4B,W
05B2:  MOVWF  53
05B3:  RLF    52,W
05B4:  MOVWF  79
05B5:  RLF    53,W
05B6:  MOVWF  7A
05B7:  RLF    79,F
05B8:  RLF    7A,F
05B9:  MOVLW  FC
05BA:  ANDWF  79,F
05BB:  MOVF   79,W
05BC:  ADDLW  08
05BD:  MOVWF  04
05BE:  MOVLW  20
05BF:  ADDWFC 7A,W
05C0:  MOVWF  05
05C1:  MOVF   00,W
05C2:  MOVWF  77
05C3:  ADDFSR 01,FSR0
05C4:  MOVF   00,W
05C5:  MOVWF  78
05C6:  ADDFSR 01,FSR0
05C7:  MOVF   00,W
05C8:  MOVWF  79
05C9:  ADDFSR 01,FSR0
05CA:  MOVF   00,W
05CB:  MOVWF  7A
05CC:  ADDFSR 3D,FSR0
05CD:  MOVF   7A,W
05CE:  MOVWF  55
05CF:  MOVF   79,W
05D0:  MOVWF  54
05D1:  MOVF   78,W
05D2:  MOVWF  53
05D3:  MOVF   77,W
05D4:  MOVWF  52
05D5:  MOVF   51,W
05D6:  MOVWF  05
05D7:  MOVF   50,W
05D8:  MOVWF  04
05D9:  MOVF   52,W
05DA:  MOVWF  00
05DB:  ADDFSR 01,FSR0
05DC:  MOVF   53,W
05DD:  MOVWF  00
05DE:  ADDFSR 01,FSR0
05DF:  MOVF   54,W
05E0:  MOVWF  00
05E1:  ADDFSR 01,FSR0
05E2:  MOVF   55,W
05E3:  MOVWF  00
05E4:  ADDFSR 3D,FSR0
05E5:  MOVF   4A,W
05E6:  BTFSC  03.2
05E7:  DECF   4B,F
05E8:  DECF   4A,F
05E9:  GOTO   596
....................  
....................   //Now form a new RGB color 
....................   for(x = 0 ; x < 3 ; x++){ 
05EA:  CLRF   4B
05EB:  CLRF   4A
05EC:  MOVF   4B,F
05ED:  BTFSS  03.2
05EE:  GOTO   605
05EF:  MOVF   4A,W
05F0:  SUBLW  02
05F1:  BTFSS  03.0
05F2:  GOTO   605
....................     new_color <<= 8; 
05F3:  MOVF   4E,W
05F4:  MOVWF  4F
05F5:  MOVF   4D,W
05F6:  MOVWF  4E
05F7:  MOVF   4C,W
05F8:  MOVWF  4D
05F9:  CLRF   4C
....................     new_color |= rand(); //Give me a number from 0 to 0xFF 
05FA:  MOVLB  00
05FB:  CALL   239
05FC:  MOVF   78,W
05FD:  MOVLB  03
05FE:  IORWF  4C,F
05FF:  MOVF   79,W
0600:  IORWF  4D,F
0601:  INCF   4A,F
0602:  BTFSC  03.2
0603:  INCF   4B,F
0604:  GOTO   5EC
....................   } 
....................   node_list[0] = new_color; //Add the new random color to the strip 
0605:  MOVF   4F,W
0606:  MOVLB  00
0607:  MOVWF  2B
0608:  MOVLB  03
0609:  MOVF   4E,W
060A:  MOVLB  00
060B:  MOVWF  2A
060C:  MOVLB  03
060D:  MOVF   4D,W
060E:  MOVLB  00
060F:  MOVWF  29
0610:  MOVLB  03
0611:  MOVF   4C,W
0612:  MOVLB  00
0613:  MOVWF  28
.................... } 
....................  
.................... // Create a 24 bit color value from R,G,B 
.................... int32 Color(int r, int g, int b){ 
....................   //Take the lowest 8bits of each value and append them end to end 
....................   	return( ((int32)(b & 0xFF)<<16) | ((int32)(g & 0xFF)<<8) | (int32)(r & 0xFF) ); 
*
007C:  MOVLB  03
007D:  MOVF   5C,W
007E:  CLRF   60
007F:  CLRF   5F
0080:  CLRF   5E
0081:  MOVWF  5D
0082:  MOVF   5E,W
0083:  MOVWF  60
0084:  MOVF   5D,W
0085:  MOVWF  5F
0086:  CLRF   5D
0087:  CLRF   5E
0088:  MOVF   5B,W
0089:  CLRF   65
008A:  CLRF   64
008B:  CLRF   63
008C:  MOVWF  62
008D:  MOVF   64,W
008E:  MOVWF  7A
008F:  MOVF   63,W
0090:  MOVWF  79
0091:  MOVF   62,W
0092:  MOVWF  78
0093:  CLRF   77
0094:  MOVF   77,W
0095:  IORWF  5D,F
0096:  MOVF   62,W
0097:  IORWF  5E,F
0098:  MOVF   63,W
0099:  IORWF  5F,F
009A:  MOVF   64,W
009B:  IORWF  60,F
009C:  MOVF   5A,W
009D:  MOVWF  77
009E:  CLRF   78
009F:  CLRF   79
00A0:  CLRF   7A
00A1:  MOVF   5A,W
00A2:  IORWF  5D,W
00A3:  MOVWF  77
00A4:  MOVF   78,W
00A5:  IORWF  5E,W
00A6:  MOVWF  78
00A7:  MOVF   79,W
00A8:  IORWF  5F,W
00A9:  MOVWF  79
00AA:  MOVF   7A,W
00AB:  IORWF  60,W
00AC:  MOVWF  7A
00AD:  MOVLB  00
00AE:  RETURN
.................... } 
....................  
.................... //Input a value 0 to 767 to get a color value. 
.................... //The colours are a transition r - g -b - back to r 
.................... int32 Wheel(int16 WheelPos){ 
....................   int16 r; 
....................   int16 g; 
....................   int16 b; 
....................   switch(WheelPos >> 8)  { 
*
018E:  MOVLB  03
018F:  MOVF   53,W
0190:  CLRF   7A
0191:  MOVWF  77
0192:  MOVF   7A,W
0193:  BTFSS  03.2
0194:  GOTO   19A
0195:  MOVF   77,F
0196:  MOVLB  00
0197:  BTFSC  03.2
0198:  GOTO   1AD
0199:  MOVLB  03
019A:  MOVF   7A,W
019B:  BTFSS  03.2
019C:  GOTO   1A3
019D:  MOVLW  01
019E:  SUBWF  77,W
019F:  MOVLB  00
01A0:  BTFSC  03.2
01A1:  GOTO   1BC
01A2:  MOVLB  03
01A3:  MOVF   7A,W
01A4:  BTFSS  03.2
01A5:  GOTO   1AC
01A6:  MOVLW  02
01A7:  SUBWF  77,W
01A8:  MOVLB  00
01A9:  BTFSC  03.2
01AA:  GOTO   1CB
01AB:  MOVLB  03
01AC:  GOTO   1D9
....................     case 0: 
....................       r=255- WheelPos % 256;   //Red down 
01AD:  MOVLB  03
01AE:  CLRF   7A
01AF:  MOVF   52,W
01B0:  SUBLW  FF
01B1:  MOVWF  54
01B2:  MOVLW  00
01B3:  MOVWF  55
01B4:  MOVF   7A,W
01B5:  SUBWFC 55,F
....................       g=WheelPos % 256;      // Green up 
01B6:  MOVF   52,W
01B7:  MOVWF  56
01B8:  CLRF   57
....................       b=0;                  //blue off 
01B9:  CLRF   59
01BA:  CLRF   58
....................       break; 
01BB:  GOTO   1D9
....................     case 1: 
....................       g=255- WheelPos % 256;  //green down 
01BC:  MOVLB  03
01BD:  CLRF   7A
01BE:  MOVF   52,W
01BF:  SUBLW  FF
01C0:  MOVWF  56
01C1:  MOVLW  00
01C2:  MOVWF  57
01C3:  MOVF   7A,W
01C4:  SUBWFC 57,F
....................       b=WheelPos % 256;      //blue up 
01C5:  MOVF   52,W
01C6:  MOVWF  58
01C7:  CLRF   59
....................       r=0;                  //red off 
01C8:  CLRF   55
01C9:  CLRF   54
....................       break; 
01CA:  GOTO   1D9
....................     case 2: 
....................       b=255- WheelPos % 256;  //blue down 
01CB:  MOVLB  03
01CC:  CLRF   7A
01CD:  MOVF   52,W
01CE:  SUBLW  FF
01CF:  MOVWF  58
01D0:  MOVLW  00
01D1:  MOVWF  59
01D2:  MOVF   7A,W
01D3:  SUBWFC 59,F
....................       r=WheelPos % 256;      //red up 
01D4:  MOVF   52,W
01D5:  MOVWF  54
01D6:  CLRF   55
....................       g=0;                  //green off 
01D7:  CLRF   57
01D8:  CLRF   56
....................       break; 
....................   } 
....................   return(Color(r,g,b)); 
01D9:  MOVF   54,W
01DA:  MOVWF  5A
01DB:  MOVF   56,W
01DC:  MOVWF  5B
01DD:  MOVF   58,W
01DE:  MOVWF  5C
01DF:  MOVLB  00
01E0:  CALL   07C
01E1:  RETURN
.................... } 
....................  
.................... //make all LEDS one color (overloaded function) 
.................... void MakeAllColor(int32 color_set){ 
.................... 	int i; 
.................... 	for(i=0; i<TDOTS; i++) 
*
014B:  MOVLB  03
014C:  CLRF   52
014D:  MOVF   52,W
014E:  SUBLW  2A
014F:  BTFSS  03.0
0150:  GOTO   167
.................... 	{ 
....................             node_list[i] = color_set; 
0151:  RLF    52,W
0152:  MOVWF  77
0153:  RLF    77,F
0154:  MOVLW  FC
0155:  ANDWF  77,F
0156:  MOVF   77,W
0157:  ADDLW  08
0158:  MOVWF  04
0159:  MOVLW  20
015A:  MOVWF  05
015B:  BTFSC  03.0
015C:  INCF   05,F
015D:  MOVF   4E,W
015E:  MOVWF  00
015F:  MOVF   4F,W
0160:  MOVWI  W,[FSR0+01]
0161:  MOVF   50,W
0162:  MOVWI  W,[FSR0+02]
0163:  MOVF   51,W
0164:  MOVWI  W,[FSR0+03]
0165:  INCF   52,F
0166:  GOTO   14D
.................... 	} 
.................... 	send_frame(); 
0167:  MOVLB  00
0168:  CALL   0C3
0169:  RETURN
.................... } 
....................  
.................... //make all LEDS one color, overloaded to accept red, green blue inputs 
.................... void MakeAllColor(int red, int green, int blue) { 
.................... 	int i; 
.................... 	for(i=0; i<TDOTS; i++) 
.................... 	{ 
....................             node_list[i] = color(red, green, blue); 
.................... 	} 
.................... 	send_frame(); 
.................... } 
....................  
.................... void setup() { 
....................     int x; 
....................     //Clear out the array 
....................     for(x = 0; x < TDOTS ; x++){ 
*
07AA:  MOVLB  02
07AB:  CLRF   5B
07AC:  MOVF   5B,W
07AD:  SUBLW  2A
07AE:  BTFSS  03.0
07AF:  GOTO   7C5
....................         node_list[x] = 0; 
07B0:  RLF    5B,W
07B1:  MOVWF  77
07B2:  RLF    77,F
07B3:  MOVLW  FC
07B4:  ANDWF  77,F
07B5:  MOVF   77,W
07B6:  ADDLW  08
07B7:  MOVWF  04
07B8:  MOVLW  20
07B9:  MOVWF  05
07BA:  BTFSC  03.0
07BB:  INCF   05,F
07BC:  CLRF   00
07BD:  ADDFSR 01,FSR0
07BE:  CLRF   00
07BF:  ADDFSR 01,FSR0
07C0:  CLRF   00
07C1:  ADDFSR 01,FSR0
07C2:  CLRF   00
07C3:  INCF   5B,F
07C4:  GOTO   7AC
....................     } 
....................     send_frame(); 
07C5:  MOVLB  00
07C6:  CALL   0C3
07C7:  MOVLP  08
07C8:  GOTO   300 (RETURN)
.................... } 
....................  
.................... void ShiftRight(int32 newval){ 
....................         int newPosition; 
.................... 	for(newPosition = (TDOTS)-1; newPosition > 0; newPosition--) { 
*
02AE:  MOVLW  2A
02AF:  MOVLB  03
02B0:  MOVWF  5A
02B1:  MOVF   5A,F
02B2:  BTFSC  03.2
02B3:  GOTO   2F4
....................             node_list[newPosition] = node_list[newPosition - 1]; 
02B4:  RLF    5A,W
02B5:  MOVWF  77
02B6:  RLF    77,F
02B7:  MOVLW  FC
02B8:  ANDWF  77,F
02B9:  MOVF   77,W
02BA:  ADDLW  08
02BB:  MOVWF  78
02BC:  MOVLW  20
02BD:  MOVWF  7A
02BE:  BTFSC  03.0
02BF:  INCF   7A,F
02C0:  MOVF   78,W
02C1:  MOVWF  5B
02C2:  MOVF   7A,W
02C3:  MOVWF  5C
02C4:  MOVLW  01
02C5:  SUBWF  5A,W
02C6:  MOVWF  77
02C7:  RLF    77,F
02C8:  RLF    77,F
02C9:  MOVLW  FC
02CA:  ANDWF  77,F
02CB:  MOVF   77,W
02CC:  ADDLW  08
02CD:  MOVWF  04
02CE:  MOVLW  20
02CF:  MOVWF  05
02D0:  BTFSC  03.0
02D1:  INCF   05,F
02D2:  MOVF   00,W
02D3:  MOVWF  77
02D4:  ADDFSR 01,FSR0
02D5:  MOVF   00,W
02D6:  MOVWF  78
02D7:  ADDFSR 01,FSR0
02D8:  MOVF   00,W
02D9:  MOVWF  79
02DA:  ADDFSR 01,FSR0
02DB:  MOVF   00,W
02DC:  MOVWF  7A
02DD:  ADDFSR 3D,FSR0
02DE:  MOVF   7A,W
02DF:  MOVWF  60
02E0:  MOVF   79,W
02E1:  MOVWF  5F
02E2:  MOVF   78,W
02E3:  MOVWF  5E
02E4:  MOVF   77,W
02E5:  MOVWF  5D
02E6:  MOVF   5C,W
02E7:  MOVWF  05
02E8:  MOVF   5B,W
02E9:  MOVWF  04
02EA:  MOVF   5D,W
02EB:  MOVWF  00
02EC:  MOVF   5E,W
02ED:  MOVWI  W,[FSR0+01]
02EE:  MOVF   5F,W
02EF:  MOVWI  W,[FSR0+02]
02F0:  MOVF   60,W
02F1:  MOVWI  W,[FSR0+03]
02F2:  DECF   5A,F
02F3:  GOTO   2B1
.................... 	} 
.................... 	node_list[0] = newval; // fill the gap 
02F4:  MOVF   59,W
02F5:  MOVLB  00
02F6:  MOVWF  2B
02F7:  MOVLB  03
02F8:  MOVF   58,W
02F9:  MOVLB  00
02FA:  MOVWF  2A
02FB:  MOVLB  03
02FC:  MOVF   57,W
02FD:  MOVLB  00
02FE:  MOVWF  29
02FF:  MOVLB  03
0300:  MOVF   56,W
0301:  MOVLB  00
0302:  MOVWF  28
0303:  RETURN
.................... } 
....................  
.................... void ShiftLeft(int32 newval){ 
....................         int newPosition; 
.................... 	for(newPosition = 0; newPosition < (TDOTS - 1); newPosition++) { 
....................             node_list[newPosition] = node_list[newPosition + 1]; 
.................... 	} 
.................... 	node_list[TDOTS - 1] = newval; // fill the gap 
.................... } 
....................  
.................... #include "LED_Patterns.c" 
.................... //FILE NAME = LED_Patterns.h 
.................... // A Collection of patterns to run using WS2801 leds using the RTOS system 
....................  
.................... void MakeAllRed(){ 
....................     MakeAllColor(Color(255, 0, 0)); 
*
03E1:  MOVLW  FF
03E2:  MOVLB  03
03E3:  MOVWF  5A
03E4:  CLRF   5B
03E5:  CLRF   5C
03E6:  MOVLB  00
03E7:  CALL   07C
03E8:  MOVF   7A,W
03E9:  MOVLB  03
03EA:  MOVWF  4D
03EB:  MOVF   79,W
03EC:  MOVWF  4C
03ED:  MOVF   78,W
03EE:  MOVWF  4B
03EF:  MOVF   77,W
03F0:  MOVWF  4A
03F1:  MOVF   4D,W
03F2:  MOVWF  51
03F3:  MOVF   4C,W
03F4:  MOVWF  50
03F5:  MOVF   4B,W
03F6:  MOVWF  4F
03F7:  MOVF   4A,W
03F8:  MOVWF  4E
03F9:  MOVLB  00
03FA:  CALL   14B
.................... } 
....................  
.................... void MakeAllGreen(){ 
....................     MakeAllColor(Color(0, 255, 0)); 
*
03FE:  MOVLB  03
03FF:  CLRF   5A
0400:  MOVLW  FF
0401:  MOVWF  5B
0402:  CLRF   5C
0403:  MOVLB  00
0404:  CALL   07C
0405:  MOVF   7A,W
0406:  MOVLB  03
0407:  MOVWF  4D
0408:  MOVF   79,W
0409:  MOVWF  4C
040A:  MOVF   78,W
040B:  MOVWF  4B
040C:  MOVF   77,W
040D:  MOVWF  4A
040E:  MOVF   4D,W
040F:  MOVWF  51
0410:  MOVF   4C,W
0411:  MOVWF  50
0412:  MOVF   4B,W
0413:  MOVWF  4F
0414:  MOVF   4A,W
0415:  MOVWF  4E
0416:  MOVLB  00
0417:  CALL   14B
.................... } 
....................  
.................... void MakeAllBlue(){ 
....................     MakeAllColor(Color(0, 0, 255)); 
*
041B:  MOVLB  03
041C:  CLRF   5A
041D:  CLRF   5B
041E:  MOVLW  FF
041F:  MOVWF  5C
0420:  MOVLB  00
0421:  CALL   07C
0422:  MOVF   7A,W
0423:  MOVLB  03
0424:  MOVWF  4D
0425:  MOVF   79,W
0426:  MOVWF  4C
0427:  MOVF   78,W
0428:  MOVWF  4B
0429:  MOVF   77,W
042A:  MOVWF  4A
042B:  MOVF   4D,W
042C:  MOVWF  51
042D:  MOVF   4C,W
042E:  MOVWF  50
042F:  MOVF   4B,W
0430:  MOVWF  4F
0431:  MOVF   4A,W
0432:  MOVWF  4E
0433:  MOVLB  00
0434:  CALL   14B
.................... } 
....................  
.................... void All_Rainbow_Fade_200ms() { 
....................     //Slow fade all colors       
....................     if (pattern_position[0] < 768) { 
*
0439:  MOVF   71,W
043A:  SUBLW  02
043B:  BTFSS  03.0
043C:  GOTO   47A
....................         if (Timer_Get_Timer(0) > 200) { 
043D:  MOVLB  03
043E:  CLRF   52
043F:  MOVLB  00
0440:  CALL   16A
0441:  MOVF   7A,W
0442:  MOVLB  03
0443:  MOVWF  4D
0444:  MOVF   79,W
0445:  MOVWF  4C
0446:  MOVF   78,W
0447:  MOVWF  4B
0448:  MOVF   77,W
0449:  MOVWF  4A
044A:  MOVF   4D,F
044B:  BTFSS  03.2
044C:  GOTO   457
044D:  MOVF   4C,F
044E:  BTFSS  03.2
044F:  GOTO   457
0450:  MOVF   4B,F
0451:  BTFSS  03.2
0452:  GOTO   457
0453:  MOVF   4A,W
0454:  SUBLW  C8
0455:  BTFSC  03.0
0456:  GOTO   478
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
.................... #endif 
....................             MakeAllColor(Wheel(pattern_position[0])); 
0457:  MOVF   71,W
0458:  MOVWF  53
0459:  MOVF   70,W
045A:  MOVWF  52
045B:  MOVLB  00
045C:  CALL   18E
045D:  MOVF   7A,W
045E:  MOVLB  03
045F:  MOVWF  4D
0460:  MOVF   79,W
0461:  MOVWF  4C
0462:  MOVF   78,W
0463:  MOVWF  4B
0464:  MOVF   77,W
0465:  MOVWF  4A
0466:  MOVF   4D,W
0467:  MOVWF  51
0468:  MOVF   4C,W
0469:  MOVWF  50
046A:  MOVF   4B,W
046B:  MOVWF  4F
046C:  MOVF   4A,W
046D:  MOVWF  4E
046E:  MOVLB  00
046F:  CALL   14B
....................             pattern_position[0]++; 
0470:  INCF   70,F
0471:  BTFSC  03.2
0472:  INCF   71,F
....................             Timer_Clear_Timer(0); 
0473:  MOVLB  03
0474:  CLRF   52
0475:  MOVLB  00
0476:  CALL   1E2
0477:  MOVLB  03
....................         } 
....................     } else { 
0478:  GOTO   47D
0479:  MOVLB  00
....................         pattern_position[0] = 0; 
047A:  CLRF   71
047B:  CLRF   70
047C:  MOVLB  03
....................     } 
.................... } 
....................  
.................... void Dot_Rainbow_Fade() { 
....................     int16 i; 
....................     int32 temp_color; 
....................     // 3 cycles of all 768 colors in the wheel 
....................     if (pattern_position[0] < 768) { 
*
0481:  MOVF   71,W
0482:  SUBLW  02
0483:  BTFSS  03.0
0484:  GOTO   511
....................         if (Timer_Get_Timer(0) > delay_time_ms) { 
0485:  MOVLB  03
0486:  CLRF   52
0487:  MOVLB  00
0488:  CALL   16A
0489:  MOVF   7A,W
048A:  MOVLB  03
048B:  MOVWF  53
048C:  MOVF   79,W
048D:  MOVWF  52
048E:  MOVF   78,W
048F:  MOVWF  51
0490:  MOVF   77,W
0491:  MOVWF  50
0492:  MOVF   53,F
0493:  BTFSS  03.2
0494:  GOTO   4A8
0495:  MOVF   52,F
0496:  BTFSS  03.2
0497:  GOTO   4A8
0498:  MOVLB  02
0499:  MOVF   3B,W
049A:  MOVLB  03
049B:  SUBWF  51,W
049C:  BTFSS  03.0
049D:  GOTO   50F
049E:  BTFSS  03.2
049F:  GOTO   4A8
04A0:  MOVF   50,W
04A1:  MOVLB  02
04A2:  SUBWF  3A,W
04A3:  BTFSS  03.0
04A4:  GOTO   4A7
04A5:  MOVLB  03
04A6:  GOTO   50F
04A7:  MOVLB  03
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
.................... #endif 
....................             for (i = 0; i < TDOTS; i++) { 
04A8:  CLRF   4B
04A9:  CLRF   4A
04AA:  MOVF   4B,F
04AB:  BTFSS  03.2
04AC:  GOTO   505
04AD:  MOVF   4A,W
04AE:  SUBLW  2A
04AF:  BTFSS  03.0
04B0:  GOTO   505
....................                 temp_color = Wheel(((i * 20) + (pattern_position[0] * 10)) % 768); 
04B1:  MOVF   4B,W
04B2:  MOVWF  53
04B3:  MOVF   4A,W
04B4:  MOVWF  52
04B5:  CLRF   55
04B6:  MOVLW  14
04B7:  MOVWF  54
04B8:  MOVLB  00
04B9:  CALL   1FB
04BA:  MOVF   79,W
04BB:  MOVLB  03
04BC:  MOVWF  51
04BD:  MOVF   78,W
04BE:  MOVWF  50
04BF:  MOVF   71,W
04C0:  MOVWF  53
04C1:  MOVF   70,W
04C2:  MOVWF  52
04C3:  CLRF   55
04C4:  MOVLW  0A
04C5:  MOVWF  54
04C6:  MOVLB  00
04C7:  CALL   1FB
04C8:  MOVF   79,W
04C9:  MOVWF  7A
04CA:  MOVF   78,W
04CB:  MOVLB  03
04CC:  ADDWF  50,F
04CD:  MOVF   79,W
04CE:  ADDWFC 51,F
04CF:  MOVF   51,W
04D0:  MOVWF  54
04D1:  MOVF   50,W
04D2:  MOVWF  53
04D3:  MOVLW  03
04D4:  MOVWF  56
04D5:  CLRF   55
04D6:  MOVLB  00
04D7:  CALL   212
04D8:  MOVF   77,W
04D9:  MOVLB  03
04DA:  MOVWF  50
04DB:  MOVF   7A,W
04DC:  MOVWF  51
04DD:  MOVWF  53
04DE:  MOVF   50,W
04DF:  MOVWF  52
04E0:  MOVLB  00
04E1:  CALL   18E
04E2:  MOVF   7A,W
04E3:  MOVLB  03
04E4:  MOVWF  4F
04E5:  MOVF   79,W
04E6:  MOVWF  4E
04E7:  MOVF   78,W
04E8:  MOVWF  4D
04E9:  MOVF   77,W
04EA:  MOVWF  4C
....................                 node_list[i] = temp_color; 
04EB:  RLF    4A,W
04EC:  MOVWF  79
04ED:  RLF    4B,W
04EE:  MOVWF  7A
04EF:  RLF    79,F
04F0:  RLF    7A,F
04F1:  MOVLW  FC
04F2:  ANDWF  79,F
04F3:  MOVF   79,W
04F4:  ADDLW  08
04F5:  MOVWF  04
04F6:  MOVLW  20
04F7:  ADDWFC 7A,W
04F8:  MOVWF  05
04F9:  MOVF   4C,W
04FA:  MOVWF  00
04FB:  MOVF   4D,W
04FC:  MOVWI  W,[FSR0+01]
04FD:  MOVF   4E,W
04FE:  MOVWI  W,[FSR0+02]
04FF:  MOVF   4F,W
0500:  MOVWI  W,[FSR0+03]
0501:  INCF   4A,F
0502:  BTFSC  03.2
0503:  INCF   4B,F
0504:  GOTO   4AA
....................             } 
....................             send_frame(); 
0505:  MOVLB  00
0506:  CALL   0C3
....................             pattern_position[0]++; 
0507:  INCF   70,F
0508:  BTFSC  03.2
0509:  INCF   71,F
....................             Timer_Clear_Timer(0); 
050A:  MOVLB  03
050B:  CLRF   52
050C:  MOVLB  00
050D:  CALL   1E2
050E:  MOVLB  03
....................         } 
....................     } else { 
050F:  GOTO   514
0510:  MOVLB  00
....................         pattern_position[0] = 0; 
0511:  CLRF   71
0512:  CLRF   70
0513:  MOVLB  03
....................     } 
.................... } 
....................  
.................... void All_Rainbow_Fade() { 
....................     //Slow fade all colors 
....................     if (pattern_position[0] < 768) { 
*
0518:  MOVF   71,W
0519:  SUBLW  02
051A:  BTFSS  03.0
051B:  GOTO   562
....................         if (Timer_Get_Timer(0) > delay_time_ms) { 
051C:  MOVLB  03
051D:  CLRF   52
051E:  MOVLB  00
051F:  CALL   16A
0520:  MOVF   7A,W
0521:  MOVLB  03
0522:  MOVWF  4D
0523:  MOVF   79,W
0524:  MOVWF  4C
0525:  MOVF   78,W
0526:  MOVWF  4B
0527:  MOVF   77,W
0528:  MOVWF  4A
0529:  MOVF   4D,F
052A:  BTFSS  03.2
052B:  GOTO   53F
052C:  MOVF   4C,F
052D:  BTFSS  03.2
052E:  GOTO   53F
052F:  MOVLB  02
0530:  MOVF   3B,W
0531:  MOVLB  03
0532:  SUBWF  4B,W
0533:  BTFSS  03.0
0534:  GOTO   560
0535:  BTFSS  03.2
0536:  GOTO   53F
0537:  MOVF   4A,W
0538:  MOVLB  02
0539:  SUBWF  3A,W
053A:  BTFSS  03.0
053B:  GOTO   53E
053C:  MOVLB  03
053D:  GOTO   560
053E:  MOVLB  03
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
.................... #endif 
....................             MakeAllColor(Wheel(pattern_position[0])); 
053F:  MOVF   71,W
0540:  MOVWF  53
0541:  MOVF   70,W
0542:  MOVWF  52
0543:  MOVLB  00
0544:  CALL   18E
0545:  MOVF   7A,W
0546:  MOVLB  03
0547:  MOVWF  4D
0548:  MOVF   79,W
0549:  MOVWF  4C
054A:  MOVF   78,W
054B:  MOVWF  4B
054C:  MOVF   77,W
054D:  MOVWF  4A
054E:  MOVF   4D,W
054F:  MOVWF  51
0550:  MOVF   4C,W
0551:  MOVWF  50
0552:  MOVF   4B,W
0553:  MOVWF  4F
0554:  MOVF   4A,W
0555:  MOVWF  4E
0556:  MOVLB  00
0557:  CALL   14B
....................             pattern_position[0]++; 
0558:  INCF   70,F
0559:  BTFSC  03.2
055A:  INCF   71,F
....................             Timer_Clear_Timer(0); 
055B:  MOVLB  03
055C:  CLRF   52
055D:  MOVLB  00
055E:  CALL   1E2
055F:  MOVLB  03
....................         } 
....................     } else { 
0560:  GOTO   565
0561:  MOVLB  00
....................         pattern_position[0] = 0; 
0562:  CLRF   71
0563:  CLRF   70
0564:  MOVLB  03
....................     } 
.................... } 
....................  
.................... void Random_Chain() { 
....................     //Start with random colors then push random colors down 
....................     if (Timer_Get_Timer(0) > delay_time_ms*2) { 
*
0569:  MOVLB  03
056A:  CLRF   52
056B:  MOVLB  00
056C:  CALL   16A
056D:  MOVF   7A,W
056E:  MOVLB  03
056F:  MOVWF  4D
0570:  MOVF   79,W
0571:  MOVWF  4C
0572:  MOVF   78,W
0573:  MOVWF  4B
0574:  MOVF   77,W
0575:  MOVWF  4A
0576:  BCF    03.0
0577:  MOVLB  02
0578:  RLF    3A,W
0579:  MOVWF  79
057A:  RLF    3B,W
057B:  MOVWF  7A
057C:  MOVF   79,W
057D:  MOVWF  78
057E:  MOVLB  03
057F:  MOVF   4D,F
0580:  BTFSS  03.2
0581:  GOTO   58F
0582:  MOVF   4C,F
0583:  BTFSS  03.2
0584:  GOTO   58F
0585:  MOVF   7A,W
0586:  SUBWF  4B,W
0587:  BTFSS  03.0
0588:  GOTO   61A
0589:  BTFSS  03.2
058A:  GOTO   58F
058B:  MOVF   4A,W
058C:  SUBWF  78,W
058D:  BTFSC  03.0
058E:  GOTO   61A
....................         addRandom(); 
....................         send_frame(); 
*
0614:  CALL   0C3
....................         Timer_Clear_Timer(0); 
0615:  MOVLB  03
0616:  CLRF   52
0617:  MOVLB  00
0618:  CALL   1E2
0619:  MOVLB  03
....................     } 
.................... } 
....................  
.................... //push in 3 leds of color selected than shift it 1 led each time, 3 blanks 
.................... void ShiftThreeColorThreeBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
0304:  MOVLB  03
0305:  CLRF   52
0306:  MOVLB  00
0307:  CALL   16A
0308:  MOVF   7A,W
0309:  MOVLB  03
030A:  MOVWF  55
030B:  MOVF   79,W
030C:  MOVWF  54
030D:  MOVF   78,W
030E:  MOVWF  53
030F:  MOVF   77,W
0310:  MOVWF  52
0311:  MOVF   55,F
0312:  BTFSS  03.2
0313:  GOTO   327
0314:  MOVF   54,F
0315:  BTFSS  03.2
0316:  GOTO   327
0317:  MOVLB  02
0318:  MOVF   3B,W
0319:  MOVLB  03
031A:  SUBWF  53,W
031B:  BTFSS  03.0
031C:  GOTO   372
031D:  BTFSS  03.2
031E:  GOTO   327
031F:  MOVF   52,W
0320:  MOVLB  02
0321:  SUBWF  3A,W
0322:  BTFSS  03.0
0323:  GOTO   326
0324:  MOVLB  03
0325:  GOTO   372
0326:  MOVLB  03
....................         if (pattern_position[0] >= 6) { 
0327:  MOVF   71,F
0328:  BTFSS  03.2
0329:  GOTO   32E
032A:  MOVF   70,W
032B:  SUBLW  05
032C:  BTFSC  03.0
032D:  GOTO   330
....................             pattern_position[0] = 0; 
032E:  CLRF   71
032F:  CLRF   70
....................         } 
....................         if (pattern_position[0] % 6 < 3) { 
0330:  MOVF   71,W
0331:  MOVWF  54
0332:  MOVF   70,W
0333:  MOVWF  53
0334:  CLRF   56
0335:  MOVLW  06
0336:  MOVWF  55
0337:  MOVLB  00
0338:  CALL   212
0339:  MOVF   77,W
033A:  MOVLB  03
033B:  MOVWF  52
033C:  MOVF   7A,W
033D:  MOVWF  53
033E:  MOVF   53,F
033F:  BTFSS  03.2
0340:  GOTO   351
0341:  MOVF   52,W
0342:  SUBLW  02
0343:  BTFSS  03.0
0344:  GOTO   351
....................             ShiftRight(color_set); 
0345:  MOVF   51,W
0346:  MOVWF  59
0347:  MOVF   50,W
0348:  MOVWF  58
0349:  MOVF   4F,W
034A:  MOVWF  57
034B:  MOVF   4E,W
034C:  MOVWF  56
034D:  MOVLB  00
034E:  CALL   2AE
....................         } else { 
034F:  GOTO   369
0350:  MOVLB  03
....................             ShiftRight(color(0, 0, 0)); 
0351:  CLRF   5A
0352:  CLRF   5B
0353:  CLRF   5C
0354:  MOVLB  00
0355:  CALL   07C
0356:  MOVF   7A,W
0357:  MOVLB  03
0358:  MOVWF  55
0359:  MOVF   79,W
035A:  MOVWF  54
035B:  MOVF   78,W
035C:  MOVWF  53
035D:  MOVF   77,W
035E:  MOVWF  52
035F:  MOVF   55,W
0360:  MOVWF  59
0361:  MOVF   54,W
0362:  MOVWF  58
0363:  MOVF   53,W
0364:  MOVWF  57
0365:  MOVF   52,W
0366:  MOVWF  56
0367:  MOVLB  00
0368:  CALL   2AE
....................         } 
....................         send_frame(); 
0369:  CALL   0C3
....................         pattern_position[0]++; 
036A:  INCF   70,F
036B:  BTFSC  03.2
036C:  INCF   71,F
....................         Timer_Clear_Timer(0); 
036D:  MOVLB  03
036E:  CLRF   52
036F:  MOVLB  00
0370:  CALL   1E2
0371:  MOVLB  03
....................     } 
0372:  MOVLB  00
0373:  RETURN
.................... } 
....................  
.................... //push in 1 leds of color selected than shift it 1 led each time, 1 blank 
.................... void ShiftOneColorOneBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
06A0:  CLRF   52
06A1:  MOVLB  00
06A2:  CALL   16A
06A3:  MOVF   7A,W
06A4:  MOVLB  03
06A5:  MOVWF  55
06A6:  MOVF   79,W
06A7:  MOVWF  54
06A8:  MOVF   78,W
06A9:  MOVWF  53
06AA:  MOVF   77,W
06AB:  MOVWF  52
06AC:  MOVF   55,F
06AD:  BTFSS  03.2
06AE:  GOTO   6C2
06AF:  MOVF   54,F
06B0:  BTFSS  03.2
06B1:  GOTO   6C2
06B2:  MOVLB  02
06B3:  MOVF   3B,W
06B4:  MOVLB  03
06B5:  SUBWF  53,W
06B6:  BTFSS  03.0
06B7:  GOTO   702
06B8:  BTFSS  03.2
06B9:  GOTO   6C2
06BA:  MOVF   52,W
06BB:  MOVLB  02
06BC:  SUBWF  3A,W
06BD:  BTFSS  03.0
06BE:  GOTO   6C1
06BF:  MOVLB  03
06C0:  GOTO   702
06C1:  MOVLB  03
....................         if (pattern_position[0] >= 2) { 
06C2:  MOVF   71,F
06C3:  BTFSS  03.2
06C4:  GOTO   6C9
06C5:  MOVF   70,W
06C6:  SUBLW  01
06C7:  BTFSC  03.0
06C8:  GOTO   6CB
....................             pattern_position[0] = 0; 
06C9:  CLRF   71
06CA:  CLRF   70
....................         } 
....................         if (pattern_position[0] % 2 < 1) { 
06CB:  MOVF   70,W
06CC:  ANDLW  01
06CD:  MOVWF  52
06CE:  CLRF   53
06CF:  MOVF   52,F
06D0:  BTFSS  03.2
06D1:  GOTO   6E1
06D2:  MOVF   53,F
06D3:  BTFSS  03.2
06D4:  GOTO   6E1
....................             ShiftRight(color_set); 
06D5:  MOVF   51,W
06D6:  MOVWF  59
06D7:  MOVF   50,W
06D8:  MOVWF  58
06D9:  MOVF   4F,W
06DA:  MOVWF  57
06DB:  MOVF   4E,W
06DC:  MOVWF  56
06DD:  MOVLB  00
06DE:  CALL   2AE
....................         } else { 
06DF:  GOTO   6F9
06E0:  MOVLB  03
....................             ShiftRight(color(0, 0, 0)); 
06E1:  CLRF   5A
06E2:  CLRF   5B
06E3:  CLRF   5C
06E4:  MOVLB  00
06E5:  CALL   07C
06E6:  MOVF   7A,W
06E7:  MOVLB  03
06E8:  MOVWF  55
06E9:  MOVF   79,W
06EA:  MOVWF  54
06EB:  MOVF   78,W
06EC:  MOVWF  53
06ED:  MOVF   77,W
06EE:  MOVWF  52
06EF:  MOVF   55,W
06F0:  MOVWF  59
06F1:  MOVF   54,W
06F2:  MOVWF  58
06F3:  MOVF   53,W
06F4:  MOVWF  57
06F5:  MOVF   52,W
06F6:  MOVWF  56
06F7:  MOVLB  00
06F8:  CALL   2AE
....................         } 
....................         send_frame(); 
06F9:  CALL   0C3
....................         pattern_position[0]++; 
06FA:  INCF   70,F
06FB:  BTFSC  03.2
06FC:  INCF   71,F
....................         Timer_Clear_Timer(0); 
06FD:  MOVLB  03
06FE:  CLRF   52
06FF:  MOVLB  00
0700:  CALL   1E2
0701:  MOVLB  03
....................     } 
.................... } 
....................  
.................... //push in 1 leds of color selected than shift it 1 led each time, 1 blank 
.................... void ShiftOneColorTwoBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
071E:  CLRF   52
071F:  MOVLB  00
0720:  CALL   16A
0721:  MOVF   7A,W
0722:  MOVLB  03
0723:  MOVWF  55
0724:  MOVF   79,W
0725:  MOVWF  54
0726:  MOVF   78,W
0727:  MOVWF  53
0728:  MOVF   77,W
0729:  MOVWF  52
072A:  MOVF   55,F
072B:  BTFSS  03.2
072C:  GOTO   740
072D:  MOVF   54,F
072E:  BTFSS  03.2
072F:  GOTO   740
0730:  MOVLB  02
0731:  MOVF   3B,W
0732:  MOVLB  03
0733:  SUBWF  53,W
0734:  BTFSS  03.0
0735:  GOTO   78A
0736:  BTFSS  03.2
0737:  GOTO   740
0738:  MOVF   52,W
0739:  MOVLB  02
073A:  SUBWF  3A,W
073B:  BTFSS  03.0
073C:  GOTO   73F
073D:  MOVLB  03
073E:  GOTO   78A
073F:  MOVLB  03
....................         if (pattern_position[0] >= 3) { 
0740:  MOVF   71,F
0741:  BTFSS  03.2
0742:  GOTO   747
0743:  MOVF   70,W
0744:  SUBLW  02
0745:  BTFSC  03.0
0746:  GOTO   749
....................             pattern_position[0] = 0; 
0747:  CLRF   71
0748:  CLRF   70
....................         } 
....................         if (pattern_position[0] % 3 < 1) { 
0749:  MOVF   71,W
074A:  MOVWF  54
074B:  MOVF   70,W
074C:  MOVWF  53
074D:  CLRF   56
074E:  MOVLW  03
074F:  MOVWF  55
0750:  MOVLB  00
0751:  CALL   212
0752:  MOVF   77,W
0753:  MOVLB  03
0754:  MOVWF  52
0755:  MOVF   7A,W
0756:  MOVWF  53
0757:  MOVF   52,F
0758:  BTFSS  03.2
0759:  GOTO   769
075A:  MOVF   53,F
075B:  BTFSS  03.2
075C:  GOTO   769
....................             ShiftRight(color_set); 
075D:  MOVF   51,W
075E:  MOVWF  59
075F:  MOVF   50,W
0760:  MOVWF  58
0761:  MOVF   4F,W
0762:  MOVWF  57
0763:  MOVF   4E,W
0764:  MOVWF  56
0765:  MOVLB  00
0766:  CALL   2AE
....................         } else { 
0767:  GOTO   781
0768:  MOVLB  03
....................             ShiftRight(color(0, 0, 0)); 
0769:  CLRF   5A
076A:  CLRF   5B
076B:  CLRF   5C
076C:  MOVLB  00
076D:  CALL   07C
076E:  MOVF   7A,W
076F:  MOVLB  03
0770:  MOVWF  55
0771:  MOVF   79,W
0772:  MOVWF  54
0773:  MOVF   78,W
0774:  MOVWF  53
0775:  MOVF   77,W
0776:  MOVWF  52
0777:  MOVF   55,W
0778:  MOVWF  59
0779:  MOVF   54,W
077A:  MOVWF  58
077B:  MOVF   53,W
077C:  MOVWF  57
077D:  MOVF   52,W
077E:  MOVWF  56
077F:  MOVLB  00
0780:  CALL   2AE
....................         } 
....................         send_frame(); 
0781:  CALL   0C3
....................         pattern_position[0]++; 
0782:  INCF   70,F
0783:  BTFSC  03.2
0784:  INCF   71,F
....................         Timer_Clear_Timer(0); 
0785:  MOVLB  03
0786:  CLRF   52
0787:  MOVLB  00
0788:  CALL   1E2
0789:  MOVLB  03
....................     } 
.................... } 
....................  
....................  
....................  
.................... void Clear_Pattern_Positions() { 
....................     int i; 
....................     for (i = 0; i < NUM_PATTERN_POSITION; i++) { 
*
0031:  MOVLB  03
0032:  CLRF   4A
0033:  MOVF   4A,W
0034:  SUBLW  01
0035:  BTFSS  03.0
0036:  GOTO   041
....................         pattern_position[i] = 0; 
0037:  BCF    03.0
0038:  RLF    4A,W
0039:  ADDLW  70
003A:  MOVWF  04
003B:  CLRF   05
003C:  CLRF   00
003D:  ADDFSR 01,FSR0
003E:  CLRF   00
003F:  INCF   4A,F
0040:  GOTO   033
....................     } 
0041:  MOVLB  00
0042:  RETURN
.................... } 
....................  
.................... void Next_Pattern() { 
....................     if ((current_pattern + 1) >= NUM_PATTERNS) { 
*
08DB:  MOVLW  01
08DC:  MOVLB  00
08DD:  ADDWF  26,W
08DE:  MOVLB  03
08DF:  MOVWF  4A
08E0:  MOVLW  00
08E1:  MOVLB  00
08E2:  ADDWFC 27,W
08E3:  MOVLB  03
08E4:  MOVWF  4B
08E5:  MOVF   4B,F
08E6:  BTFSS  03.2
08E7:  GOTO   0EC
08E8:  MOVF   4A,W
08E9:  SUBLW  0B
08EA:  BTFSC  03.0
08EB:  GOTO   0F4
....................         Clear_Pattern_Positions(); 
08EC:  MOVLP  00
08ED:  MOVLB  00
08EE:  CALL   031
08EF:  MOVLP  08
....................         current_pattern = 0; 
08F0:  CLRF   27
08F1:  CLRF   26
....................     }else{ 
08F2:  GOTO   0FB
08F3:  MOVLB  03
....................         Clear_Pattern_Positions(); 
08F4:  MOVLP  00
08F5:  MOVLB  00
08F6:  CALL   031
08F7:  MOVLP  08
....................         current_pattern++; 
08F8:  INCF   26,F
08F9:  BTFSC  03.2
08FA:  INCF   27,F
....................     } 
....................     pattern_set = 0; 
08FB:  BCF    74.0
.................... } 
....................  
.................... void Previous_Pattern() { 
....................     if (current_pattern == 0){ 
*
090A:  MOVLB  00
090B:  MOVF   26,F
090C:  BTFSS  03.2
090D:  GOTO   118
090E:  MOVF   27,F
090F:  BTFSS  03.2
0910:  GOTO   118
....................         Clear_Pattern_Positions(); 
0911:  MOVLP  00
0912:  CALL   031
0913:  MOVLP  08
....................         current_pattern = NUM_PATTERNS - 1; 
0914:  CLRF   27
0915:  MOVLW  0B
0916:  MOVWF  26
....................     }else{ 
0917:  GOTO   11F
....................         Clear_Pattern_Positions(); 
0918:  MOVLP  00
0919:  CALL   031
091A:  MOVLP  08
....................         current_pattern--; 
091B:  MOVF   26,W
091C:  BTFSC  03.2
091D:  DECF   27,F
091E:  DECF   26,F
....................     } 
....................     pattern_set = 0; 
091F:  BCF    74.0
.................... } 
....................  
.................... void Speed_Up_Pattern() { 
....................     if(delay_time_ms < 3000){ 
*
092E:  MOVF   3B,W
092F:  SUBLW  0B
0930:  BTFSS  03.0
0931:  GOTO   13C
0932:  BTFSS  03.2
0933:  GOTO   138
0934:  MOVF   3A,W
0935:  SUBLW  B7
0936:  BTFSS  03.0
0937:  GOTO   13C
....................         delay_time_ms = delay_time_ms + DELAY_TIME_MS_JUMP; 
0938:  MOVLW  32
0939:  ADDWF  3A,F
093A:  MOVLW  00
093B:  ADDWFC 3B,F
....................     } 
.................... } 
....................  
.................... void Slow_Down_Pattern() { 
....................     if(delay_time_ms >= DELAY_TIME_MS_JUMP){ 
*
094B:  MOVF   3B,F
094C:  BTFSS  03.2
094D:  GOTO   152
094E:  MOVF   3A,W
094F:  SUBLW  31
0950:  BTFSC  03.0
0951:  GOTO   156
....................         delay_time_ms = delay_time_ms - DELAY_TIME_MS_JUMP; 
0952:  MOVLW  32
0953:  SUBWF  3A,F
0954:  MOVLW  00
0955:  SUBWFC 3B,F
....................     } 
.................... } 
....................  
.................... void Toggle_Autochange_Pattern() { 
....................     if (autochange_pattern == 0) { 
*
0965:  MOVF   7B,F
0966:  BTFSS  03.2
0967:  GOTO   213
....................         //blink green twice 
....................         pattern_set = 1; 
0968:  BSF    74.0
....................         continue_pattern_calling = 0; 
0969:  BCF    74.1
....................         //make all green 
....................         MakeAllColor(Color(0, 255, 0)); 
096A:  MOVLB  03
096B:  CLRF   5A
096C:  MOVLW  FF
096D:  MOVWF  5B
096E:  CLRF   5C
096F:  MOVLP  00
0970:  MOVLB  00
0971:  CALL   07C
0972:  MOVLP  08
0973:  MOVF   7A,W
0974:  MOVLB  03
0975:  MOVWF  4D
0976:  MOVF   79,W
0977:  MOVWF  4C
0978:  MOVF   78,W
0979:  MOVWF  4B
097A:  MOVF   77,W
097B:  MOVWF  4A
097C:  MOVF   4D,W
097D:  MOVWF  51
097E:  MOVF   4C,W
097F:  MOVWF  50
0980:  MOVF   4B,W
0981:  MOVWF  4F
0982:  MOVF   4A,W
0983:  MOVWF  4E
0984:  MOVLP  00
0985:  MOVLB  00
0986:  CALL   14B
0987:  MOVLP  08
....................         delay_ms(500); 
0988:  MOVLW  02
0989:  MOVLB  03
098A:  MOVWF  4A
098B:  MOVLW  FA
098C:  MOVWF  4B
098D:  MOVLP  00
098E:  MOVLB  00
098F:  CALL   795
0990:  MOVLP  08
0991:  MOVLB  03
0992:  DECFSZ 4A,F
0993:  GOTO   18B
....................         MakeAllColor(Color(0, 0, 0)); 
0994:  CLRF   5A
0995:  CLRF   5B
0996:  CLRF   5C
0997:  MOVLP  00
0998:  MOVLB  00
0999:  CALL   07C
099A:  MOVLP  08
099B:  MOVF   7A,W
099C:  MOVLB  03
099D:  MOVWF  4D
099E:  MOVF   79,W
099F:  MOVWF  4C
09A0:  MOVF   78,W
09A1:  MOVWF  4B
09A2:  MOVF   77,W
09A3:  MOVWF  4A
09A4:  MOVF   4D,W
09A5:  MOVWF  51
09A6:  MOVF   4C,W
09A7:  MOVWF  50
09A8:  MOVF   4B,W
09A9:  MOVWF  4F
09AA:  MOVF   4A,W
09AB:  MOVWF  4E
09AC:  MOVLP  00
09AD:  MOVLB  00
09AE:  CALL   14B
09AF:  MOVLP  08
....................         delay_ms(500); 
09B0:  MOVLW  02
09B1:  MOVLB  03
09B2:  MOVWF  4A
09B3:  MOVLW  FA
09B4:  MOVWF  4B
09B5:  MOVLP  00
09B6:  MOVLB  00
09B7:  CALL   795
09B8:  MOVLP  08
09B9:  MOVLB  03
09BA:  DECFSZ 4A,F
09BB:  GOTO   1B3
....................         MakeAllColor(Color(0, 255, 0)); 
09BC:  CLRF   5A
09BD:  MOVLW  FF
09BE:  MOVWF  5B
09BF:  CLRF   5C
09C0:  MOVLP  00
09C1:  MOVLB  00
09C2:  CALL   07C
09C3:  MOVLP  08
09C4:  MOVF   7A,W
09C5:  MOVLB  03
09C6:  MOVWF  4D
09C7:  MOVF   79,W
09C8:  MOVWF  4C
09C9:  MOVF   78,W
09CA:  MOVWF  4B
09CB:  MOVF   77,W
09CC:  MOVWF  4A
09CD:  MOVF   4D,W
09CE:  MOVWF  51
09CF:  MOVF   4C,W
09D0:  MOVWF  50
09D1:  MOVF   4B,W
09D2:  MOVWF  4F
09D3:  MOVF   4A,W
09D4:  MOVWF  4E
09D5:  MOVLP  00
09D6:  MOVLB  00
09D7:  CALL   14B
09D8:  MOVLP  08
....................         delay_ms(500); 
09D9:  MOVLW  02
09DA:  MOVLB  03
09DB:  MOVWF  4A
09DC:  MOVLW  FA
09DD:  MOVWF  4B
09DE:  MOVLP  00
09DF:  MOVLB  00
09E0:  CALL   795
09E1:  MOVLP  08
09E2:  MOVLB  03
09E3:  DECFSZ 4A,F
09E4:  GOTO   1DC
....................         MakeAllColor(Color(0, 0, 0)); 
09E5:  CLRF   5A
09E6:  CLRF   5B
09E7:  CLRF   5C
09E8:  MOVLP  00
09E9:  MOVLB  00
09EA:  CALL   07C
09EB:  MOVLP  08
09EC:  MOVF   7A,W
09ED:  MOVLB  03
09EE:  MOVWF  4D
09EF:  MOVF   79,W
09F0:  MOVWF  4C
09F1:  MOVF   78,W
09F2:  MOVWF  4B
09F3:  MOVF   77,W
09F4:  MOVWF  4A
09F5:  MOVF   4D,W
09F6:  MOVWF  51
09F7:  MOVF   4C,W
09F8:  MOVWF  50
09F9:  MOVF   4B,W
09FA:  MOVWF  4F
09FB:  MOVF   4A,W
09FC:  MOVWF  4E
09FD:  MOVLP  00
09FE:  MOVLB  00
09FF:  CALL   14B
0A00:  MOVLP  08
....................         delay_ms(500); 
0A01:  MOVLW  02
0A02:  MOVLB  03
0A03:  MOVWF  4A
0A04:  MOVLW  FA
0A05:  MOVWF  4B
0A06:  MOVLP  00
0A07:  MOVLB  00
0A08:  CALL   795
0A09:  MOVLP  08
0A0A:  MOVLB  03
0A0B:  DECFSZ 4A,F
0A0C:  GOTO   204
....................         autochange_pattern = 1; 
0A0D:  MOVLW  01
0A0E:  MOVWF  7B
....................         pattern_set = 0; 
0A0F:  BCF    74.0
....................         continue_pattern_calling = 1; 
0A10:  BSF    74.1
....................     } else { 
0A11:  GOTO   2BB
0A12:  MOVLB  02
....................         //blink green twice 
....................         pattern_set = 1; 
0A13:  BSF    74.0
....................         continue_pattern_calling = 0; 
0A14:  BCF    74.1
....................         //make all green 
....................         MakeAllColor(Color(255, 0, 0)); 
0A15:  MOVLW  FF
0A16:  MOVLB  03
0A17:  MOVWF  5A
0A18:  CLRF   5B
0A19:  CLRF   5C
0A1A:  MOVLP  00
0A1B:  MOVLB  00
0A1C:  CALL   07C
0A1D:  MOVLP  08
0A1E:  MOVF   7A,W
0A1F:  MOVLB  03
0A20:  MOVWF  4D
0A21:  MOVF   79,W
0A22:  MOVWF  4C
0A23:  MOVF   78,W
0A24:  MOVWF  4B
0A25:  MOVF   77,W
0A26:  MOVWF  4A
0A27:  MOVF   4D,W
0A28:  MOVWF  51
0A29:  MOVF   4C,W
0A2A:  MOVWF  50
0A2B:  MOVF   4B,W
0A2C:  MOVWF  4F
0A2D:  MOVF   4A,W
0A2E:  MOVWF  4E
0A2F:  MOVLP  00
0A30:  MOVLB  00
0A31:  CALL   14B
0A32:  MOVLP  08
....................         delay_ms(500); 
0A33:  MOVLW  02
0A34:  MOVLB  03
0A35:  MOVWF  4A
0A36:  MOVLW  FA
0A37:  MOVWF  4B
0A38:  MOVLP  00
0A39:  MOVLB  00
0A3A:  CALL   795
0A3B:  MOVLP  08
0A3C:  MOVLB  03
0A3D:  DECFSZ 4A,F
0A3E:  GOTO   236
....................         MakeAllColor(Color(0, 0, 0)); 
0A3F:  CLRF   5A
0A40:  CLRF   5B
0A41:  CLRF   5C
0A42:  MOVLP  00
0A43:  MOVLB  00
0A44:  CALL   07C
0A45:  MOVLP  08
0A46:  MOVF   7A,W
0A47:  MOVLB  03
0A48:  MOVWF  4D
0A49:  MOVF   79,W
0A4A:  MOVWF  4C
0A4B:  MOVF   78,W
0A4C:  MOVWF  4B
0A4D:  MOVF   77,W
0A4E:  MOVWF  4A
0A4F:  MOVF   4D,W
0A50:  MOVWF  51
0A51:  MOVF   4C,W
0A52:  MOVWF  50
0A53:  MOVF   4B,W
0A54:  MOVWF  4F
0A55:  MOVF   4A,W
0A56:  MOVWF  4E
0A57:  MOVLP  00
0A58:  MOVLB  00
0A59:  CALL   14B
0A5A:  MOVLP  08
....................         delay_ms(500); 
0A5B:  MOVLW  02
0A5C:  MOVLB  03
0A5D:  MOVWF  4A
0A5E:  MOVLW  FA
0A5F:  MOVWF  4B
0A60:  MOVLP  00
0A61:  MOVLB  00
0A62:  CALL   795
0A63:  MOVLP  08
0A64:  MOVLB  03
0A65:  DECFSZ 4A,F
0A66:  GOTO   25E
....................         MakeAllColor(Color(255, 0, 0)); 
0A67:  MOVLW  FF
0A68:  MOVWF  5A
0A69:  CLRF   5B
0A6A:  CLRF   5C
0A6B:  MOVLP  00
0A6C:  MOVLB  00
0A6D:  CALL   07C
0A6E:  MOVLP  08
0A6F:  MOVF   7A,W
0A70:  MOVLB  03
0A71:  MOVWF  4D
0A72:  MOVF   79,W
0A73:  MOVWF  4C
0A74:  MOVF   78,W
0A75:  MOVWF  4B
0A76:  MOVF   77,W
0A77:  MOVWF  4A
0A78:  MOVF   4D,W
0A79:  MOVWF  51
0A7A:  MOVF   4C,W
0A7B:  MOVWF  50
0A7C:  MOVF   4B,W
0A7D:  MOVWF  4F
0A7E:  MOVF   4A,W
0A7F:  MOVWF  4E
0A80:  MOVLP  00
0A81:  MOVLB  00
0A82:  CALL   14B
0A83:  MOVLP  08
....................         delay_ms(500); 
0A84:  MOVLW  02
0A85:  MOVLB  03
0A86:  MOVWF  4A
0A87:  MOVLW  FA
0A88:  MOVWF  4B
0A89:  MOVLP  00
0A8A:  MOVLB  00
0A8B:  CALL   795
0A8C:  MOVLP  08
0A8D:  MOVLB  03
0A8E:  DECFSZ 4A,F
0A8F:  GOTO   287
....................         MakeAllColor(Color(0, 0, 0)); 
0A90:  CLRF   5A
0A91:  CLRF   5B
0A92:  CLRF   5C
0A93:  MOVLP  00
0A94:  MOVLB  00
0A95:  CALL   07C
0A96:  MOVLP  08
0A97:  MOVF   7A,W
0A98:  MOVLB  03
0A99:  MOVWF  4D
0A9A:  MOVF   79,W
0A9B:  MOVWF  4C
0A9C:  MOVF   78,W
0A9D:  MOVWF  4B
0A9E:  MOVF   77,W
0A9F:  MOVWF  4A
0AA0:  MOVF   4D,W
0AA1:  MOVWF  51
0AA2:  MOVF   4C,W
0AA3:  MOVWF  50
0AA4:  MOVF   4B,W
0AA5:  MOVWF  4F
0AA6:  MOVF   4A,W
0AA7:  MOVWF  4E
0AA8:  MOVLP  00
0AA9:  MOVLB  00
0AAA:  CALL   14B
0AAB:  MOVLP  08
....................         delay_ms(500); 
0AAC:  MOVLW  02
0AAD:  MOVLB  03
0AAE:  MOVWF  4A
0AAF:  MOVLW  FA
0AB0:  MOVWF  4B
0AB1:  MOVLP  00
0AB2:  MOVLB  00
0AB3:  CALL   795
0AB4:  MOVLP  08
0AB5:  MOVLB  03
0AB6:  DECFSZ 4A,F
0AB7:  GOTO   2AF
....................         autochange_pattern = 0; 
0AB8:  CLRF   7B
....................         pattern_set = 0; 
0AB9:  BCF    74.0
....................         continue_pattern_calling = 1; 
0ABA:  BSF    74.1
....................     } 
.................... } 
....................  
.................... #include "Buttons.c" 
.................... //FILE NAME = Buttons.h 
.................... //Functions to deal with buttons being pressed 
....................  
.................... void Power_Button_Function() { 
....................     if (led_power_status == 0) { //turning on 
*
0881:  BTFSC  74.2
0882:  GOTO   094
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Turning on Power to LEDs\n\r"); 
.................... #endif 
....................         OUTPUT_LOW(LED_ON_PIN); 
0883:  MOVLB  01
0884:  BCF    0C.7
0885:  MOVLB  02
0886:  BCF    0C.7
....................         led_power_status = 1; //LED IS ON 
0887:  BSF    74.2
....................         delay_us(100); 
0888:  MOVLW  64
0889:  MOVLB  03
088A:  MOVWF  59
088B:  MOVLP  00
088C:  MOVLB  00
088D:  CALL   0AF
088E:  MOVLP  08
....................         send_frame(); 
088F:  MOVLP  00
0890:  CALL   0C3
0891:  MOVLP  08
....................     } else { //turning off 
0892:  GOTO   0CD
0893:  MOVLB  02
....................         OUTPUT_HIGH(LED_ON_PIN); 
0894:  MOVLB  01
0895:  BCF    0C.7
0896:  MOVLB  02
0897:  BSF    0C.7
....................         led_power_status = 0; //LEDS are off 
0898:  BCF    74.2
....................         disable_interrupts(GLOBAL); 
0899:  BCF    0B.6
089A:  BCF    0B.7
089B:  BTFSC  0B.7
089C:  GOTO   09A
....................         clear_interrupt(INT_IOC_A0_L2H); 
089D:  MOVLB  07
089E:  BCF    13.0
....................         delay_us(200); 
089F:  MOVLW  C8
08A0:  MOVLB  03
08A1:  MOVWF  59
08A2:  MOVLP  00
08A3:  MOVLB  00
08A4:  CALL   0AF
08A5:  MOVLP  08
....................         enable_interrupts(INT_IOC_A0_L2H); 
08A6:  BSF    0B.3
08A7:  MOVLB  07
08A8:  BSF    11.0
08A9:  BCF    12.0
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Going to Sleep\n\r"); 
.................... #endif 
....................         sleep(); 
08AA:  SLEEP
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Wake Up\n\r"); 
.................... #endif 
....................  
....................         delay_cycles(1); 
08AB:  NOP
....................         disable_interrupts(INT_IOC_A0_L2H); 
08AC:  BCF    11.0
....................         rtos_disable(Button_Checker); 
08AD:  MOVLB  02
08AE:  BSF    4A.7
....................         OUTPUT_LOW(LED_ON_PIN); 
08AF:  MOVLB  01
08B0:  BCF    0C.7
08B1:  MOVLB  02
08B2:  BCF    0C.7
....................         led_power_status = 1; //LED IS ON 
08B3:  BSF    74.2
....................         delay_ms(50); 
08B4:  MOVLW  32
08B5:  MOVLB  03
08B6:  MOVWF  4B
08B7:  MOVLP  00
08B8:  MOVLB  00
08B9:  CALL   795
08BA:  MOVLP  08
....................         send_frame(); 
08BB:  MOVLP  00
08BC:  CALL   0C3
08BD:  MOVLP  08
....................         delay_ms(300); 
08BE:  MOVLW  02
08BF:  MOVLB  03
08C0:  MOVWF  4A
08C1:  MOVLW  96
08C2:  MOVWF  4B
08C3:  MOVLP  00
08C4:  MOVLB  00
08C5:  CALL   795
08C6:  MOVLP  08
08C7:  MOVLB  03
08C8:  DECFSZ 4A,F
08C9:  GOTO   0C1
....................         rtos_enable(Button_Checker); 
08CA:  MOVLB  02
08CB:  BCF    4A.7
08CC:  MOVLB  00
....................     } 
.................... } 
....................  
.................... void Up_Button_Function() { 
....................     Next_Pattern(); 
.................... } 
....................  
.................... void Down_Button_Function() { 
....................     Previous_Pattern(); 
.................... } 
....................  
.................... void Left_Button_Function() { 
....................     Speed_Up_Pattern(); 
.................... } 
....................  
.................... void Right_Button_Function() { 
....................     Slow_Down_Pattern(); 
.................... } 
....................  
.................... void Center_Button_Function() { 
....................     Toggle_Autochange_Pattern(); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include "RTOS_Functions.c" 
.................... //FILE NAME = LED_Patterns.h 
.................... // A Collection of functions to be called by the RTOS 
....................  
.................... void Pattern_Selector() { 
....................     switch (autochange_pattern) { 
*
0043:  MOVF   7B,W
0044:  XORLW  00
0045:  BTFSC  03.2
0046:  GOTO   04B
0047:  XORLW  01
0048:  BTFSC  03.2
0049:  GOTO   04E
004A:  GOTO   052
....................         case 0: 
....................             rtos_disable(Pattern_Selector); 
004B:  MOVLB  02
004C:  BSF    3C.7
....................             break; 
004D:  GOTO   053
....................         case 1: 
....................             rtos_enable(Pattern_Selector); 
004E:  MOVLB  02
004F:  BCF    3C.7
....................             break; 
0050:  GOTO   053
0051:  MOVLB  00
....................         default: 
....................             break; 
0052:  MOVLB  02
....................     } 
....................     if (autochange_pattern) { 
0053:  MOVF   7B,F
0054:  BTFSC  03.2
0055:  GOTO   074
....................         if ((current_pattern + 1) == NUM_PATTERNS) { 
0056:  MOVLW  01
0057:  MOVLB  00
0058:  ADDWF  26,W
0059:  MOVLB  03
005A:  MOVWF  4A
005B:  MOVLW  00
005C:  MOVLB  00
005D:  ADDWFC 27,W
005E:  MOVLB  03
005F:  MOVWF  4B
0060:  MOVF   4A,W
0061:  SUBLW  0C
0062:  BTFSS  03.2
0063:  GOTO   06D
0064:  MOVF   4B,F
0065:  BTFSS  03.2
0066:  GOTO   06D
....................             current_pattern = 0; 
0067:  MOVLB  00
0068:  CLRF   27
0069:  CLRF   26
....................             Clear_Pattern_Positions(); 
006A:  CALL   031
....................         } else { 
006B:  GOTO   072
006C:  MOVLB  03
....................             current_pattern++; 
006D:  MOVLB  00
006E:  INCF   26,F
006F:  BTFSC  03.2
0070:  INCF   27,F
....................             Clear_Pattern_Positions(); 
0071:  CALL   031
....................         } 
....................         pattern_set = 0; 
0072:  BCF    74.0
0073:  MOVLB  02
....................         //rtos_disable(Pattern_Selector); 
....................     } 
0074:  MOVLW  43
0075:  MOVWF  41
0076:  MOVLW  00
0077:  MOVWF  42
0078:  MOVLP  08
0079:  MOVLB  00
007A:  GOTO   38E
007B:  RETURN
.................... } 
....................  
.................... void Update_Pattern() { 
.................... #ifdef DEBUG_SERIAL 
....................     if (pattern_set == 0) { 
....................         printf("Changing Pattern to %Lu\n\r", current_pattern); 
....................     } 
.................... #endif 
....................  
....................     switch (autochange_pattern) { 
*
0374:  MOVF   7B,W
0375:  XORLW  00
0376:  BTFSC  03.2
0377:  GOTO   37C
0378:  XORLW  01
0379:  BTFSC  03.2
037A:  GOTO   37F
037B:  GOTO   383
....................         case 0: 
....................             rtos_disable(Pattern_Selector); 
037C:  MOVLB  02
037D:  BSF    3C.7
....................             break; 
037E:  GOTO   384
....................         case 1: 
....................             rtos_enable(Pattern_Selector); 
037F:  MOVLB  02
0380:  BCF    3C.7
....................             break; 
0381:  GOTO   384
0382:  MOVLB  00
....................         default: 
....................             break; 
0383:  MOVLB  02
....................     } 
....................      
....................     if (pattern_set == 0 || continue_pattern_calling == 1) { 
0384:  BTFSS  74.0
0385:  GOTO   388
0386:  BTFSS  74.1
0387:  GOTO   78D
....................         switch (current_pattern) { 
0388:  MOVLB  00
0389:  MOVF   26,W
038A:  MOVWF  77
038B:  MOVF   27,W
038C:  MOVWF  7A
038D:  MOVF   7A,W
038E:  BTFSS  03.2
038F:  GOTO   393
0390:  MOVF   77,F
0391:  BTFSC  03.2
0392:  GOTO   3E1
0393:  MOVF   7A,W
0394:  BTFSS  03.2
0395:  GOTO   39A
0396:  MOVLW  01
0397:  SUBWF  77,W
0398:  BTFSC  03.2
0399:  GOTO   3FE
039A:  MOVF   7A,W
039B:  BTFSS  03.2
039C:  GOTO   3A1
039D:  MOVLW  02
039E:  SUBWF  77,W
039F:  BTFSC  03.2
03A0:  GOTO   41B
03A1:  MOVF   7A,W
03A2:  BTFSS  03.2
03A3:  GOTO   3A8
03A4:  MOVLW  03
03A5:  SUBWF  77,W
03A6:  BTFSC  03.2
03A7:  GOTO   438
03A8:  MOVF   7A,W
03A9:  BTFSS  03.2
03AA:  GOTO   3AF
03AB:  MOVLW  04
03AC:  SUBWF  77,W
03AD:  BTFSC  03.2
03AE:  GOTO   480
03AF:  MOVF   7A,W
03B0:  BTFSS  03.2
03B1:  GOTO   3B6
03B2:  MOVLW  05
03B3:  SUBWF  77,W
03B4:  BTFSC  03.2
03B5:  GOTO   517
03B6:  MOVF   7A,W
03B7:  BTFSS  03.2
03B8:  GOTO   3BD
03B9:  MOVLW  06
03BA:  SUBWF  77,W
03BB:  BTFSC  03.2
03BC:  GOTO   568
03BD:  MOVF   7A,W
03BE:  BTFSS  03.2
03BF:  GOTO   3C4
03C0:  MOVLW  07
03C1:  SUBWF  77,W
03C2:  BTFSC  03.2
03C3:  GOTO   61D
03C4:  MOVF   7A,W
03C5:  BTFSS  03.2
03C6:  GOTO   3CB
03C7:  MOVLW  08
03C8:  SUBWF  77,W
03C9:  BTFSC  03.2
03CA:  GOTO   63A
03CB:  MOVF   7A,W
03CC:  BTFSS  03.2
03CD:  GOTO   3D2
03CE:  MOVLW  09
03CF:  SUBWF  77,W
03D0:  BTFSC  03.2
03D1:  GOTO   657
03D2:  MOVF   7A,W
03D3:  BTFSS  03.2
03D4:  GOTO   3D9
03D5:  MOVLW  0A
03D6:  SUBWF  77,W
03D7:  BTFSC  03.2
03D8:  GOTO   687
03D9:  MOVF   7A,W
03DA:  BTFSS  03.2
03DB:  GOTO   3E0
03DC:  MOVLW  0B
03DD:  SUBWF  77,W
03DE:  BTFSC  03.2
03DF:  GOTO   705
03E0:  GOTO   78C
....................             case 0: // All Red 
....................                 MakeAllRed(); 
....................                 pattern_set = 1; 
*
03FB:  BSF    74.0
....................                 continue_pattern_calling = 0; 
03FC:  BCF    74.1
....................                 break; 
03FD:  GOTO   78C
....................             case 1: //All Green 
....................                 MakeAllGreen(); 
....................                 pattern_set = 1; 
*
0418:  BSF    74.0
....................                 continue_pattern_calling = 0; 
0419:  BCF    74.1
....................                 break; 
041A:  GOTO   78C
....................             case 2: //All Blue 
....................                 MakeAllBlue(); 
....................                 pattern_set = 1; 
*
0435:  BSF    74.0
....................                 continue_pattern_calling = 0; 
0436:  BCF    74.1
....................                 break; 
0437:  GOTO   78C
....................             case 3: //Slow Rainbow Fade on all Leds 
....................                 continue_pattern_calling = 1; 
0438:  BSF    74.1
....................                 All_Rainbow_Fade_200ms(); 
....................                 pattern_set = 1; 
*
047D:  BSF    74.0
....................                 break; 
047E:  MOVLB  00
047F:  GOTO   78C
....................             case 4: 
....................                 continue_pattern_calling = 1; 
0480:  BSF    74.1
....................                 Dot_Rainbow_Fade(); 
....................                 pattern_set = 1; 
*
0514:  BSF    74.0
....................                 break; 
0515:  MOVLB  00
0516:  GOTO   78C
....................             case 5: 
....................                 continue_pattern_calling = 1; 
0517:  BSF    74.1
....................                 All_Rainbow_Fade(); 
....................                 pattern_set = 1; 
*
0565:  BSF    74.0
....................                 break; 
0566:  MOVLB  00
0567:  GOTO   78C
....................             case 6: 
....................                 continue_pattern_calling = 1; 
0568:  BSF    74.1
....................                 Random_Chain(); 
....................                 pattern_set = 1; 
*
061A:  BSF    74.0
....................                 break; 
061B:  MOVLB  00
061C:  GOTO   78C
....................             case 7: 
....................                 continue_pattern_calling = 1; 
061D:  BSF    74.1
....................                 ShiftThreeColorThreeBlank(Color(255,0,0)); 
061E:  MOVLW  FF
061F:  MOVLB  03
0620:  MOVWF  5A
0621:  CLRF   5B
0622:  CLRF   5C
0623:  MOVLB  00
0624:  CALL   07C
0625:  MOVF   7A,W
0626:  MOVLB  03
0627:  MOVWF  4D
0628:  MOVF   79,W
0629:  MOVWF  4C
062A:  MOVF   78,W
062B:  MOVWF  4B
062C:  MOVF   77,W
062D:  MOVWF  4A
062E:  MOVF   4D,W
062F:  MOVWF  51
0630:  MOVF   4C,W
0631:  MOVWF  50
0632:  MOVF   4B,W
0633:  MOVWF  4F
0634:  MOVF   4A,W
0635:  MOVWF  4E
0636:  MOVLB  00
0637:  CALL   304
....................                 pattern_set = 1; 
0638:  BSF    74.0
....................                 break; 
0639:  GOTO   78C
....................             case 8: 
....................                 continue_pattern_calling = 1; 
063A:  BSF    74.1
....................                 ShiftThreeColorThreeBlank(Color(0,255,255)); 
063B:  MOVLB  03
063C:  CLRF   5A
063D:  MOVLW  FF
063E:  MOVWF  5B
063F:  MOVWF  5C
0640:  MOVLB  00
0641:  CALL   07C
0642:  MOVF   7A,W
0643:  MOVLB  03
0644:  MOVWF  4D
0645:  MOVF   79,W
0646:  MOVWF  4C
0647:  MOVF   78,W
0648:  MOVWF  4B
0649:  MOVF   77,W
064A:  MOVWF  4A
064B:  MOVF   4D,W
064C:  MOVWF  51
064D:  MOVF   4C,W
064E:  MOVWF  50
064F:  MOVF   4B,W
0650:  MOVWF  4F
0651:  MOVF   4A,W
0652:  MOVWF  4E
0653:  MOVLB  00
0654:  CALL   304
....................                 pattern_set = 1; 
0655:  BSF    74.0
....................                 break; 
0656:  GOTO   78C
....................             case 9: 
....................                 continue_pattern_calling = 1; 
0657:  BSF    74.1
....................                 ShiftThreeColorThreeBlank(Wheel(rand()%767)); 
0658:  CALL   239
0659:  MOVF   79,W
065A:  MOVLB  03
065B:  MOVWF  4B
065C:  MOVF   78,W
065D:  MOVWF  4A
065E:  MOVF   4B,W
065F:  MOVWF  54
0660:  MOVF   4A,W
0661:  MOVWF  53
0662:  MOVLW  02
0663:  MOVWF  56
0664:  MOVLW  FF
0665:  MOVWF  55
0666:  MOVLB  00
0667:  CALL   212
0668:  MOVF   77,W
0669:  MOVLB  03
066A:  MOVWF  4A
066B:  MOVF   7A,W
066C:  MOVWF  4B
066D:  MOVWF  53
066E:  MOVF   4A,W
066F:  MOVWF  52
0670:  MOVLB  00
0671:  CALL   18E
0672:  MOVF   7A,W
0673:  MOVLB  03
0674:  MOVWF  4D
0675:  MOVF   79,W
0676:  MOVWF  4C
0677:  MOVF   78,W
0678:  MOVWF  4B
0679:  MOVF   77,W
067A:  MOVWF  4A
067B:  MOVF   4D,W
067C:  MOVWF  51
067D:  MOVF   4C,W
067E:  MOVWF  50
067F:  MOVF   4B,W
0680:  MOVWF  4F
0681:  MOVF   4A,W
0682:  MOVWF  4E
0683:  MOVLB  00
0684:  CALL   304
....................                 pattern_set = 1; 
0685:  BSF    74.0
....................                 break; 
0686:  GOTO   78C
....................             case 10: 
....................                 continue_pattern_calling = 1; 
0687:  BSF    74.1
....................                 ShiftOneColorOneBlank(Color(0,0,255)); 
0688:  MOVLB  03
0689:  CLRF   5A
068A:  CLRF   5B
068B:  MOVLW  FF
068C:  MOVWF  5C
068D:  MOVLB  00
068E:  CALL   07C
068F:  MOVF   7A,W
0690:  MOVLB  03
0691:  MOVWF  4D
0692:  MOVF   79,W
0693:  MOVWF  4C
0694:  MOVF   78,W
0695:  MOVWF  4B
0696:  MOVF   77,W
0697:  MOVWF  4A
0698:  MOVF   4D,W
0699:  MOVWF  51
069A:  MOVF   4C,W
069B:  MOVWF  50
069C:  MOVF   4B,W
069D:  MOVWF  4F
069E:  MOVF   4A,W
069F:  MOVWF  4E
....................                 pattern_set = 1; 
*
0702:  BSF    74.0
....................                 break; 
0703:  MOVLB  00
0704:  GOTO   78C
....................             case 11: 
....................                 continue_pattern_calling = 1; 
0705:  BSF    74.1
....................                 ShiftOneColorTwoBlank(Color(0,0,255)); 
0706:  MOVLB  03
0707:  CLRF   5A
0708:  CLRF   5B
0709:  MOVLW  FF
070A:  MOVWF  5C
070B:  MOVLB  00
070C:  CALL   07C
070D:  MOVF   7A,W
070E:  MOVLB  03
070F:  MOVWF  4D
0710:  MOVF   79,W
0711:  MOVWF  4C
0712:  MOVF   78,W
0713:  MOVWF  4B
0714:  MOVF   77,W
0715:  MOVWF  4A
0716:  MOVF   4D,W
0717:  MOVWF  51
0718:  MOVF   4C,W
0719:  MOVWF  50
071A:  MOVF   4B,W
071B:  MOVWF  4F
071C:  MOVF   4A,W
071D:  MOVWF  4E
....................                 pattern_set = 1; 
*
078A:  BSF    74.0
....................                 break; 
078B:  MOVLB  00
078C:  MOVLB  02
....................  
....................         } 
....................     } 
078D:  MOVLW  74
078E:  MOVWF  48
078F:  MOVLW  03
0790:  MOVWF  49
0791:  MOVLP  08
0792:  MOVLB  00
0793:  GOTO   38E
0794:  RETURN
.................... } 
....................  
.................... void Button_Checker() { 
....................     //check if any button is pressed 
....................     if (button_status == 0) { //no buttons have been pressed 
*
0800:  MOVF   75,F
0801:  BTFSS  03.2
0802:  GOTO   02E
....................  
....................         //Power Button 
....................         if (input(POWER_BUTTON_PIN) == 0) { //button is pressed 
0803:  MOVLB  01
0804:  BSF    0C.0
0805:  MOVLB  00
0806:  BTFSC  0C.0
0807:  GOTO   00A
....................             bit_set(button_status, POWER_BUTTON_BIT); 
0808:  BSF    75.0
....................             button_counter = 0; 
0809:  CLRF   76
....................         } 
....................  
....................         //Up Button 
....................         if (input(UP_BUTTON_PIN) == 0) { //button is pressed 
080A:  MOVLB  01
080B:  BSF    0C.1
080C:  MOVLB  00
080D:  BTFSC  0C.1
080E:  GOTO   011
....................             bit_set(button_status, UP_BUTTON_BIT); 
080F:  BSF    75.1
....................             button_counter = 0; 
0810:  CLRF   76
....................         } 
....................  
....................         //Down Button 
....................         if (input(DOWN_BUTTON_PIN) == 0) { //button is pressed 
0811:  MOVLB  01
0812:  BSF    0C.2
0813:  MOVLB  00
0814:  BTFSC  0C.2
0815:  GOTO   018
....................             bit_set(button_status, DOWN_BUTTON_BIT); 
0816:  BSF    75.2
....................             button_counter = 0; 
0817:  CLRF   76
....................         } 
....................  
....................         //Left Button 
....................         if (input(LEFT_BUTTON_PIN) == 0) { //button is pressed 
0818:  MOVLB  01
0819:  BSF    0C.3
081A:  MOVLB  00
081B:  BTFSC  0C.3
081C:  GOTO   01F
....................             bit_set(button_status, LEFT_BUTTON_BIT); 
081D:  BSF    75.3
....................             button_counter = 0; 
081E:  CLRF   76
....................         }       
....................          
....................         //Right Button 
....................         if (input(RIGHT_BUTTON_PIN) == 0) { //button is pressed 
081F:  MOVLB  01
0820:  BSF    0C.4
0821:  MOVLB  00
0822:  BTFSC  0C.4
0823:  GOTO   026
....................             bit_set(button_status, RIGHT_BUTTON_BIT); 
0824:  BSF    75.4
....................             button_counter = 0; 
0825:  CLRF   76
....................         } 
....................  
....................         //Center Button 
....................         if (input(CENTER_BUTTON_PIN) == 0) { //button is pressed 
0826:  MOVLB  01
0827:  BSF    0C.5
0828:  MOVLB  00
0829:  BTFSC  0C.5
082A:  GOTO   02D
....................             bit_set(button_status, CENTER_BUTTON_BIT); 
082B:  BSF    75.5
....................             button_counter = 0; 
082C:  CLRF   76
....................         } 
....................  
....................  
....................  
....................     } else { //a button has been pressed, lets see if it's still pressed 
082D:  GOTO   070
....................  
....................         //Power Button 
....................         if (bit_test(button_status, POWER_BUTTON_BIT)) { 
082E:  BTFSS  75.0
082F:  GOTO   039
....................             if (input(POWER_BUTTON_PIN) == 0) { 
0830:  MOVLB  01
0831:  BSF    0C.0
0832:  MOVLB  00
0833:  BTFSC  0C.0
0834:  GOTO   037
....................                 button_counter++; 
0835:  INCF   76,F
....................             } else { 
0836:  GOTO   039
....................                 button_counter = 0; 
0837:  CLRF   76
....................                 bit_clear(button_status, POWER_BUTTON_BIT); 
0838:  BCF    75.0
....................             } 
....................         } 
....................  
....................         //Up Button 
....................         if (bit_test(button_status, UP_BUTTON_BIT)) { 
0839:  BTFSS  75.1
083A:  GOTO   044
....................             if (input(UP_BUTTON_PIN) == 0) { 
083B:  MOVLB  01
083C:  BSF    0C.1
083D:  MOVLB  00
083E:  BTFSC  0C.1
083F:  GOTO   042
....................                 button_counter++; 
0840:  INCF   76,F
....................             } else { 
0841:  GOTO   044
....................                 button_counter = 0; 
0842:  CLRF   76
....................                 bit_clear(button_status, UP_BUTTON_BIT); 
0843:  BCF    75.1
....................             } 
....................         } 
....................  
....................         //Down Button 
....................         if (bit_test(button_status, DOWN_BUTTON_BIT)) { 
0844:  BTFSS  75.2
0845:  GOTO   04F
....................             if (input(DOWN_BUTTON_PIN) == 0) { 
0846:  MOVLB  01
0847:  BSF    0C.2
0848:  MOVLB  00
0849:  BTFSC  0C.2
084A:  GOTO   04D
....................                 button_counter++; 
084B:  INCF   76,F
....................             } else { 
084C:  GOTO   04F
....................                 button_counter = 0; 
084D:  CLRF   76
....................                 bit_clear(button_status, DOWN_BUTTON_BIT); 
084E:  BCF    75.2
....................             } 
....................         } 
....................  
....................         //Left Button 
....................         if (bit_test(button_status, LEFT_BUTTON_BIT)) { 
084F:  BTFSS  75.3
0850:  GOTO   05A
....................             if (input(LEFT_BUTTON_PIN) == 0) { 
0851:  MOVLB  01
0852:  BSF    0C.3
0853:  MOVLB  00
0854:  BTFSC  0C.3
0855:  GOTO   058
....................                 button_counter++; 
0856:  INCF   76,F
....................             } else { 
0857:  GOTO   05A
....................                 button_counter = 0; 
0858:  CLRF   76
....................                 bit_clear(button_status, LEFT_BUTTON_BIT); 
0859:  BCF    75.3
....................             } 
....................         } 
....................  
....................         //Right Button 
....................         if (bit_test(button_status, RIGHT_BUTTON_BIT)) { 
085A:  BTFSS  75.4
085B:  GOTO   065
....................             if (input(RIGHT_BUTTON_PIN) == 0) { 
085C:  MOVLB  01
085D:  BSF    0C.4
085E:  MOVLB  00
085F:  BTFSC  0C.4
0860:  GOTO   063
....................                 button_counter++; 
0861:  INCF   76,F
....................             } else { 
0862:  GOTO   065
....................                 button_counter = 0; 
0863:  CLRF   76
....................                 bit_clear(button_status, RIGHT_BUTTON_BIT); 
0864:  BCF    75.4
....................             } 
....................         } 
....................  
....................         //Center Button 
....................         if (bit_test(button_status, CENTER_BUTTON_BIT)) { 
0865:  BTFSS  75.5
0866:  GOTO   070
....................             if (input(CENTER_BUTTON_PIN) == 0) { 
0867:  MOVLB  01
0868:  BSF    0C.5
0869:  MOVLB  00
086A:  BTFSC  0C.5
086B:  GOTO   06E
....................                 button_counter++; 
086C:  INCF   76,F
....................             } else { 
086D:  GOTO   070
....................                 button_counter = 0; 
086E:  CLRF   76
....................                 bit_clear(button_status, CENTER_BUTTON_BIT); 
086F:  BCF    75.5
....................             } 
....................         } 
....................  
....................     } 
....................  
....................     if (button_counter > 5) { 
0870:  MOVF   76,W
0871:  SUBLW  05
0872:  BTFSC  03.0
0873:  GOTO   2BD
....................  
....................         //Power Button 
....................         if (bit_test(button_status, POWER_BUTTON_BIT)) { 
0874:  BTFSS  75.0
0875:  GOTO   0CE
....................             while (input(POWER_BUTTON_PIN) == 0) { //wait untill the button is released 
0876:  MOVLB  01
0877:  BSF    0C.0
0878:  MOVLB  00
0879:  BTFSC  0C.0
087A:  GOTO   07F
....................                 rtos_disable(Button_Checker); 
087B:  MOVLB  02
087C:  BSF    4A.7
087D:  MOVLB  00
087E:  GOTO   076
....................             } 
....................             rtos_enable(Button_Checker); 
087F:  MOVLB  02
0880:  BCF    4A.7
....................             Power_Button_Function(); 
....................             button_status = 0; 
*
08CD:  CLRF   75
....................         } 
....................  
....................         //Up Button 
....................         if (bit_test(button_status, UP_BUTTON_BIT)) { 
08CE:  BTFSS  75.1
08CF:  GOTO   0FD
....................             while (input(UP_BUTTON_PIN) == 0) { //wait untill the button is released 
08D0:  MOVLB  01
08D1:  BSF    0C.1
08D2:  MOVLB  00
08D3:  BTFSC  0C.1
08D4:  GOTO   0D9
....................                 rtos_disable(Button_Checker); 
08D5:  MOVLB  02
08D6:  BSF    4A.7
08D7:  MOVLB  00
08D8:  GOTO   0D0
....................             } 
....................             rtos_enable(Button_Checker); 
08D9:  MOVLB  02
08DA:  BCF    4A.7
....................             Up_Button_Function(); 
....................             button_status = 0; 
*
08FC:  CLRF   75
....................         } 
....................  
....................         //Down Button 
....................         if (bit_test(button_status, DOWN_BUTTON_BIT)) { 
08FD:  BTFSS  75.2
08FE:  GOTO   121
....................             while (input(DOWN_BUTTON_PIN) == 0) { //wait untill the button is released 
08FF:  MOVLB  01
0900:  BSF    0C.2
0901:  MOVLB  00
0902:  BTFSC  0C.2
0903:  GOTO   108
....................                 rtos_disable(Button_Checker); 
0904:  MOVLB  02
0905:  BSF    4A.7
0906:  MOVLB  00
0907:  GOTO   0FF
....................             } 
....................             rtos_enable(Button_Checker); 
0908:  MOVLB  02
0909:  BCF    4A.7
....................             Down_Button_Function(); 
....................             button_status = 0; 
*
0920:  CLRF   75
....................         } 
....................  
....................         //Left Button 
....................         if (bit_test(button_status, LEFT_BUTTON_BIT)) { 
0921:  BTFSS  75.3
0922:  GOTO   13E
....................             while (input(LEFT_BUTTON_PIN) == 0) { //wait untill the button is released 
0923:  MOVLB  01
0924:  BSF    0C.3
0925:  MOVLB  00
0926:  BTFSC  0C.3
0927:  GOTO   12C
....................                 rtos_disable(Button_Checker); 
0928:  MOVLB  02
0929:  BSF    4A.7
092A:  MOVLB  00
092B:  GOTO   123
....................             } 
....................             rtos_enable(Button_Checker); 
092C:  MOVLB  02
092D:  BCF    4A.7
....................             Left_Button_Function(); 
....................             button_status = 0; 
*
093C:  CLRF   75
093D:  MOVLB  00
....................         } 
....................  
....................         //Right Button 
....................         if (bit_test(button_status, RIGHT_BUTTON_BIT)) { 
093E:  BTFSS  75.4
093F:  GOTO   158
....................             while (input(RIGHT_BUTTON_PIN) == 0) { //wait untill the button is released 
0940:  MOVLB  01
0941:  BSF    0C.4
0942:  MOVLB  00
0943:  BTFSC  0C.4
0944:  GOTO   149
....................                 rtos_disable(Button_Checker); 
0945:  MOVLB  02
0946:  BSF    4A.7
0947:  MOVLB  00
0948:  GOTO   140
....................             } 
....................             rtos_enable(Button_Checker); 
0949:  MOVLB  02
094A:  BCF    4A.7
....................             Right_Button_Function(); 
....................             button_status = 0; 
*
0956:  CLRF   75
0957:  MOVLB  00
....................         } 
....................  
....................         //Center Button 
....................         if (bit_test(button_status, CENTER_BUTTON_BIT)) { 
0958:  BTFSS  75.5
0959:  GOTO   2BD
....................             while (input(CENTER_BUTTON_PIN) == 0) { //wait untill the button is released 
095A:  MOVLB  01
095B:  BSF    0C.5
095C:  MOVLB  00
095D:  BTFSC  0C.5
095E:  GOTO   163
....................                 rtos_disable(Button_Checker); 
095F:  MOVLB  02
0960:  BSF    4A.7
0961:  MOVLB  00
0962:  GOTO   15A
....................             } 
....................             rtos_enable(Button_Checker); 
0963:  MOVLB  02
0964:  BCF    4A.7
....................             Center_Button_Function(); 
....................             button_status = 0; 
*
0ABB:  CLRF   75
0ABC:  MOVLB  00
....................         } 
....................  
....................     } 
0ABD:  MOVLW  00
0ABE:  MOVLB  02
0ABF:  MOVWF  4F
0AC0:  MOVLW  08
0AC1:  MOVWF  50
0AC2:  MOVLP  08
0AC3:  MOVLB  00
0AC4:  GOTO   38E
0AC5:  RETURN
.................... } 
....................  
....................  
.................... /*MAIN FUNCTION*/ 
.................... void main(int argc, char** argv) { 
0AC6:  MOVLW  F0
0AC7:  MOVLB  01
0AC8:  MOVWF  19
0AC9:  MOVLB  03
0ACA:  BSF    1F.3
0ACB:  BSF    1F.4
0ACC:  MOVLW  8A
0ACD:  MOVWF  1B
0ACE:  MOVLW  00
0ACF:  MOVWF  1C
0AD0:  MOVLW  A6
0AD1:  MOVWF  1E
0AD2:  MOVLW  90
0AD3:  MOVWF  1D
0AD4:  CLRF   0C
0AD5:  CLRF   0D
0AD6:  CLRF   0E
0AD7:  MOVLB  02
0AD8:  CLRF   12
0AD9:  CLRF   11
0ADA:  MOVLB  00
0ADB:  CLRF   20
0ADC:  CLRF   21
....................     //setup the IC 
....................     setup_oscillator(OSC_8MHZ | OSC_PLL_ON); //32MHZ 
0ADD:  MOVLW  F0
0ADE:  MOVLB  01
0ADF:  MOVWF  19
....................     //set_tris_a(0b01111111); 
....................     //set_tris_b(0b00000000); 
....................     PORT_A_PULLUPS(0b01111111); 
0AE0:  MOVLW  7F
0AE1:  MOVLB  04
0AE2:  MOVWF  0C
0AE3:  MOVLB  01
0AE4:  BCF    15.7
....................     PORT_B_PULLUPS(0b00000000); 
0AE5:  MOVLB  04
0AE6:  CLRF   0D
....................  
.................... #ifdef BOARD_V1_1 
....................     #ifdef WS2801 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_DO_B5 | SPI_SCK_B7 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
0AE7:  MOVLB  02
0AE8:  BCF    1D.3
0AE9:  BSF    1D.4
0AEA:  BSF    1D.5
0AEB:  BCF    1C.1
0AEC:  BCF    1C.2
0AED:  MOVLB  04
0AEE:  BCF    15.5
0AEF:  MOVLB  01
0AF0:  BCF    0D.5
0AF1:  BSF    0E.4
0AF2:  BCF    0D.7
0AF3:  MOVLW  20
0AF4:  MOVLB  04
0AF5:  MOVWF  15
0AF6:  MOVLW  40
0AF7:  MOVWF  14
....................     #endif 
....................     #ifdef WS2811 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_16 | SPI_DO_B5 | SPI_SCK_B7 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
....................     #endif 
.................... #endif 
....................  
.................... #ifdef BOARD_V1_2 
....................     #ifdef WS2801 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_DO_C5 | SPI_SCK_C3 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
....................     #endif 
....................     #ifdef WS2811 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_16 | SPI_DO_C5 | SPI_SCK_C3 | SPI_L_TO_H); 
....................     #endif 
.................... #endif 
....................  
....................     //turn on the leds 
....................     OUTPUT_LOW(LED_ON_PIN); 
0AF8:  MOVLB  01
0AF9:  BCF    0C.7
0AFA:  MOVLB  02
0AFB:  BCF    0C.7
....................     led_power_status = 1; //LED IS ON 
0AFC:  BSF    74.2
....................      
....................     //clear the led_strup_colors variable 
....................     setup(); 
0AFD:  MOVLP  00
0AFE:  MOVLB  00
0AFF:  GOTO   7AA
0B00:  MOVLP  08
....................     send_frame(); 
0B01:  MOVLP  00
0B02:  CALL   0C3
0B03:  MOVLP  08
....................     delay_ms(100); 
0B04:  MOVLW  64
0B05:  MOVLB  03
0B06:  MOVWF  4B
0B07:  MOVLP  00
0B08:  MOVLB  00
0B09:  CALL   795
0B0A:  MOVLP  08
....................  
....................     //setup global variables 
....................     autochange_pattern = 0; 
0B0B:  CLRF   7B
....................     current_pattern = 4; 
0B0C:  CLRF   27
0B0D:  MOVLW  04
0B0E:  MOVWF  26
....................     button_status = 0; 
0B0F:  CLRF   75
....................     timer_flags_counter = 0; 
0B10:  MOVLB  02
0B11:  CLRF   39
0B12:  CLRF   38
....................     pattern_set = 0; 
0B13:  BCF    74.0
....................     continue_pattern_calling = 0; 
0B14:  BCF    74.1
....................     delay_time_ms = 50; 
0B15:  CLRF   3B
0B16:  MOVLW  32
0B17:  MOVWF  3A
....................     Clear_Pattern_Positions(); 
0B18:  MOVLP  00
0B19:  MOVLB  00
0B1A:  CALL   031
0B1B:  MOVLP  08
....................              
....................  
.................... #ifdef DEBUG_SERIAL 
....................     printf("System Started\n\r"); 
.................... #endif 
....................  
.................... /* 
.................... //Test code when checking LED programs 
....................     while (1) { 
....................         //startup test of all colors 
....................         //make all red 
....................         MakeAllColor(Color(255, 0, 0)); 
....................         delay_ms(1000); 
....................         //make all green 
....................         MakeAllColor(Color(0, 255, 0)); 
....................         delay_ms(1000); 
....................         //make all blue 
....................         MakeAllColor(Color(0, 0, 255)); 
....................         delay_ms(1000); 
....................     } 
.................... */ 
....................      
....................     Timer_Clear_All_Timer(); 
0B1C:  MOVLP  00
0B1D:  GOTO   7C9
0B1E:  MOVLP  08
....................              
.................... #ifdef DEBUG_SERIAL 
....................     printf("Starting RTOS\n\r"); 
.................... #endif 
....................      
....................     rtos_run(); 
0B1F:  MOVLB  02
0B20:  CLRF   3C
0B21:  MOVLW  75
0B22:  MOVWF  3E
0B23:  MOVLW  30
0B24:  MOVWF  3D
0B25:  CLRF   40
0B26:  MOVLW  02
0B27:  MOVWF  3F
0B28:  MOVLW  43
0B29:  MOVWF  41
0B2A:  MOVLW  00
0B2B:  MOVWF  42
0B2C:  CLRF   43
0B2D:  CLRF   45
0B2E:  MOVLW  0A
0B2F:  MOVWF  44
0B30:  CLRF   47
0B31:  CLRF   46
0B32:  MOVLW  74
0B33:  MOVWF  48
0B34:  MOVLW  03
0B35:  MOVWF  49
0B36:  CLRF   4A
0B37:  CLRF   4C
0B38:  MOVLW  0A
0B39:  MOVWF  4B
0B3A:  CLRF   4E
0B3B:  MOVLW  01
0B3C:  MOVWF  4D
0B3D:  MOVLW  00
0B3E:  MOVWF  4F
0B3F:  MOVLW  08
0B40:  MOVWF  50
0B41:  CLRF   51
0B42:  CLRF   53
0B43:  MOVLW  01
0B44:  MOVWF  52
0B45:  CLRF   55
0B46:  CLRF   54
0B47:  MOVLW  0C
0B48:  MOVWF  56
0B49:  MOVLW  00
0B4A:  MOVWF  57
0B4B:  CLRF   7C
0B4C:  MOVLW  05
0B4D:  MOVLB  00
0B4E:  MOVWF  18
0B4F:  CLRF   19
0B50:  CLRF   16
0B51:  MOVLW  E0
0B52:  MOVWF  17
0B53:  MOVLW  C0
0B54:  MOVWF  16
0B55:  BCF    11.0
0B56:  BCF    03.0
0B57:  RLF    7C,W
0B58:  MOVWF  77
0B59:  MOVLP  00
0B5A:  CALL   003
0B5B:  MOVLP  08
0B5C:  MOVWF  79
0B5D:  MOVLW  01
0B5E:  ADDWF  77,W
0B5F:  MOVLP  00
0B60:  CALL   003
0B61:  MOVLP  08
0B62:  MOVWF  7A
0B63:  MOVF   7A,W
0B64:  MOVWF  05
0B65:  MOVF   79,W
0B66:  MOVWF  04
0B67:  MOVF   00,W
0B68:  MOVWF  79
0B69:  INCF   04,F
0B6A:  MOVF   00,W
0B6B:  MOVWF  77
0B6C:  INCF   04,F
0B6D:  MOVF   00,W
0B6E:  MOVWF  78
0B6F:  INCF   04,F
0B70:  INCF   00,F
0B71:  MOVF   00,W
0B72:  MOVWF  7A
0B73:  BTFSS  03.2
0B74:  GOTO   378
0B75:  INCF   04,F
0B76:  INCF   00,F
0B77:  DECF   04,F
0B78:  INCF   04,F
0B79:  MOVF   00,W
0B7A:  SUBWF  78,W
0B7B:  BTFSS  03.2
0B7C:  GOTO   38F
0B7D:  MOVF   77,W
0B7E:  SUBWF  7A,W
0B7F:  BTFSS  03.2
0B80:  GOTO   38F
0B81:  DECF   04,F
0B82:  CLRF   00
0B83:  INCF   04,F
0B84:  CLRF   00
0B85:  INCF   04,F
0B86:  BTFSC  79.7
0B87:  GOTO   38F
0B88:  ADDFSR 01,FSR0
0B89:  MOVF   00,W
0B8A:  MOVWF  0A
0B8B:  ADDFSR 3F,FSR0
0B8C:  MOVF   00,W
0B8D:  MOVWF  02
0B8E:  MOVLB  00
0B8F:  INCF   7C,F
0B90:  MOVLW  04
0B91:  SUBWF  7C,W
0B92:  BTFSS  03.2
0B93:  GOTO   356
0B94:  CLRF   7C
0B95:  BTFSC  11.0
0B96:  GOTO   350
0B97:  GOTO   395
0B98:  MOVLW  FF
0B99:  MOVWF  7C
.................... } 
0B9A:  SLEEP

Configuration Fuses:
   Word  1: 3984   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NOLPBOR NODEBUG NOLVP

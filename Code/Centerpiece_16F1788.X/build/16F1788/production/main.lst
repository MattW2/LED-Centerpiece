CCS PCM C Compiler, Version 5.008, 5967               22-Aug-15 22:55

               Filename:   C:\Users\Matt\Documents\Projects\Wedding\LED Centerpiece\Code\Centerpiece_16F1788.X\build\16F1788\production\main.lst

               ROM used:   5370 words (33%)
                           Largest free fragment is 2048
               RAM used:   887 (43%) at main() level
                           995 (49%) worst case
               Stack used: 8 locations (3 in main + 5 for interrupts)
               Stack size: 16

*
0000:  MOVLP  10
0001:  GOTO   35F
0002:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: Matt Wasserman 
....................  * Control Wedding LED Centerpieces 
....................  * 
....................  * Created on September 1, 2014, 5:54 PM 
....................  */ 
....................  
.................... #include <16F1788.h> 
.................... //////// Standard Header file for the PIC16F1788 device //////////////// 
.................... #device PIC16F1788 
0003:  BRW
0004:  RETLW  4C
0005:  RETLW  23
0006:  RETLW  53
0007:  RETLW  23
0008:  RETLW  5A
0009:  RETLW  23
000A:  RETLW  61
000B:  RETLW  23
*
0031:  DATA D4,34
0032:  DATA ED,32
0033:  DATA 72,10
0034:  DATA A5,34
0035:  DATA A0,1E
0036:  DATA A0,12
0037:  DATA CC,3A
0038:  DATA 8A,06
0039:  DATA 00,00
003A:  DATA D0,30
003B:  DATA 74,3A
003C:  DATA 65,39
003D:  DATA 6E,10
003E:  DATA D0,37
003F:  DATA F3,34
0040:  DATA F4,34
0041:  DATA 6F,37
0042:  DATA A0,1E
0043:  DATA A0,12
0044:  DATA CC,3A
0045:  DATA 8A,06
0046:  DATA 00,00
0047:  DATA D0,30
0048:  DATA 74,3A
0049:  DATA 65,39
004A:  DATA 6E,10
004B:  DATA D0,37
004C:  DATA F3,34
004D:  DATA F4,34
004E:  DATA 6F,37
004F:  DATA A0,1E
0050:  DATA A0,12
0051:  DATA CC,3A
0052:  DATA 8A,06
0053:  DATA 00,00
0054:  DATA D0,30
0055:  DATA 74,3A
0056:  DATA 65,39
0057:  DATA 6E,10
0058:  DATA D0,37
0059:  DATA F3,34
005A:  DATA F4,34
005B:  DATA 6F,37
005C:  DATA A0,1E
005D:  DATA A0,12
005E:  DATA CC,3A
005F:  DATA 8A,06
0060:  DATA 00,00
0061:  DATA D0,30
0062:  DATA 74,3A
0063:  DATA 65,39
0064:  DATA 6E,10
0065:  DATA D0,37
0066:  DATA F3,34
0067:  DATA F4,34
0068:  DATA 6F,37
0069:  DATA 20,18
006A:  DATA AC,18
006B:  DATA 20,10
006C:  DATA 3D,10
006D:  DATA 25,26
006E:  DATA 75,16
006F:  DATA 25,36
0070:  DATA 75,05
0071:  DATA 0D,00
0072:  DATA C4,32
0073:  DATA EC,30
0074:  DATA 79,10
0075:  DATA D4,34
0076:  DATA ED,32
0077:  DATA A0,36
0078:  DATA 73,10
0079:  DATA 3D,10
007A:  DATA 25,36
007B:  DATA 75,05
007C:  DATA 0D,00
007D:  DATA C4,32
007E:  DATA EC,30
007F:  DATA 79,10
0080:  DATA D4,34
0081:  DATA ED,32
0082:  DATA A0,36
0083:  DATA 73,10
0084:  DATA 3D,10
0085:  DATA 25,36
0086:  DATA 75,05
0087:  DATA 0D,00
0088:  DATA D4,3A
0089:  DATA 72,37
008A:  DATA 69,37
008B:  DATA 67,10
008C:  DATA 6F,37
008D:  DATA 20,28
008E:  DATA EF,3B
008F:  DATA 65,39
0090:  DATA 20,3A
0091:  DATA 6F,10
0092:  DATA CC,22
0093:  DATA C4,39
0094:  DATA 8A,06
0095:  DATA 00,00
0096:  DATA C7,37
0097:  DATA 69,37
0098:  DATA 67,10
0099:  DATA F4,37
009A:  DATA A0,29
009B:  DATA EC,32
009C:  DATA 65,38
009D:  DATA 8A,06
009E:  DATA 00,01
009F:  DATA D7,30
00A0:  DATA EB,32
00A1:  DATA A0,2A
00A2:  DATA 70,05
00A3:  DATA 0D,00
*
00F2:  MOVF   0B,W
00F3:  MOVLB  0B
00F4:  MOVWF  6C
00F5:  BCF    0B.7
00F6:  MOVLB  03
00F7:  BSF    15.7
00F8:  BSF    15.0
00F9:  NOP
00FA:  NOP
00FB:  BTFSC  03.0
00FC:  GOTO   123
00FD:  MOVF   13,W
00FE:  ANDLW  7F
00FF:  MOVLB  0B
0100:  MOVWF  6D
0101:  MOVLB  03
0102:  MOVF   11,W
0103:  MOVLB  0B
0104:  MOVWF  6E
0105:  MOVLB  03
0106:  MOVF   12,W
0107:  MOVLB  0B
0108:  MOVWF  6F
0109:  MOVF   6D,W
010A:  MOVLB  00
010B:  BTFSS  11.4
010C:  GOTO   10B
010D:  MOVLB  03
010E:  MOVWF  1A
010F:  MOVLB  0B
0110:  MOVF   6E,W
0111:  MOVLB  03
0112:  MOVWF  11
0113:  MOVLB  0B
0114:  MOVF   6F,W
0115:  MOVLB  03
0116:  MOVWF  12
0117:  BSF    15.7
0118:  BSF    15.0
0119:  NOP
011A:  NOP
011B:  MOVLB  0B
011C:  DECFSZ 6B,F
011D:  GOTO   11F
011E:  GOTO   121
011F:  MOVLB  03
0120:  GOTO   123
0121:  GOTO   145
0122:  MOVLB  03
0123:  RLF    13,W
0124:  RLF    14,W
0125:  ANDLW  7F
0126:  MOVLB  0B
0127:  MOVWF  6D
0128:  MOVLB  03
0129:  MOVF   11,W
012A:  MOVLB  0B
012B:  MOVWF  6E
012C:  MOVLB  03
012D:  MOVF   12,W
012E:  MOVLB  0B
012F:  MOVWF  6F
0130:  MOVF   6D,W
0131:  MOVLB  00
0132:  BTFSS  11.4
0133:  GOTO   132
0134:  MOVLB  03
0135:  MOVWF  1A
0136:  MOVLB  0B
0137:  MOVF   6E,W
0138:  MOVLB  03
0139:  MOVWF  11
013A:  MOVLB  0B
013B:  MOVF   6F,W
013C:  MOVLB  03
013D:  MOVWF  12
013E:  INCF   11,F
013F:  BTFSC  03.2
0140:  INCF   12,F
0141:  BCF    03.0
0142:  MOVLB  0B
0143:  DECFSZ 6B,F
0144:  GOTO   0F6
0145:  BTFSC  6C.7
0146:  BSF    0B.7
0147:  MOVLB  00
0148:  RETURN
0149:  MOVF   05,W
014A:  MOVLB  0C
014B:  MOVWF  26
014C:  MOVF   04,W
014D:  MOVWF  25
014E:  MOVLB  0B
014F:  SWAPF  6C,W
0150:  IORLW  F0
0151:  MOVLB  0C
0152:  MOVWF  21
0153:  ADDWF  21,F
0154:  ADDLW  E2
0155:  MOVWF  22
0156:  ADDLW  32
0157:  MOVWF  24
0158:  MOVLB  0B
0159:  MOVF   6C,W
015A:  ANDLW  0F
015B:  MOVLB  0C
015C:  ADDWF  22,F
015D:  ADDWF  22,F
015E:  ADDWF  24,F
015F:  ADDLW  E9
0160:  MOVWF  23
0161:  ADDWF  23,F
0162:  ADDWF  23,F
0163:  MOVLB  0B
0164:  SWAPF  6B,W
0165:  ANDLW  0F
0166:  MOVLB  0C
0167:  ADDWF  23,F
0168:  ADDWF  24,F
0169:  RLF    23,F
016A:  RLF    24,F
016B:  COMF   24,F
016C:  RLF    24,F
016D:  MOVLB  0B
016E:  MOVF   6B,W
016F:  ANDLW  0F
0170:  MOVLB  0C
0171:  ADDWF  24,F
0172:  RLF    21,F
0173:  MOVLW  07
0174:  MOVWF  20
0175:  MOVLW  0A
0176:  ADDWF  24,F
0177:  DECF   23,F
0178:  BTFSS  03.0
0179:  GOTO   176
017A:  ADDWF  23,F
017B:  DECF   22,F
017C:  BTFSS  03.0
017D:  GOTO   17A
017E:  ADDWF  22,F
017F:  DECF   21,F
0180:  BTFSS  03.0
0181:  GOTO   17E
0182:  ADDWF  21,F
0183:  DECF   20,F
0184:  BTFSS  03.0
0185:  GOTO   182
0186:  MOVLW  06
0187:  MOVWF  05
0188:  MOVLW  20
0189:  MOVWF  04
018A:  MOVLW  07
018B:  ANDWF  25,W
018C:  BCF    25.6
018D:  ADDWF  04,F
018E:  MOVLW  24
018F:  SUBWF  04,W
0190:  BTFSC  03.2
0191:  BSF    25.6
0192:  MOVF   00,W
0193:  MOVWF  77
0194:  BTFSS  03.2
0195:  GOTO   19E
0196:  BTFSC  25.6
0197:  GOTO   19E
0198:  BTFSC  25.4
0199:  GOTO   1A9
019A:  BTFSC  25.3
019B:  GOTO   19E
019C:  MOVLW  20
019D:  GOTO   1A1
019E:  BSF    25.3
019F:  BCF    25.4
01A0:  MOVLW  30
01A1:  ADDWF  77,F
01A2:  MOVF   77,W
01A3:  MOVLB  00
01A4:  BTFSS  11.4
01A5:  GOTO   1A4
01A6:  MOVLB  03
01A7:  MOVWF  1A
01A8:  MOVLB  0C
01A9:  ADDFSR 01,FSR0
01AA:  BTFSS  25.6
01AB:  GOTO   18E
01AC:  MOVLB  00
01AD:  RETURN
*
01E1:  MOVLW  10
01E2:  MOVLB  0C
01E3:  MOVWF  2C
01E4:  CLRF   77
01E5:  CLRF   7A
01E6:  RRF    29,F
01E7:  RRF    28,F
01E8:  BTFSS  03.0
01E9:  GOTO   1F0
01EA:  MOVF   2A,W
01EB:  ADDWF  77,F
01EC:  BTFSC  03.0
01ED:  INCF   7A,F
01EE:  MOVF   2B,W
01EF:  ADDWF  7A,F
01F0:  RRF    7A,F
01F1:  RRF    77,F
01F2:  RRF    79,F
01F3:  RRF    78,F
01F4:  DECFSZ 2C,F
01F5:  GOTO   1E6
01F6:  MOVLB  00
01F7:  RETURN
01F8:  CLRF   78
01F9:  CLRF   79
01FA:  CLRF   77
01FB:  CLRF   7A
01FC:  MOVLB  0C
01FD:  MOVF   2D,W
01FE:  BTFSS  03.2
01FF:  GOTO   203
0200:  MOVF   2C,W
0201:  BTFSC  03.2
0202:  GOTO   21D
0203:  MOVLW  10
0204:  MOVWF  2E
0205:  BCF    03.0
0206:  RLF    2A,F
0207:  RLF    2B,F
0208:  RLF    77,F
0209:  RLF    7A,F
020A:  MOVF   2D,W
020B:  SUBWF  7A,W
020C:  BTFSS  03.2
020D:  GOTO   210
020E:  MOVF   2C,W
020F:  SUBWF  77,W
0210:  BTFSS  03.0
0211:  GOTO   219
0212:  MOVF   2C,W
0213:  SUBWF  77,F
0214:  BTFSS  03.0
0215:  DECF   7A,F
0216:  MOVF   2D,W
0217:  SUBWF  7A,F
0218:  BSF    03.0
0219:  RLF    78,F
021A:  RLF    79,F
021B:  DECFSZ 2E,F
021C:  GOTO   205
021D:  MOVLB  00
021E:  RETURN
*
03F3:  MOVLW  20
03F4:  MOVWF  2C
03F5:  CLRF   28
03F6:  CLRF   29
03F7:  CLRF   2A
03F8:  CLRF   2B
03F9:  MOVF   23,W
03FA:  MOVWF  7A
03FB:  MOVF   22,W
03FC:  MOVWF  79
03FD:  MOVF   21,W
03FE:  MOVWF  78
03FF:  MOVF   20,W
0400:  MOVWF  77
0401:  BCF    03.0
0402:  BTFSS  77.0
0403:  GOTO   412
0404:  MOVF   24,W
0405:  ADDWF  28,F
0406:  MOVF   25,W
0407:  BTFSC  03.0
0408:  INCFSZ 25,W
0409:  ADDWF  29,F
040A:  MOVF   26,W
040B:  BTFSC  03.0
040C:  INCFSZ 26,W
040D:  ADDWF  2A,F
040E:  MOVF   27,W
040F:  BTFSC  03.0
0410:  INCFSZ 27,W
0411:  ADDWF  2B,F
0412:  RRF    2B,F
0413:  RRF    2A,F
0414:  RRF    29,F
0415:  RRF    28,F
0416:  RRF    7A,F
0417:  RRF    79,F
0418:  RRF    78,F
0419:  RRF    77,F
041A:  DECFSZ 2C,F
041B:  GOTO   401
*
05F5:  DATA 43,34
05F6:  DATA 61,37
05F7:  DATA E7,34
05F8:  DATA EE,33
05F9:  DATA 20,28
05FA:  DATA 61,3A
05FB:  DATA F4,32
05FC:  DATA 72,37
05FD:  DATA 20,3A
05FE:  DATA 6F,10
05FF:  DATA 25,26
0600:  DATA 75,05
0601:  DATA 0D,00
0602:  MOVF   0B,W
0603:  MOVLB  0B
0604:  MOVWF  65
0605:  BCF    0B.7
0606:  MOVLB  03
0607:  BSF    15.7
0608:  BSF    15.0
0609:  NOP
060A:  NOP
060B:  MOVF   13,W
060C:  ANDLW  7F
060D:  BTFSC  03.2
060E:  GOTO   64C
060F:  MOVLB  0B
0610:  MOVWF  66
0611:  MOVLB  03
0612:  MOVF   11,W
0613:  MOVLB  0B
0614:  MOVWF  67
0615:  MOVLB  03
0616:  MOVF   12,W
0617:  MOVLB  0B
0618:  MOVWF  68
0619:  MOVF   66,W
061A:  MOVLB  00
061B:  BTFSS  11.4
061C:  GOTO   61B
061D:  MOVLB  03
061E:  MOVWF  1A
061F:  MOVLB  0B
0620:  MOVF   67,W
0621:  MOVLB  03
0622:  MOVWF  11
0623:  MOVLB  0B
0624:  MOVF   68,W
0625:  MOVLB  03
0626:  MOVWF  12
0627:  BSF    15.7
0628:  BSF    15.0
0629:  NOP
062A:  NOP
062B:  RLF    13,W
062C:  RLF    14,W
062D:  ANDLW  7F
062E:  BTFSC  03.2
062F:  GOTO   64C
0630:  MOVLB  0B
0631:  MOVWF  66
0632:  MOVLB  03
0633:  MOVF   11,W
0634:  MOVLB  0B
0635:  MOVWF  67
0636:  MOVLB  03
0637:  MOVF   12,W
0638:  MOVLB  0B
0639:  MOVWF  68
063A:  MOVF   66,W
063B:  MOVLB  00
063C:  BTFSS  11.4
063D:  GOTO   63C
063E:  MOVLB  03
063F:  MOVWF  1A
0640:  MOVLB  0B
0641:  MOVF   67,W
0642:  MOVLB  03
0643:  MOVWF  11
0644:  MOVLB  0B
0645:  MOVF   68,W
0646:  MOVLB  03
0647:  MOVWF  12
0648:  INCF   11,F
0649:  BTFSC  03.2
064A:  INCF   12,F
064B:  GOTO   607
064C:  MOVLB  0B
064D:  BTFSC  65.7
064E:  BSF    0B.7
064F:  MOVLB  00
0650:  RETURN
*
06C4:  DATA D3,3C
06C5:  DATA 73,3A
06C6:  DATA E5,36
06C7:  DATA A0,29
06C8:  DATA F4,30
06C9:  DATA 72,3A
06CA:  DATA 65,32
06CB:  DATA 8A,06
06CC:  DATA 00,01
06CD:  DATA 53,3A
06CE:  DATA 61,39
06CF:  DATA F4,34
06D0:  DATA EE,33
06D1:  DATA 20,29
06D2:  DATA D4,27
06D3:  DATA 53,05
06D4:  DATA 0D,00
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOMCLR, NOBROWNOUT, WDT_NOSL, PUT 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
03DC:  MOVF   25,W
03DD:  MOVLB  0C
03DE:  MOVWF  23
03DF:  MOVLB  00
03E0:  MOVF   24,W
03E1:  MOVLB  0C
03E2:  MOVWF  22
03E3:  MOVLB  00
03E4:  MOVF   23,W
03E5:  MOVLB  0C
03E6:  MOVWF  21
03E7:  MOVLB  00
03E8:  MOVF   22,W
03E9:  MOVLB  0C
03EA:  MOVWF  20
03EB:  MOVLW  41
03EC:  MOVWF  27
03ED:  MOVLW  C6
03EE:  MOVWF  26
03EF:  MOVLW  4E
03F0:  MOVWF  25
03F1:  MOVLW  6D
03F2:  MOVWF  24
*
041C:  MOVF   7A,W
041D:  MOVWF  23
041E:  MOVF   79,W
041F:  MOVWF  22
0420:  MOVF   78,W
0421:  MOVWF  21
0422:  MOVF   77,W
0423:  MOVWF  20
0424:  MOVLW  39
0425:  ADDWF  20,W
0426:  MOVLB  00
0427:  MOVWF  22
0428:  MOVLW  30
0429:  MOVLB  0C
042A:  ADDWFC 21,W
042B:  MOVLB  00
042C:  MOVWF  23
042D:  MOVLW  00
042E:  MOVLB  0C
042F:  ADDWFC 22,W
0430:  MOVLB  00
0431:  MOVWF  24
0432:  MOVLW  00
0433:  MOVLB  0C
0434:  ADDWFC 23,W
0435:  MOVLB  00
0436:  MOVWF  25
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0437:  MOVF   24,W
0438:  MOVWF  77
0439:  MOVF   25,W
043A:  MOVWF  78
043B:  CLRF   79
043C:  CLRF   7A
043D:  MOVF   25,W
043E:  MOVLB  0C
043F:  MOVWF  22
0440:  MOVF   77,W
0441:  MOVWF  21
0442:  MOVF   22,W
0443:  MOVWF  2B
0444:  MOVF   21,W
0445:  MOVWF  2A
0446:  MOVLW  7F
0447:  MOVWF  2D
0448:  MOVLW  FF
0449:  MOVWF  2C
044A:  MOVLB  00
044B:  CALL   1F8
044C:  MOVF   77,W
044D:  MOVWF  78
044E:  MOVF   7A,W
044F:  MOVWF  79
0450:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "Globals.h" 
.................... /* 
....................  * File:   Globals.h 
....................  * Author: Matt Wasserman 
....................  * Header file with all global vars and defines 
....................  */ 
....................  
.................... /* DEFINES FOR VERSION*/ 
.................... //#define BOARD_V1_1 
.................... #define BOARD_V1_2 //and V1_3 
....................  
.................... #define WS2801 
.................... //#define WS2811 
....................  
.................... //#define DIRECT_LED 
.................... #define MOSFET_CONTROL_SHOE 
....................  
.................... /* DEFINES */ 
.................... //#define TDOTS 46 // number of LEDs on the strip for tent light 
.................... //#define TDOTS 22 //standard womens belt 
.................... #define TDOTS 1 //Shealene Shoe's 
....................  
.................... #define NUM_INTERNAL_TIMER 1 
.................... #define NUM_PATTERN_POSITION 2 
.................... #define NUM_PATTERNS 22 
.................... #define DELAY_TIME_MS_JUMP 10 
.................... #define LED_ON_PIN PIN_A7 
.................... #define MAX_BRIGHTNESS 10 
.................... #define MIN_BRIGHTNESS 1 
....................  
.................... //defines for buttons 
.................... #define POWER_BUTTON_PIN PIN_A0 
.................... #define UP_BUTTON_PIN PIN_A1 
.................... #define DOWN_BUTTON_PIN PIN_A2 
.................... #define LEFT_BUTTON_PIN PIN_A3 
.................... #define RIGHT_BUTTON_PIN PIN_A4 
.................... #define CENTER_BUTTON_PIN PIN_A5 
.................... #define POWER_BUTTON_BIT 0 
.................... #define UP_BUTTON_BIT 1 
.................... #define DOWN_BUTTON_BIT 2 
.................... #define LEFT_BUTTON_BIT 3 
.................... #define RIGHT_BUTTON_BIT 4 
.................... #define CENTER_BUTTON_BIT 5 
....................  
.................... //Debug functions 
.................... #define DEBUG_SERIAL 1 
....................  
.................... struct rtos_stats { 
....................    int32 task_total_ticks;       // number of ticks the task has used 
....................    int16 task_min_ticks;         // the minimum number of ticks used 
....................    int16 task_max_ticks;         // the maximum number of ticks ueed 
....................    int16 hns_per_tick;           // us = (ticks*hns_per_tic)/10 
.................... }; 
....................  
....................  
.................... /* GLOBAL VARIABLES*/ 
.................... unsigned int32 node_list[TDOTS]; 
.................... unsigned int32 internal_timer[NUM_INTERNAL_TIMER]; 
.................... unsigned int16 pattern_position[NUM_PATTERN_POSITION]; //used to track current position within a patten 
.................... unsigned int16 current_pattern; 
.................... int1 pattern_set; 
.................... int1 continue_pattern_calling; 
.................... int1 led_power_status; 
.................... int16 timer_flags_counter; 
.................... unsigned int8 button_status; 
.................... unsigned int8 button_counter; 
.................... int autochange_pattern; 
.................... int16 delay_time_ms; 
.................... unsigned int8 brightness_value; 
....................  
....................  
.................... //BMP Patterns 
.................... unsigned int32 Pattern1[10] = {0xE05CFF, 0xCA53FF, 0xB44AFF, 0x9C40FF, 0x8637FF, 0x702EFF, 0x5A25FF, 0x421BFF, 0x2C12FF, 0x1609FF}; 
.................... unsigned int32 Pattern2[10] = {0x0000FF, 0x00FF00, 0x0000FF, 0x00FF00, 0x0000FF, 0x00FF00, 0x0000FF, 0x00FF00, 0x0000FF, 0x00FF00}; 
.................... unsigned int32 Pattern3[40] = {0x35FFFC, 0x38FCFA, 0x3BF9F8, 0x3EF5F6, 0x42F1F4, 0x46EDF1, 0x4AE8EE, 0x4FE3EB, 0x54DEE8, 0x59D8E5, 0x5ED2E1, 0x63CCDE, 0x69C6DA, 0x6FC0D6, 0x75B9D3, 0x7BB3CF, 0x81ACCB, 0x87A6C7, 0x8D9FC3, 0x9498BF, 0x9A91BB, 0xA08AB6, 0xA783B2, 0xAD7CAE, 0xB376AA, 0xB96FA6, 0xBF69A2, 0xC5629F, 0xCB5C9B, 0xD15697, 0xD65094, 0xDB4A90, 0xE0448D, 0xE53F8A, 0xEA3A87, 0xEE3584, 0xF23181, 0xF62D7F, 0xF9297D, 0xFC267B}; 
.................... unsigned int32 Pattern4[60] = {0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFFFF4F, 0xFEFE50, 0xF4F457, 0xE7E760, 0xD8D86B, 0xC7C777, 0xB4B485, 0xA0A093, 0x8B8BA2, 0x7676B1, 0x6161C0, 0x4D4DCE, 0x3B3BDB, 0x2A2AE6, 0x1B1BF0, 0x0F0FF8, 0x0606FD, 0x0101FF, 0x0000FF, 0x0202FB, 0x0707F6, 0x0E0EEF, 0x1818E6, 0x2323DB, 0x3030CF, 0x3E3EC2, 0x4E4EB4, 0x5E5EA5, 0x6F6F96, 0x808087, 0x919177, 0xA2A268, 0xB3B35A, 0xC3C34C, 0xD1D13F, 0xDFDF33, 0xEBEB28, 0xF5F51F, 0xFDFD18, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16, 0xFFFF16}; 
.................... //rainbow wave 
.................... unsigned int32 Pattern5[52] = {0x1021DE,0x4111EE,0x8511EE,0xC611EE,0xEA11E9,0xEE11C7,0xEE118E,0xEE1151,0xEE111C,0xEE1902,0xEE4200,0xEE8000,0xEEC000,0xEEF100,0xD9FF00,0xA1FF00,0x5BFF00,0x1DFF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x1FFF00,0x61FF00,0xACFF00,0xE9FF00,0xFFF000,0xFFBB00,0xFF7700,0xFF3400,0xFF0902,0xFF001E,0xFF0057,0xFF0098,0xFF00D5,0xFB00FA,0xD400FF,0x8E00FF,0x4600FF,0x1200FF}; 
.................... //white blue dot 
.................... unsigned int32 Pattern6[22] = {0xF9F9F9,0xF1F0F1,0xE4E2E5,0xF1EFF3,0x9E9CA2,0x1E1B20,0x1B1A1D,0x2C2C2D,0x626262,0xB3B3B3,0xF0EDF3,0xE6D9F3,0xA480C8,0x6F2DB3,0x660AC3,0x6503C8,0x5506A4,0x4A1B79,0x634F77,0x96909C,0xB2B1B4,0x9FA09F}; 
.................... //Chase Green 
.................... unsigned int32 Pattern7[3] = {0xFF0000,0x000000,0x000000}; 
.................... //Chase Red 
.................... unsigned int32 Pattern8[3] = {0x00FF00,0x000000,0x000000}; 
.................... //Chase Blue 
.................... unsigned int32 Pattern9[3] = {0x0000FF,0x000000,0x000000}; 
....................  
.................... unsigned int Pattern1_Size = 10; 
.................... unsigned int Pattern2_Size = 10; 
.................... unsigned int Pattern3_Size = 40; 
.................... unsigned int Pattern4_Size = 60; 
.................... unsigned int Pattern5_Size = 52; 
.................... unsigned int Pattern6_Size = 22; 
.................... unsigned int Pattern7_Size = 3; 
.................... unsigned int Pattern8_Size = 3; 
.................... unsigned int Pattern9_Size = 3; 
....................  
....................  
....................  
.................... #USE DELAY(clock=32000000) 
*
021F:  MOVLW  02
0220:  MOVLB  0C
0221:  SUBWF  29,F
0222:  BTFSS  03.0
0223:  GOTO   231
0224:  MOVLW  23
0225:  MOVWF  05
0226:  MOVLW  C9
0227:  MOVWF  04
0228:  MOVF   00,W
0229:  BTFSC  03.2
022A:  GOTO   231
022B:  GOTO   22F
022C:  GOTO   22D
022D:  GOTO   22E
022E:  NOP
022F:  DECFSZ 00,F
0230:  GOTO   22C
0231:  MOVLB  00
0232:  RETURN
*
0651:  MOVLW  23
0652:  MOVWF  05
0653:  MOVLW  B7
0654:  MOVWF  04
0655:  MOVF   00,W
0656:  BTFSC  03.2
0657:  GOTO   665
0658:  MOVLW  0A
0659:  MOVWF  78
065A:  CLRF   77
065B:  DECFSZ 77,F
065C:  GOTO   65B
065D:  DECFSZ 78,F
065E:  GOTO   65A
065F:  MOVLW  5F
0660:  MOVWF  77
0661:  DECFSZ 77,F
0662:  GOTO   661
0663:  DECFSZ 00,F
0664:  GOTO   658
0665:  RETURN
....................  
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BITS=8, STOP=1, PARITY=N, INVERT) 
.................... #use rtos(timer=1) 
....................  
....................  
.................... /* TASK FUNCTIONS */ 
.................... #task(rate=30s,max=5ms) 
.................... void Pattern_Selector(); 
....................  
.................... #task(rate=10ms,max=5ms) 
.................... void Update_Pattern(); 
....................  
.................... #task(rate=10ms,max=5ms) 
.................... void Button_Checker(); 
....................  
.................... #task(rate=1ms,max=1ms) 
.................... void Timer_Tic(); 
....................  
.................... /* 
.................... #task(rate=100ms,max=1ms) 
.................... void Timer_Check(); 
.................... */ 
....................  
.................... /*Additonal Includes*/ 
....................  
.................... #include "Timer_Flags.c" 
.................... //FILE NAME = Timer_Flags.c 
.................... // functions to avoid using delay calls 
....................  
.................... void Timer_Clear_Timer(int timer){ 
....................     if(timer < NUM_INTERNAL_TIMER){ 
*
03C3:  MOVLB  0C
03C4:  MOVF   20,F
03C5:  BTFSS  03.2
03C6:  GOTO   3DA
....................         internal_timer[timer] = 0; 
03C7:  RLF    20,W
03C8:  MOVWF  77
03C9:  RLF    77,F
03CA:  MOVLW  FC
03CB:  ANDWF  77,F
03CC:  MOVF   77,W
03CD:  ADDLW  0A
03CE:  MOVWF  04
03CF:  MOVLW  20
03D0:  MOVWF  05
03D1:  BTFSC  03.0
03D2:  INCF   05,F
03D3:  CLRF   00
03D4:  ADDFSR 01,FSR0
03D5:  CLRF   00
03D6:  ADDFSR 01,FSR0
03D7:  CLRF   00
03D8:  ADDFSR 01,FSR0
03D9:  CLRF   00
....................     } 
03DA:  MOVLB  00
03DB:  RETURN
.................... } 
....................  
.................... void Timer_Clear_All_Timer(){ 
....................     int i; 
....................     rtos_disable(Timer_Tic); 
*
06F3:  MOVLB  0A
06F4:  BSF    61.7
....................     for (i=0;i<NUM_INTERNAL_TIMER;i++){ 
06F5:  CLRF   6B
06F6:  MOVF   6B,F
06F7:  BTFSS  03.2
06F8:  GOTO   70E
....................         internal_timer[i] = 0; 
06F9:  RLF    6B,W
06FA:  MOVWF  77
06FB:  RLF    77,F
06FC:  MOVLW  FC
06FD:  ANDWF  77,F
06FE:  MOVF   77,W
06FF:  ADDLW  0A
0700:  MOVWF  04
0701:  MOVLW  20
0702:  MOVWF  05
0703:  BTFSC  03.0
0704:  INCF   05,F
0705:  CLRF   00
0706:  ADDFSR 01,FSR0
0707:  CLRF   00
0708:  ADDFSR 01,FSR0
0709:  CLRF   00
070A:  ADDFSR 01,FSR0
070B:  CLRF   00
070C:  INCF   6B,F
070D:  GOTO   6F6
....................     } 
....................     rtos_enable(Timer_Tic); 
070E:  BCF    61.7
070F:  MOVLP  10
0710:  MOVLB  00
0711:  GOTO   72F (RETURN)
.................... } 
....................  
.................... int32 Timer_Get_Timer(int timer){ 
....................     if(timer < NUM_INTERNAL_TIMER){ 
*
033E:  MOVLB  0C
033F:  MOVF   20,F
0340:  BTFSS  03.2
0341:  GOTO   35C
....................         return internal_timer[timer]; 
0342:  RLF    20,W
0343:  MOVWF  77
0344:  RLF    77,F
0345:  MOVLW  FC
0346:  ANDWF  77,F
0347:  MOVF   77,W
0348:  ADDLW  0A
0349:  MOVWF  04
034A:  MOVLW  20
034B:  MOVWF  05
034C:  BTFSC  03.0
034D:  INCF   05,F
034E:  MOVF   00,W
034F:  MOVWF  77
0350:  ADDFSR 01,FSR0
0351:  MOVF   00,W
0352:  MOVWF  78
0353:  ADDFSR 01,FSR0
0354:  MOVF   00,W
0355:  MOVWF  79
0356:  ADDFSR 01,FSR0
0357:  MOVF   00,W
0358:  MOVWF  7A
0359:  ADDFSR 3D,FSR0
035A:  GOTO   360
....................     }else{ 
035B:  GOTO   360
....................         return 0; 
035C:  CLRF   77
035D:  CLRF   78
035E:  CLRF   79
035F:  CLRF   7A
....................     } 
0360:  MOVLB  00
0361:  RETURN
.................... } 
....................  
.................... void Timer_Tic(){ 
....................     //OUTPUT_HIGH(PIN_C4); 
....................     int i; 
....................     for (i=0;i<NUM_INTERNAL_TIMER;i++){ 
*
000C:  MOVLB  0B
000D:  CLRF   65
000E:  MOVF   65,F
000F:  BTFSS  03.2
0010:  GOTO   028
....................         internal_timer[i]++; 
0011:  RLF    65,W
0012:  MOVWF  77
0013:  RLF    77,F
0014:  MOVLW  FC
0015:  ANDWF  77,F
0016:  MOVF   77,W
0017:  ADDLW  0A
0018:  MOVWF  04
0019:  MOVLW  20
001A:  MOVWF  05
001B:  BTFSC  03.0
001C:  INCF   05,F
001D:  MOVLW  01
001E:  ADDWF  00,F
001F:  ADDFSR 01,FSR0
0020:  MOVLW  00
0021:  ADDWFC 00,F
0022:  ADDFSR 01,FSR0
0023:  ADDWFC 00,F
0024:  ADDFSR 01,FSR0
0025:  ADDWFC 00,F
0026:  INCF   65,F
0027:  GOTO   00E
....................     } 
0028:  MOVLW  0C
0029:  MOVLB  0A
002A:  MOVWF  66
002B:  MOVLW  00
002C:  MOVWF  67
002D:  MOVLP  10
002E:  MOVLB  00
002F:  GOTO   7A8
0030:  RETURN
....................     //OUTPUT_LOW(PIN_C4); 
.................... } 
....................  
.................... void Timer_Check() { 
....................     int i; 
....................     for (i = 0; i < NUM_INTERNAL_TIMER; i++) { 
.................... #ifdef DEBUG_SERIAL 
....................         printf("Timer %i = %Lu\n\r",i,internal_timer[i]); 
.................... #endif 
....................     } 
....................  
.................... } 
....................  
.................... #ifdef WS2801 
....................     #include "WS2801_SPI.c" 
.................... //FILE NAME = WS2801_SPI.c 
.................... //File to output controls to a WS2801 led strip using PIC SPI commands 
....................  
.................... //needed Constant 
.................... //nDots - number of nodes in the chain 
....................  
.................... //needed Globel Vars 
.................... //node_list - 32bit array where all node colors are stored 
....................  
.................... //*****************Function List*****************// 
.................... //void send_frame(void) 
.................... 	//Update the chain of WS2801 Nodes 
.................... //******************Functions*******************// 
....................  
.................... //use SPI to sent out all frames 
.................... void send_frame(void) {   // NOTE this strip takes data in BLUE, GREEN, RED order 
....................  
....................  
....................   unsigned int16 i; 
....................   unsigned int16 red,green,blue; 
....................  
....................   for(i=0;i<TDOTS;i++) { 
*
0233:  MOVLB  0C
0234:  CLRF   21
0235:  CLRF   20
0236:  MOVF   20,F
0237:  BTFSS  03.2
0238:  GOTO   315
0239:  MOVF   21,F
023A:  BTFSS  03.2
023B:  GOTO   315
....................  
....................  
.................... #ifdef DIRECT_LED 
....................     red = node_list[i] & 0xFF; 
....................     green = (node_list[i] >> 8) & 0xFF; 
....................     blue = (node_list[i] >> 16) & 0xFF; 
....................     //apply brightness_control 
....................     red = red * brightness_value / MAX_BRIGHTNESS; 
....................     green = green * brightness_value / MAX_BRIGHTNESS; 
....................     blue = blue * brightness_value / MAX_BRIGHTNESS; 
.................... #endif 
....................  
....................  
.................... #ifdef MOSFET_CONTROL_SHOE 
....................     red = node_list[i] & 0xFF; 
023C:  RLF    20,W
023D:  MOVWF  79
023E:  RLF    21,W
023F:  MOVWF  7A
0240:  RLF    79,F
0241:  RLF    7A,F
0242:  MOVLW  FC
0243:  ANDWF  79,F
0244:  MOVF   79,W
0245:  ADDLW  06
0246:  MOVWF  04
0247:  MOVLW  20
0248:  ADDWFC 7A,W
0249:  MOVWF  05
024A:  MOVF   00,W
024B:  MOVWF  28
024C:  MOVIW  [FSR0+01],W
024D:  MOVWF  29
024E:  MOVIW  [FSR0+02],W
024F:  MOVWF  2A
0250:  MOVIW  [FSR0+03],W
0251:  MOVWF  2B
0252:  MOVF   28,W
0253:  MOVWF  22
0254:  CLRF   23
....................     green = (node_list[i] >> 8) & 0xFF; 
0255:  RLF    20,W
0256:  MOVWF  79
0257:  RLF    21,W
0258:  MOVWF  7A
0259:  RLF    79,F
025A:  RLF    7A,F
025B:  MOVLW  FC
025C:  ANDWF  79,F
025D:  MOVF   79,W
025E:  ADDLW  06
025F:  MOVWF  04
0260:  MOVLW  20
0261:  ADDWFC 7A,W
0262:  MOVWF  05
0263:  MOVF   00,W
0264:  MOVWF  28
0265:  MOVIW  [FSR0+01],W
0266:  MOVWF  29
0267:  MOVIW  [FSR0+02],W
0268:  MOVWF  2A
0269:  MOVIW  [FSR0+03],W
026A:  MOVWF  2B
026B:  MOVF   29,W
026C:  MOVWF  28
026D:  MOVF   2A,W
026E:  MOVWF  29
026F:  MOVF   2B,W
0270:  MOVWF  2A
0271:  CLRF   2B
0272:  MOVF   28,W
0273:  MOVWF  24
0274:  CLRF   25
....................     blue = (node_list[i] >> 16) & 0xFF;     
0275:  RLF    20,W
0276:  MOVWF  79
0277:  RLF    21,W
0278:  MOVWF  7A
0279:  RLF    79,F
027A:  RLF    7A,F
027B:  MOVLW  FC
027C:  ANDWF  79,F
027D:  MOVF   79,W
027E:  ADDLW  06
027F:  MOVWF  04
0280:  MOVLW  20
0281:  ADDWFC 7A,W
0282:  MOVWF  05
0283:  MOVF   00,W
0284:  MOVWF  28
0285:  MOVIW  [FSR0+01],W
0286:  MOVWF  29
0287:  MOVIW  [FSR0+02],W
0288:  MOVWF  2A
0289:  MOVIW  [FSR0+03],W
028A:  MOVWF  2B
028B:  MOVF   2A,W
028C:  MOVWF  28
028D:  MOVF   2B,W
028E:  MOVWF  29
028F:  CLRF   2A
0290:  CLRF   2B
0291:  MOVF   28,W
0292:  MOVWF  26
0293:  CLRF   27
....................     red = 255 - (red * brightness_value / MAX_BRIGHTNESS); 
0294:  MOVF   23,W
0295:  MOVWF  29
0296:  MOVF   22,W
0297:  MOVWF  28
0298:  CLRF   2B
0299:  MOVLB  00
029A:  MOVF   3C,W
029B:  MOVLB  0C
029C:  MOVWF  2A
029D:  MOVLB  00
029E:  CALL   1E1
029F:  MOVF   79,W
02A0:  MOVLB  0C
02A1:  MOVWF  29
02A2:  MOVF   78,W
02A3:  MOVWF  28
02A4:  MOVF   29,W
02A5:  MOVWF  2B
02A6:  MOVF   28,W
02A7:  MOVWF  2A
02A8:  CLRF   2D
02A9:  MOVLW  0A
02AA:  MOVWF  2C
02AB:  MOVLB  00
02AC:  CALL   1F8
02AD:  MOVF   78,W
02AE:  SUBLW  FF
02AF:  MOVLB  0C
02B0:  MOVWF  22
02B1:  MOVLW  00
02B2:  MOVWF  23
02B3:  MOVF   79,W
02B4:  SUBWFC 23,F
....................     green = 255 - (green * brightness_value / MAX_BRIGHTNESS); 
02B5:  MOVF   25,W
02B6:  MOVWF  29
02B7:  MOVF   24,W
02B8:  MOVWF  28
02B9:  CLRF   2B
02BA:  MOVLB  00
02BB:  MOVF   3C,W
02BC:  MOVLB  0C
02BD:  MOVWF  2A
02BE:  MOVLB  00
02BF:  CALL   1E1
02C0:  MOVF   79,W
02C1:  MOVLB  0C
02C2:  MOVWF  29
02C3:  MOVF   78,W
02C4:  MOVWF  28
02C5:  MOVF   29,W
02C6:  MOVWF  2B
02C7:  MOVF   28,W
02C8:  MOVWF  2A
02C9:  CLRF   2D
02CA:  MOVLW  0A
02CB:  MOVWF  2C
02CC:  MOVLB  00
02CD:  CALL   1F8
02CE:  MOVF   78,W
02CF:  SUBLW  FF
02D0:  MOVLB  0C
02D1:  MOVWF  24
02D2:  MOVLW  00
02D3:  MOVWF  25
02D4:  MOVF   79,W
02D5:  SUBWFC 25,F
....................     blue = 255 - (blue * brightness_value / MAX_BRIGHTNESS); 
02D6:  MOVF   27,W
02D7:  MOVWF  29
02D8:  MOVF   26,W
02D9:  MOVWF  28
02DA:  CLRF   2B
02DB:  MOVLB  00
02DC:  MOVF   3C,W
02DD:  MOVLB  0C
02DE:  MOVWF  2A
02DF:  MOVLB  00
02E0:  CALL   1E1
02E1:  MOVF   79,W
02E2:  MOVLB  0C
02E3:  MOVWF  29
02E4:  MOVF   78,W
02E5:  MOVWF  28
02E6:  MOVF   29,W
02E7:  MOVWF  2B
02E8:  MOVF   28,W
02E9:  MOVWF  2A
02EA:  CLRF   2D
02EB:  MOVLW  0A
02EC:  MOVWF  2C
02ED:  MOVLB  00
02EE:  CALL   1F8
02EF:  MOVF   78,W
02F0:  SUBLW  FF
02F1:  MOVLB  0C
02F2:  MOVWF  26
02F3:  MOVLW  00
02F4:  MOVWF  27
02F5:  MOVF   79,W
02F6:  SUBWFC 27,F
....................  
.................... #endif 
....................  
....................  
....................     spi_write((int8)red); 
02F7:  MOVLB  04
02F8:  MOVF   11,W
02F9:  MOVLB  0C
02FA:  MOVF   22,W
02FB:  MOVLB  04
02FC:  MOVWF  11
02FD:  RRF    14,W
02FE:  BTFSS  03.0
02FF:  GOTO   2FD
....................     spi_write((int8)blue); 
0300:  MOVF   11,W
0301:  MOVLB  0C
0302:  MOVF   26,W
0303:  MOVLB  04
0304:  MOVWF  11
0305:  RRF    14,W
0306:  BTFSS  03.0
0307:  GOTO   305
....................     spi_write((int8)green); 
0308:  MOVF   11,W
0309:  MOVLB  0C
030A:  MOVF   24,W
030B:  MOVLB  04
030C:  MOVWF  11
030D:  RRF    14,W
030E:  BTFSS  03.0
030F:  GOTO   30D
0310:  MOVLB  0C
0311:  INCF   20,F
0312:  BTFSC  03.2
0313:  INCF   21,F
0314:  GOTO   236
....................   } 
....................   delay_us(500);    // delay 500us to latch the IC 
0315:  MOVLW  02
0316:  MOVWF  28
0317:  MOVLW  FA
0318:  MOVWF  29
0319:  MOVLB  00
031A:  CALL   21F
031B:  MOVLB  0C
031C:  DECFSZ 28,F
031D:  GOTO   317
031E:  MOVLB  00
031F:  RETURN
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... #endif 
.................... #ifdef WS2811 
....................     #include "WS2811_SPI.c" 
.................... #endif 
.................... #include "LED_Array.c" 
.................... //FILE NAME = LED_Array.c 
.................... //Functions to generate 24bit colors patterns and manipulate them 
....................  
.................... //void addRandom(void) 
.................... 	//shifts all dots one to the right and adds 1 random value 
....................  
.................... //int32 Color(int r, int g, int b) 
.................... 	// Create a 24 bit color value from R,G,B 
....................  
.................... //int32 Wheel(int16 WheelPos){ 
.................... 	//Input a value 0 to 767 to get a color value. 
.................... 	//The colours are a transition r - g -b - back to r 
....................  
.................... //void MakeAllColor(int32 color_set) 
.................... 	//make all LEDS one color (overloaded function) 
....................  
.................... //void MakeAllColor(int red, int green, int blue) 
.................... 	//make all LEDS one color, overloaded to accept red, green blue inputs 
....................  
.................... //void setup() 
.................... 	////Clear out the array 
....................  
.................... //NOT IN THE FILE ANYMORE 
....................  
.................... //void ShiftRight(int16 newval) 
.................... 	//Shift right, Shift the node_list one to the right 
.................... 	//[i] -> [i+1]. Insert newval in node_list[0] 
....................  
.................... //void ShiftRight(int32 newval) 
.................... 	//Shift right, Shift the node_list one to the right 
.................... 	//[i] -> [i+1]. Insert newval in node_list[0] 
....................  
.................... void addRandom(void) { 
*
0B36:  CLRF   6A
0B37:  CLRF   69
0B38:  CLRF   68
0B39:  CLRF   67
....................   unsigned int16 x; 
....................   unsigned int32 new_color = 0; 
....................  
....................   //First, shuffle all the current colors down one spot on the strip 
....................   for(x = (TDOTS - 1) ; x > 0 ; x--) 
0B3A:  CLRF   66
0B3B:  CLRF   65
0B3C:  MOVF   65,F
0B3D:  BTFSS  03.2
0B3E:  GOTO   342
0B3F:  MOVF   66,F
0B40:  BTFSC  03.2
0B41:  GOTO   396
....................     node_list[x] = node_list[x - 1]; 
0B42:  RLF    65,W
0B43:  MOVWF  79
0B44:  RLF    66,W
0B45:  MOVWF  7A
0B46:  RLF    79,F
0B47:  RLF    7A,F
0B48:  MOVLW  FC
0B49:  ANDWF  79,F
0B4A:  MOVF   79,W
0B4B:  ADDLW  06
0B4C:  MOVWF  78
0B4D:  MOVLW  20
0B4E:  ADDWFC 7A,F
0B4F:  MOVF   78,W
0B50:  MOVLB  0C
0B51:  MOVWF  20
0B52:  MOVF   7A,W
0B53:  MOVWF  21
0B54:  MOVLW  01
0B55:  MOVLB  0B
0B56:  SUBWF  65,W
0B57:  MOVLB  0C
0B58:  MOVWF  22
0B59:  MOVLW  00
0B5A:  MOVLB  0B
0B5B:  SUBWFC 66,W
0B5C:  MOVLB  0C
0B5D:  MOVWF  23
0B5E:  RLF    22,W
0B5F:  MOVWF  79
0B60:  RLF    23,W
0B61:  MOVWF  7A
0B62:  RLF    79,F
0B63:  RLF    7A,F
0B64:  MOVLW  FC
0B65:  ANDWF  79,F
0B66:  MOVF   79,W
0B67:  ADDLW  06
0B68:  MOVWF  04
0B69:  MOVLW  20
0B6A:  ADDWFC 7A,W
0B6B:  MOVWF  05
0B6C:  MOVF   00,W
0B6D:  MOVWF  77
0B6E:  ADDFSR 01,FSR0
0B6F:  MOVF   00,W
0B70:  MOVWF  78
0B71:  ADDFSR 01,FSR0
0B72:  MOVF   00,W
0B73:  MOVWF  79
0B74:  ADDFSR 01,FSR0
0B75:  MOVF   00,W
0B76:  MOVWF  7A
0B77:  ADDFSR 3D,FSR0
0B78:  MOVF   7A,W
0B79:  MOVWF  25
0B7A:  MOVF   79,W
0B7B:  MOVWF  24
0B7C:  MOVF   78,W
0B7D:  MOVWF  23
0B7E:  MOVF   77,W
0B7F:  MOVWF  22
0B80:  MOVF   21,W
0B81:  MOVWF  05
0B82:  MOVF   20,W
0B83:  MOVWF  04
0B84:  MOVF   22,W
0B85:  MOVWF  00
0B86:  ADDFSR 01,FSR0
0B87:  MOVF   23,W
0B88:  MOVWF  00
0B89:  ADDFSR 01,FSR0
0B8A:  MOVF   24,W
0B8B:  MOVWF  00
0B8C:  ADDFSR 01,FSR0
0B8D:  MOVF   25,W
0B8E:  MOVWF  00
0B8F:  ADDFSR 3D,FSR0
0B90:  MOVLB  0B
0B91:  MOVF   65,W
0B92:  BTFSC  03.2
0B93:  DECF   66,F
0B94:  DECF   65,F
0B95:  GOTO   33C
....................  
....................   //Now form a new RGB color 
....................   for(x = 0 ; x < 3 ; x++){ 
0B96:  CLRF   66
0B97:  CLRF   65
0B98:  MOVF   66,F
0B99:  BTFSS  03.2
0B9A:  GOTO   3B3
0B9B:  MOVF   65,W
0B9C:  SUBLW  02
0B9D:  BTFSS  03.0
0B9E:  GOTO   3B3
....................     new_color <<= 8; 
0B9F:  MOVF   69,W
0BA0:  MOVWF  6A
0BA1:  MOVF   68,W
0BA2:  MOVWF  69
0BA3:  MOVF   67,W
0BA4:  MOVWF  68
0BA5:  CLRF   67
....................     new_color |= rand(); //Give me a number from 0 to 0xFF 
0BA6:  MOVLP  00
0BA7:  MOVLB  00
0BA8:  CALL   3DC
0BA9:  MOVLP  08
0BAA:  MOVF   78,W
0BAB:  MOVLB  0B
0BAC:  IORWF  67,F
0BAD:  MOVF   79,W
0BAE:  IORWF  68,F
0BAF:  INCF   65,F
0BB0:  BTFSC  03.2
0BB1:  INCF   66,F
0BB2:  GOTO   398
....................   } 
....................   node_list[0] = new_color; //Add the new random color to the strip 
0BB3:  MOVF   6A,W
0BB4:  MOVLB  00
0BB5:  MOVWF  29
0BB6:  MOVLB  0B
0BB7:  MOVF   69,W
0BB8:  MOVLB  00
0BB9:  MOVWF  28
0BBA:  MOVLB  0B
0BBB:  MOVF   68,W
0BBC:  MOVLB  00
0BBD:  MOVWF  27
0BBE:  MOVLB  0B
0BBF:  MOVF   67,W
0BC0:  MOVLB  00
0BC1:  MOVWF  26
.................... } 
....................  
.................... // Create a 24 bit color value from R,G,B 
.................... int32 Color(int r, int g, int b){ 
....................   //Take the lowest 8bits of each value and append them end to end 
....................   	return( ((int32)(r & 0xFF)<<16) | ((int32)(g & 0xFF)<<8) | (int32)(b & 0xFF) ); 
*
01AE:  MOVLB  0C
01AF:  MOVF   26,W
01B0:  CLRF   2C
01B1:  CLRF   2B
01B2:  CLRF   2A
01B3:  MOVWF  29
01B4:  MOVF   2A,W
01B5:  MOVWF  2C
01B6:  MOVF   29,W
01B7:  MOVWF  2B
01B8:  CLRF   29
01B9:  CLRF   2A
01BA:  MOVF   27,W
01BB:  CLRF   31
01BC:  CLRF   30
01BD:  CLRF   2F
01BE:  MOVWF  2E
01BF:  MOVF   30,W
01C0:  MOVWF  7A
01C1:  MOVF   2F,W
01C2:  MOVWF  79
01C3:  MOVF   2E,W
01C4:  MOVWF  78
01C5:  CLRF   77
01C6:  MOVF   77,W
01C7:  IORWF  29,F
01C8:  MOVF   2E,W
01C9:  IORWF  2A,F
01CA:  MOVF   2F,W
01CB:  IORWF  2B,F
01CC:  MOVF   30,W
01CD:  IORWF  2C,F
01CE:  MOVF   28,W
01CF:  MOVWF  77
01D0:  CLRF   78
01D1:  CLRF   79
01D2:  CLRF   7A
01D3:  MOVF   28,W
01D4:  IORWF  29,W
01D5:  MOVWF  77
01D6:  MOVF   78,W
01D7:  IORWF  2A,W
01D8:  MOVWF  78
01D9:  MOVF   79,W
01DA:  IORWF  2B,W
01DB:  MOVWF  79
01DC:  MOVF   7A,W
01DD:  IORWF  2C,W
01DE:  MOVWF  7A
01DF:  MOVLB  00
01E0:  RETURN
.................... } 
....................  
.................... //Input a value 0 to 767 to get a color value. 
.................... //The colours are a transition r - g -b - back to r 
.................... int32 Wheel(int16 WheelPos){ 
....................   int16 r; 
....................   int16 g; 
....................   int16 b; 
....................   switch(WheelPos >> 8)  { 
*
0362:  MOVLB  0B
0363:  MOVF   6E,W
0364:  CLRF   7A
0365:  MOVWF  77
0366:  MOVF   7A,W
0367:  BTFSS  03.2
0368:  GOTO   36E
0369:  MOVF   77,F
036A:  MOVLB  00
036B:  BTFSC  03.2
036C:  GOTO   381
036D:  MOVLB  0B
036E:  MOVF   7A,W
036F:  BTFSS  03.2
0370:  GOTO   377
0371:  MOVLW  01
0372:  SUBWF  77,W
0373:  MOVLB  00
0374:  BTFSC  03.2
0375:  GOTO   394
0376:  MOVLB  0B
0377:  MOVF   7A,W
0378:  BTFSS  03.2
0379:  GOTO   380
037A:  MOVLW  02
037B:  SUBWF  77,W
037C:  MOVLB  00
037D:  BTFSC  03.2
037E:  GOTO   3A7
037F:  MOVLB  0B
0380:  GOTO   3B9
....................     case 0: 
....................       r=255- WheelPos % 256;   //Red down 
0381:  MOVLB  0B
0382:  CLRF   7A
0383:  MOVF   6D,W
0384:  SUBLW  FF
0385:  MOVLB  0C
0386:  MOVWF  20
0387:  MOVLW  00
0388:  MOVWF  21
0389:  MOVF   7A,W
038A:  SUBWFC 21,F
....................       g=WheelPos % 256;      // Green up 
038B:  MOVLB  0B
038C:  MOVF   6D,W
038D:  MOVLB  0C
038E:  MOVWF  22
038F:  CLRF   23
....................       b=0;                  //blue off 
0390:  CLRF   25
0391:  CLRF   24
....................       break; 
0392:  MOVLB  0B
0393:  GOTO   3B9
....................     case 1: 
....................       g=255- WheelPos % 256;  //green down 
0394:  MOVLB  0B
0395:  CLRF   7A
0396:  MOVF   6D,W
0397:  SUBLW  FF
0398:  MOVLB  0C
0399:  MOVWF  22
039A:  MOVLW  00
039B:  MOVWF  23
039C:  MOVF   7A,W
039D:  SUBWFC 23,F
....................       b=WheelPos % 256;      //blue up 
039E:  MOVLB  0B
039F:  MOVF   6D,W
03A0:  MOVLB  0C
03A1:  MOVWF  24
03A2:  CLRF   25
....................       r=0;                  //red off 
03A3:  CLRF   21
03A4:  CLRF   20
....................       break; 
03A5:  MOVLB  0B
03A6:  GOTO   3B9
....................     case 2: 
....................       b=255- WheelPos % 256;  //blue down 
03A7:  MOVLB  0B
03A8:  CLRF   7A
03A9:  MOVF   6D,W
03AA:  SUBLW  FF
03AB:  MOVLB  0C
03AC:  MOVWF  24
03AD:  MOVLW  00
03AE:  MOVWF  25
03AF:  MOVF   7A,W
03B0:  SUBWFC 25,F
....................       r=WheelPos % 256;      //red up 
03B1:  MOVLB  0B
03B2:  MOVF   6D,W
03B3:  MOVLB  0C
03B4:  MOVWF  20
03B5:  CLRF   21
....................       g=0;                  //green off 
03B6:  CLRF   23
03B7:  CLRF   22
....................       break; 
03B8:  MOVLB  0B
....................   } 
....................   return(Color(r,g,b)); 
03B9:  MOVLB  0C
03BA:  MOVF   20,W
03BB:  MOVWF  26
03BC:  MOVF   22,W
03BD:  MOVWF  27
03BE:  MOVF   24,W
03BF:  MOVWF  28
03C0:  MOVLB  00
03C1:  CALL   1AE
03C2:  RETURN
.................... } 
....................  
.................... int32 RandomColor() { 
....................     unsigned int16 x; 
....................     unsigned int32 new_color; 
....................  
....................     x = rand() % 767; 
....................     new_color = Wheel(x); 
....................  
....................     return new_color; 
.................... } 
....................  
....................  
.................... //make all LEDS one color (overloaded function) 
.................... void MakeAllColor(int32 color_set){ 
.................... 	int i; 
.................... 	for(i=0; i<TDOTS; i++) 
*
0320:  MOVLB  0B
0321:  CLRF   6E
0322:  MOVF   6E,F
0323:  BTFSS  03.2
0324:  GOTO   33B
.................... 	{ 
....................             node_list[i] = color_set; 
0325:  RLF    6E,W
0326:  MOVWF  77
0327:  RLF    77,F
0328:  MOVLW  FC
0329:  ANDWF  77,F
032A:  MOVF   77,W
032B:  ADDLW  06
032C:  MOVWF  04
032D:  MOVLW  20
032E:  MOVWF  05
032F:  BTFSC  03.0
0330:  INCF   05,F
0331:  MOVF   6A,W
0332:  MOVWF  00
0333:  MOVF   6B,W
0334:  MOVWI  W,[FSR0+01]
0335:  MOVF   6C,W
0336:  MOVWI  W,[FSR0+02]
0337:  MOVF   6D,W
0338:  MOVWI  W,[FSR0+03]
0339:  INCF   6E,F
033A:  GOTO   322
.................... 	} 
.................... 	send_frame(); 
033B:  MOVLB  00
033C:  CALL   233
033D:  RETURN
.................... } 
....................  
.................... //make all LEDS one color, overloaded to accept red, green blue inputs 
.................... void MakeAllColor(int red, int green, int blue) { 
.................... 	int i; 
.................... 	for(i=0; i<TDOTS; i++) 
.................... 	{ 
....................             node_list[i] = color(red, green, blue); 
.................... 	} 
.................... 	send_frame(); 
.................... } 
....................  
.................... void setup() { 
....................     int x; 
....................     //Clear out the array 
....................     for(x = 0; x < TDOTS ; x++){ 
*
06D5:  MOVLB  0A
06D6:  CLRF   6B
06D7:  MOVF   6B,F
06D8:  BTFSS  03.2
06D9:  GOTO   6EF
....................         node_list[x] = 0; 
06DA:  RLF    6B,W
06DB:  MOVWF  77
06DC:  RLF    77,F
06DD:  MOVLW  FC
06DE:  ANDWF  77,F
06DF:  MOVF   77,W
06E0:  ADDLW  06
06E1:  MOVWF  04
06E2:  MOVLW  20
06E3:  MOVWF  05
06E4:  BTFSC  03.0
06E5:  INCF   05,F
06E6:  CLRF   00
06E7:  ADDFSR 01,FSR0
06E8:  CLRF   00
06E9:  ADDFSR 01,FSR0
06EA:  CLRF   00
06EB:  ADDFSR 01,FSR0
06EC:  CLRF   00
06ED:  INCF   6B,F
06EE:  GOTO   6D7
....................     } 
....................     send_frame(); 
06EF:  MOVLB  00
06F0:  CALL   233
06F1:  MOVLP  10
06F2:  GOTO   708 (RETURN)
.................... } 
....................  
.................... void ShiftRight(int32 newval){ 
....................         int newPosition; 
.................... 	for(newPosition = (TDOTS)-1; newPosition > 0; newPosition--) { 
*
0451:  MOVLB  0C
0452:  CLRF   28
0453:  MOVF   28,F
0454:  BTFSC  03.2
0455:  GOTO   496
....................             node_list[newPosition] = node_list[newPosition - 1]; 
0456:  RLF    28,W
0457:  MOVWF  77
0458:  RLF    77,F
0459:  MOVLW  FC
045A:  ANDWF  77,F
045B:  MOVF   77,W
045C:  ADDLW  06
045D:  MOVWF  78
045E:  MOVLW  20
045F:  MOVWF  7A
0460:  BTFSC  03.0
0461:  INCF   7A,F
0462:  MOVF   78,W
0463:  MOVWF  29
0464:  MOVF   7A,W
0465:  MOVWF  2A
0466:  MOVLW  01
0467:  SUBWF  28,W
0468:  MOVWF  77
0469:  RLF    77,F
046A:  RLF    77,F
046B:  MOVLW  FC
046C:  ANDWF  77,F
046D:  MOVF   77,W
046E:  ADDLW  06
046F:  MOVWF  04
0470:  MOVLW  20
0471:  MOVWF  05
0472:  BTFSC  03.0
0473:  INCF   05,F
0474:  MOVF   00,W
0475:  MOVWF  77
0476:  ADDFSR 01,FSR0
0477:  MOVF   00,W
0478:  MOVWF  78
0479:  ADDFSR 01,FSR0
047A:  MOVF   00,W
047B:  MOVWF  79
047C:  ADDFSR 01,FSR0
047D:  MOVF   00,W
047E:  MOVWF  7A
047F:  ADDFSR 3D,FSR0
0480:  MOVF   7A,W
0481:  MOVWF  2E
0482:  MOVF   79,W
0483:  MOVWF  2D
0484:  MOVF   78,W
0485:  MOVWF  2C
0486:  MOVF   77,W
0487:  MOVWF  2B
0488:  MOVF   2A,W
0489:  MOVWF  05
048A:  MOVF   29,W
048B:  MOVWF  04
048C:  MOVF   2B,W
048D:  MOVWF  00
048E:  MOVF   2C,W
048F:  MOVWI  W,[FSR0+01]
0490:  MOVF   2D,W
0491:  MOVWI  W,[FSR0+02]
0492:  MOVF   2E,W
0493:  MOVWI  W,[FSR0+03]
0494:  DECF   28,F
0495:  GOTO   453
.................... 	} 
.................... 	node_list[0] = newval; // fill the gap 
0496:  MOVF   27,W
0497:  MOVLB  00
0498:  MOVWF  29
0499:  MOVLB  0C
049A:  MOVF   26,W
049B:  MOVLB  00
049C:  MOVWF  28
049D:  MOVLB  0C
049E:  MOVF   25,W
049F:  MOVLB  00
04A0:  MOVWF  27
04A1:  MOVLB  0C
04A2:  MOVF   24,W
04A3:  MOVLB  00
04A4:  MOVWF  26
04A5:  RETURN
.................... } 
....................  
.................... void ShiftLeft(int32 newval){ 
....................         int newPosition; 
.................... 	for(newPosition = 0; newPosition < (TDOTS - 1); newPosition++) { 
....................             node_list[newPosition] = node_list[newPosition + 1]; 
.................... 	} 
.................... 	node_list[TDOTS - 1] = newval; // fill the gap 
.................... } 
....................  
.................... #include "LED_Patterns.c" 
.................... //FILE NAME = LED_Patterns.h 
.................... // A Collection of patterns to run using WS2801 leds using the RTOS system 
....................  
.................... void MakeAllRed(){ 
....................     MakeAllColor(Color(255,0,0)); 
*
08DB:  MOVLW  FF
08DC:  MOVLB  0C
08DD:  MOVWF  26
08DE:  CLRF   27
08DF:  CLRF   28
08E0:  MOVLP  00
08E1:  MOVLB  00
08E2:  CALL   1AE
08E3:  MOVLP  08
08E4:  MOVF   7A,W
08E5:  MOVLB  0B
08E6:  MOVWF  68
08E7:  MOVF   79,W
08E8:  MOVWF  67
08E9:  MOVF   78,W
08EA:  MOVWF  66
08EB:  MOVF   77,W
08EC:  MOVWF  65
08ED:  MOVF   68,W
08EE:  MOVWF  6D
08EF:  MOVF   67,W
08F0:  MOVWF  6C
08F1:  MOVF   66,W
08F2:  MOVWF  6B
08F3:  MOVF   65,W
08F4:  MOVWF  6A
08F5:  MOVLP  00
08F6:  MOVLB  00
08F7:  CALL   320
08F8:  MOVLP  08
.................... } 
....................  
.................... void MakeAllGreen(){ 
....................     MakeAllColor(Color(0, 255, 0)); 
*
08FC:  MOVLB  0C
08FD:  CLRF   26
08FE:  MOVLW  FF
08FF:  MOVWF  27
0900:  CLRF   28
0901:  MOVLP  00
0902:  MOVLB  00
0903:  CALL   1AE
0904:  MOVLP  08
0905:  MOVF   7A,W
0906:  MOVLB  0B
0907:  MOVWF  68
0908:  MOVF   79,W
0909:  MOVWF  67
090A:  MOVF   78,W
090B:  MOVWF  66
090C:  MOVF   77,W
090D:  MOVWF  65
090E:  MOVF   68,W
090F:  MOVWF  6D
0910:  MOVF   67,W
0911:  MOVWF  6C
0912:  MOVF   66,W
0913:  MOVWF  6B
0914:  MOVF   65,W
0915:  MOVWF  6A
0916:  MOVLP  00
0917:  MOVLB  00
0918:  CALL   320
0919:  MOVLP  08
.................... } 
....................  
.................... void MakeAllBlue(){ 
....................     MakeAllColor(Color(0, 0, 255)); 
*
091D:  MOVLB  0C
091E:  CLRF   26
091F:  CLRF   27
0920:  MOVLW  FF
0921:  MOVWF  28
0922:  MOVLP  00
0923:  MOVLB  00
0924:  CALL   1AE
0925:  MOVLP  08
0926:  MOVF   7A,W
0927:  MOVLB  0B
0928:  MOVWF  68
0929:  MOVF   79,W
092A:  MOVWF  67
092B:  MOVF   78,W
092C:  MOVWF  66
092D:  MOVF   77,W
092E:  MOVWF  65
092F:  MOVF   68,W
0930:  MOVWF  6D
0931:  MOVF   67,W
0932:  MOVWF  6C
0933:  MOVF   66,W
0934:  MOVWF  6B
0935:  MOVF   65,W
0936:  MOVWF  6A
0937:  MOVLP  00
0938:  MOVLB  00
0939:  CALL   320
093A:  MOVLP  08
.................... } 
....................  
.................... void MakeAllWhite(){ 
....................     MakeAllColor(Color(255, 255, 255)); 
*
0E0A:  MOVLW  FF
0E0B:  MOVLB  0C
0E0C:  MOVWF  26
0E0D:  MOVWF  27
0E0E:  MOVWF  28
0E0F:  MOVLP  00
0E10:  MOVLB  00
0E11:  CALL   1AE
0E12:  MOVLP  08
0E13:  MOVF   7A,W
0E14:  MOVLB  0B
0E15:  MOVWF  68
0E16:  MOVF   79,W
0E17:  MOVWF  67
0E18:  MOVF   78,W
0E19:  MOVWF  66
0E1A:  MOVF   77,W
0E1B:  MOVWF  65
0E1C:  MOVF   68,W
0E1D:  MOVWF  6D
0E1E:  MOVF   67,W
0E1F:  MOVWF  6C
0E20:  MOVF   66,W
0E21:  MOVWF  6B
0E22:  MOVF   65,W
0E23:  MOVWF  6A
0E24:  MOVLP  00
0E25:  MOVLB  00
0E26:  CALL   320
0E27:  MOVLP  08
.................... } 
....................  
.................... void All_Rainbow_Fade_200ms() { 
....................     //Slow fade all colors       
....................     if (pattern_position[0] < 768) { 
*
093F:  MOVF   2F,W
0940:  SUBLW  02
0941:  BTFSS  03.0
0942:  GOTO   1B1
....................         if (Timer_Get_Timer(0) > 200) { 
0943:  MOVLB  0C
0944:  CLRF   20
0945:  MOVLP  00
0946:  MOVLB  00
0947:  CALL   33E
0948:  MOVLP  08
0949:  MOVF   7A,W
094A:  MOVLB  0B
094B:  MOVWF  68
094C:  MOVF   79,W
094D:  MOVWF  67
094E:  MOVF   78,W
094F:  MOVWF  66
0950:  MOVF   77,W
0951:  MOVWF  65
0952:  MOVF   68,F
0953:  BTFSS  03.2
0954:  GOTO   15F
0955:  MOVF   67,F
0956:  BTFSS  03.2
0957:  GOTO   15F
0958:  MOVF   66,F
0959:  BTFSS  03.2
095A:  GOTO   15F
095B:  MOVF   65,W
095C:  SUBLW  C8
095D:  BTFSC  03.0
095E:  GOTO   1AF
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
095F:  MOVLW  3A
0960:  MOVLB  03
0961:  MOVWF  11
0962:  MOVLW  00
0963:  MOVWF  12
0964:  BCF    03.0
0965:  MOVLW  13
0966:  MOVLB  0B
0967:  MOVWF  6B
0968:  MOVLP  00
0969:  MOVLB  00
096A:  CALL   0F2
096B:  MOVLP  08
096C:  MOVLW  10
096D:  MOVWF  04
096E:  MOVF   2F,W
096F:  MOVLB  0B
0970:  MOVWF  6C
0971:  MOVLB  00
0972:  MOVF   2E,W
0973:  MOVLB  0B
0974:  MOVWF  6B
0975:  MOVLP  00
0976:  MOVLB  00
0977:  CALL   149
0978:  MOVLP  08
0979:  MOVLW  0A
097A:  BTFSS  11.4
097B:  GOTO   17A
097C:  MOVLB  03
097D:  MOVWF  1A
097E:  MOVLW  0D
097F:  MOVLB  00
0980:  BTFSS  11.4
0981:  GOTO   180
0982:  MOVLB  03
0983:  MOVWF  1A
.................... #endif 
....................             MakeAllColor(Wheel(pattern_position[0])); 
0984:  MOVLB  00
0985:  MOVF   2F,W
0986:  MOVLB  0B
0987:  MOVWF  6E
0988:  MOVLB  00
0989:  MOVF   2E,W
098A:  MOVLB  0B
098B:  MOVWF  6D
098C:  MOVLP  00
098D:  MOVLB  00
098E:  CALL   362
098F:  MOVLP  08
0990:  MOVF   7A,W
0991:  MOVLB  0B
0992:  MOVWF  68
0993:  MOVF   79,W
0994:  MOVWF  67
0995:  MOVF   78,W
0996:  MOVWF  66
0997:  MOVF   77,W
0998:  MOVWF  65
0999:  MOVF   68,W
099A:  MOVWF  6D
099B:  MOVF   67,W
099C:  MOVWF  6C
099D:  MOVF   66,W
099E:  MOVWF  6B
099F:  MOVF   65,W
09A0:  MOVWF  6A
09A1:  MOVLP  00
09A2:  MOVLB  00
09A3:  CALL   320
09A4:  MOVLP  08
....................             pattern_position[0]++; 
09A5:  INCF   2E,F
09A6:  BTFSC  03.2
09A7:  INCF   2F,F
....................             Timer_Clear_Timer(0); 
09A8:  MOVLB  0C
09A9:  CLRF   20
09AA:  MOVLP  00
09AB:  MOVLB  00
09AC:  CALL   3C3
09AD:  MOVLP  08
09AE:  MOVLB  0B
....................         } 
....................     } else { 
09AF:  GOTO   1B4
09B0:  MOVLB  00
....................         pattern_position[0] = 0; 
09B1:  CLRF   2F
09B2:  CLRF   2E
09B3:  MOVLB  0B
....................     } 
.................... } 
....................  
.................... void Dot_Rainbow_Fade() { 
....................     int16 i; 
....................     int32 temp_color; 
....................     // 3 cycles of all 768 colors in the wheel 
....................     if (pattern_position[0] < 768) { 
*
09B8:  MOVF   2F,W
09B9:  SUBLW  02
09BA:  BTFSS  03.0
09BB:  GOTO   285
....................         if (Timer_Get_Timer(0) > delay_time_ms) { 
09BC:  MOVLB  0C
09BD:  CLRF   20
09BE:  MOVLP  00
09BF:  MOVLB  00
09C0:  CALL   33E
09C1:  MOVLP  08
09C2:  MOVF   7A,W
09C3:  MOVLB  0B
09C4:  MOVWF  6E
09C5:  MOVF   79,W
09C6:  MOVWF  6D
09C7:  MOVF   78,W
09C8:  MOVWF  6C
09C9:  MOVF   77,W
09CA:  MOVWF  6B
09CB:  MOVF   6E,F
09CC:  BTFSS  03.2
09CD:  GOTO   1E1
09CE:  MOVF   6D,F
09CF:  BTFSS  03.2
09D0:  GOTO   1E1
09D1:  MOVLB  00
09D2:  MOVF   3B,W
09D3:  MOVLB  0B
09D4:  SUBWF  6C,W
09D5:  BTFSS  03.0
09D6:  GOTO   283
09D7:  BTFSS  03.2
09D8:  GOTO   1E1
09D9:  MOVF   6B,W
09DA:  MOVLB  00
09DB:  SUBWF  3A,W
09DC:  BTFSS  03.0
09DD:  GOTO   1E0
09DE:  MOVLB  0B
09DF:  GOTO   283
09E0:  MOVLB  0B
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
09E1:  MOVLW  47
09E2:  MOVLB  03
09E3:  MOVWF  11
09E4:  MOVLW  00
09E5:  MOVWF  12
09E6:  BCF    03.0
09E7:  MOVLW  13
09E8:  MOVLB  0B
09E9:  MOVWF  6B
09EA:  MOVLP  00
09EB:  MOVLB  00
09EC:  CALL   0F2
09ED:  MOVLP  08
09EE:  MOVLW  10
09EF:  MOVWF  04
09F0:  MOVF   2F,W
09F1:  MOVLB  0B
09F2:  MOVWF  6C
09F3:  MOVLB  00
09F4:  MOVF   2E,W
09F5:  MOVLB  0B
09F6:  MOVWF  6B
09F7:  MOVLP  00
09F8:  MOVLB  00
09F9:  CALL   149
09FA:  MOVLP  08
09FB:  MOVLW  0A
09FC:  BTFSS  11.4
09FD:  GOTO   1FC
09FE:  MOVLB  03
09FF:  MOVWF  1A
0A00:  MOVLW  0D
0A01:  MOVLB  00
0A02:  BTFSS  11.4
0A03:  GOTO   202
0A04:  MOVLB  03
0A05:  MOVWF  1A
.................... #endif 
....................             for (i = 0; i < TDOTS; i++) { 
0A06:  MOVLB  0B
0A07:  CLRF   66
0A08:  CLRF   65
0A09:  MOVF   65,F
0A0A:  BTFSS  03.2
0A0B:  GOTO   275
0A0C:  MOVF   66,F
0A0D:  BTFSS  03.2
0A0E:  GOTO   275
....................                 temp_color = Wheel(((i * 20) + (pattern_position[0] * 10)) % 768); 
0A0F:  MOVF   66,W
0A10:  MOVLB  0C
0A11:  MOVWF  29
0A12:  MOVLB  0B
0A13:  MOVF   65,W
0A14:  MOVLB  0C
0A15:  MOVWF  28
0A16:  CLRF   2B
0A17:  MOVLW  14
0A18:  MOVWF  2A
0A19:  MOVLP  00
0A1A:  MOVLB  00
0A1B:  CALL   1E1
0A1C:  MOVLP  08
0A1D:  MOVF   79,W
0A1E:  MOVLB  0B
0A1F:  MOVWF  6C
0A20:  MOVF   78,W
0A21:  MOVWF  6B
0A22:  MOVLB  00
0A23:  MOVF   2F,W
0A24:  MOVLB  0C
0A25:  MOVWF  29
0A26:  MOVLB  00
0A27:  MOVF   2E,W
0A28:  MOVLB  0C
0A29:  MOVWF  28
0A2A:  CLRF   2B
0A2B:  MOVLW  0A
0A2C:  MOVWF  2A
0A2D:  MOVLP  00
0A2E:  MOVLB  00
0A2F:  CALL   1E1
0A30:  MOVLP  08
0A31:  MOVF   79,W
0A32:  MOVWF  7A
0A33:  MOVF   78,W
0A34:  MOVLB  0B
0A35:  ADDWF  6B,F
0A36:  MOVF   79,W
0A37:  ADDWFC 6C,F
0A38:  MOVF   6C,W
0A39:  MOVLB  0C
0A3A:  MOVWF  2B
0A3B:  MOVLB  0B
0A3C:  MOVF   6B,W
0A3D:  MOVLB  0C
0A3E:  MOVWF  2A
0A3F:  MOVLW  03
0A40:  MOVWF  2D
0A41:  CLRF   2C
0A42:  MOVLP  00
0A43:  MOVLB  00
0A44:  CALL   1F8
0A45:  MOVLP  08
0A46:  MOVF   77,W
0A47:  MOVLB  0B
0A48:  MOVWF  6B
0A49:  MOVF   7A,W
0A4A:  MOVWF  6C
0A4B:  MOVWF  6E
0A4C:  MOVF   6B,W
0A4D:  MOVWF  6D
0A4E:  MOVLP  00
0A4F:  MOVLB  00
0A50:  CALL   362
0A51:  MOVLP  08
0A52:  MOVF   7A,W
0A53:  MOVLB  0B
0A54:  MOVWF  6A
0A55:  MOVF   79,W
0A56:  MOVWF  69
0A57:  MOVF   78,W
0A58:  MOVWF  68
0A59:  MOVF   77,W
0A5A:  MOVWF  67
....................                 node_list[i] = temp_color; 
0A5B:  RLF    65,W
0A5C:  MOVWF  79
0A5D:  RLF    66,W
0A5E:  MOVWF  7A
0A5F:  RLF    79,F
0A60:  RLF    7A,F
0A61:  MOVLW  FC
0A62:  ANDWF  79,F
0A63:  MOVF   79,W
0A64:  ADDLW  06
0A65:  MOVWF  04
0A66:  MOVLW  20
0A67:  ADDWFC 7A,W
0A68:  MOVWF  05
0A69:  MOVF   67,W
0A6A:  MOVWF  00
0A6B:  MOVF   68,W
0A6C:  MOVWI  W,[FSR0+01]
0A6D:  MOVF   69,W
0A6E:  MOVWI  W,[FSR0+02]
0A6F:  MOVF   6A,W
0A70:  MOVWI  W,[FSR0+03]
0A71:  INCF   65,F
0A72:  BTFSC  03.2
0A73:  INCF   66,F
0A74:  GOTO   209
....................             } 
....................             send_frame(); 
0A75:  MOVLP  00
0A76:  MOVLB  00
0A77:  CALL   233
0A78:  MOVLP  08
....................             pattern_position[0]++; 
0A79:  INCF   2E,F
0A7A:  BTFSC  03.2
0A7B:  INCF   2F,F
....................             Timer_Clear_Timer(0); 
0A7C:  MOVLB  0C
0A7D:  CLRF   20
0A7E:  MOVLP  00
0A7F:  MOVLB  00
0A80:  CALL   3C3
0A81:  MOVLP  08
0A82:  MOVLB  0B
....................         } 
....................     } else { 
0A83:  GOTO   288
0A84:  MOVLB  00
....................         pattern_position[0] = 0; 
0A85:  CLRF   2F
0A86:  CLRF   2E
0A87:  MOVLB  0B
....................     } 
.................... } 
....................  
.................... void All_Rainbow_Fade() { 
....................     //Slow fade all colors 
....................     if (pattern_position[0] < 768) { 
*
0A8C:  MOVF   2F,W
0A8D:  SUBLW  02
0A8E:  BTFSS  03.0
0A8F:  GOTO   307
....................         if (Timer_Get_Timer(0) > delay_time_ms) { 
0A90:  MOVLB  0C
0A91:  CLRF   20
0A92:  MOVLP  00
0A93:  MOVLB  00
0A94:  CALL   33E
0A95:  MOVLP  08
0A96:  MOVF   7A,W
0A97:  MOVLB  0B
0A98:  MOVWF  68
0A99:  MOVF   79,W
0A9A:  MOVWF  67
0A9B:  MOVF   78,W
0A9C:  MOVWF  66
0A9D:  MOVF   77,W
0A9E:  MOVWF  65
0A9F:  MOVF   68,F
0AA0:  BTFSS  03.2
0AA1:  GOTO   2B5
0AA2:  MOVF   67,F
0AA3:  BTFSS  03.2
0AA4:  GOTO   2B5
0AA5:  MOVLB  00
0AA6:  MOVF   3B,W
0AA7:  MOVLB  0B
0AA8:  SUBWF  66,W
0AA9:  BTFSS  03.0
0AAA:  GOTO   305
0AAB:  BTFSS  03.2
0AAC:  GOTO   2B5
0AAD:  MOVF   65,W
0AAE:  MOVLB  00
0AAF:  SUBWF  3A,W
0AB0:  BTFSS  03.0
0AB1:  GOTO   2B4
0AB2:  MOVLB  0B
0AB3:  GOTO   305
0AB4:  MOVLB  0B
.................... #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position = %Lu\n\r", pattern_position[0]); 
0AB5:  MOVLW  54
0AB6:  MOVLB  03
0AB7:  MOVWF  11
0AB8:  MOVLW  00
0AB9:  MOVWF  12
0ABA:  BCF    03.0
0ABB:  MOVLW  13
0ABC:  MOVLB  0B
0ABD:  MOVWF  6B
0ABE:  MOVLP  00
0ABF:  MOVLB  00
0AC0:  CALL   0F2
0AC1:  MOVLP  08
0AC2:  MOVLW  10
0AC3:  MOVWF  04
0AC4:  MOVF   2F,W
0AC5:  MOVLB  0B
0AC6:  MOVWF  6C
0AC7:  MOVLB  00
0AC8:  MOVF   2E,W
0AC9:  MOVLB  0B
0ACA:  MOVWF  6B
0ACB:  MOVLP  00
0ACC:  MOVLB  00
0ACD:  CALL   149
0ACE:  MOVLP  08
0ACF:  MOVLW  0A
0AD0:  BTFSS  11.4
0AD1:  GOTO   2D0
0AD2:  MOVLB  03
0AD3:  MOVWF  1A
0AD4:  MOVLW  0D
0AD5:  MOVLB  00
0AD6:  BTFSS  11.4
0AD7:  GOTO   2D6
0AD8:  MOVLB  03
0AD9:  MOVWF  1A
.................... #endif 
....................             MakeAllColor(Wheel(pattern_position[0])); 
0ADA:  MOVLB  00
0ADB:  MOVF   2F,W
0ADC:  MOVLB  0B
0ADD:  MOVWF  6E
0ADE:  MOVLB  00
0ADF:  MOVF   2E,W
0AE0:  MOVLB  0B
0AE1:  MOVWF  6D
0AE2:  MOVLP  00
0AE3:  MOVLB  00
0AE4:  CALL   362
0AE5:  MOVLP  08
0AE6:  MOVF   7A,W
0AE7:  MOVLB  0B
0AE8:  MOVWF  68
0AE9:  MOVF   79,W
0AEA:  MOVWF  67
0AEB:  MOVF   78,W
0AEC:  MOVWF  66
0AED:  MOVF   77,W
0AEE:  MOVWF  65
0AEF:  MOVF   68,W
0AF0:  MOVWF  6D
0AF1:  MOVF   67,W
0AF2:  MOVWF  6C
0AF3:  MOVF   66,W
0AF4:  MOVWF  6B
0AF5:  MOVF   65,W
0AF6:  MOVWF  6A
0AF7:  MOVLP  00
0AF8:  MOVLB  00
0AF9:  CALL   320
0AFA:  MOVLP  08
....................             pattern_position[0]++; 
0AFB:  INCF   2E,F
0AFC:  BTFSC  03.2
0AFD:  INCF   2F,F
....................             Timer_Clear_Timer(0); 
0AFE:  MOVLB  0C
0AFF:  CLRF   20
0B00:  MOVLP  00
0B01:  MOVLB  00
0B02:  CALL   3C3
0B03:  MOVLP  08
0B04:  MOVLB  0B
....................         } 
....................     } else { 
0B05:  GOTO   30A
0B06:  MOVLB  00
....................         pattern_position[0] = 0; 
0B07:  CLRF   2F
0B08:  CLRF   2E
0B09:  MOVLB  0B
....................     } 
.................... } 
....................  
.................... void Random_Chain() { 
....................     //Start with random colors then push random colors down 
....................     if (Timer_Get_Timer(0) > delay_time_ms*2) { 
*
0B0E:  MOVLB  0C
0B0F:  CLRF   20
0B10:  MOVLP  00
0B11:  MOVLB  00
0B12:  CALL   33E
0B13:  MOVLP  08
0B14:  MOVF   7A,W
0B15:  MOVLB  0B
0B16:  MOVWF  68
0B17:  MOVF   79,W
0B18:  MOVWF  67
0B19:  MOVF   78,W
0B1A:  MOVWF  66
0B1B:  MOVF   77,W
0B1C:  MOVWF  65
0B1D:  BCF    03.0
0B1E:  MOVLB  00
0B1F:  RLF    3A,W
0B20:  MOVWF  79
0B21:  RLF    3B,W
0B22:  MOVWF  7A
0B23:  MOVF   79,W
0B24:  MOVWF  78
0B25:  MOVLB  0B
0B26:  MOVF   68,F
0B27:  BTFSS  03.2
0B28:  GOTO   336
0B29:  MOVF   67,F
0B2A:  BTFSS  03.2
0B2B:  GOTO   336
0B2C:  MOVF   7A,W
0B2D:  SUBWF  66,W
0B2E:  BTFSS  03.0
0B2F:  GOTO   3CC
0B30:  BTFSS  03.2
0B31:  GOTO   336
0B32:  MOVF   65,W
0B33:  SUBWF  78,W
0B34:  BTFSC  03.0
0B35:  GOTO   3CC
....................         addRandom(); 
....................         send_frame(); 
*
0BC2:  MOVLP  00
0BC3:  CALL   233
0BC4:  MOVLP  08
....................         Timer_Clear_Timer(0); 
0BC5:  MOVLB  0C
0BC6:  CLRF   20
0BC7:  MOVLP  00
0BC8:  MOVLB  00
0BC9:  CALL   3C3
0BCA:  MOVLP  08
0BCB:  MOVLB  0B
....................     } 
.................... } 
....................  
.................... //push in 3 leds of color selected than shift it 1 led each time, 3 blanks 
.................... void ShiftThreeColorThreeBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
04A6:  MOVLB  0C
04A7:  CLRF   20
04A8:  MOVLB  00
04A9:  CALL   33E
04AA:  MOVF   7A,W
04AB:  MOVLB  0C
04AC:  MOVWF  23
04AD:  MOVF   79,W
04AE:  MOVWF  22
04AF:  MOVF   78,W
04B0:  MOVWF  21
04B1:  MOVF   77,W
04B2:  MOVWF  20
04B3:  MOVF   23,F
04B4:  BTFSS  03.2
04B5:  GOTO   4C9
04B6:  MOVF   22,F
04B7:  BTFSS  03.2
04B8:  GOTO   4C9
04B9:  MOVLB  00
04BA:  MOVF   3B,W
04BB:  MOVLB  0C
04BC:  SUBWF  21,W
04BD:  BTFSS  03.0
04BE:  GOTO   520
04BF:  BTFSS  03.2
04C0:  GOTO   4C9
04C1:  MOVF   20,W
04C2:  MOVLB  00
04C3:  SUBWF  3A,W
04C4:  BTFSS  03.0
04C5:  GOTO   4C8
04C6:  MOVLB  0C
04C7:  GOTO   520
04C8:  MOVLB  0C
....................         if (pattern_position[0] >= 6) { 
04C9:  MOVLB  00
04CA:  MOVF   2F,F
04CB:  BTFSS  03.2
04CC:  GOTO   4D1
04CD:  MOVF   2E,W
04CE:  SUBLW  05
04CF:  BTFSC  03.0
04D0:  GOTO   4D3
....................             pattern_position[0] = 0; 
04D1:  CLRF   2F
04D2:  CLRF   2E
....................         } 
....................         if (pattern_position[0] % 6 < 3) { 
04D3:  MOVF   2F,W
04D4:  MOVLB  0C
04D5:  MOVWF  2B
04D6:  MOVLB  00
04D7:  MOVF   2E,W
04D8:  MOVLB  0C
04D9:  MOVWF  2A
04DA:  CLRF   2D
04DB:  MOVLW  06
04DC:  MOVWF  2C
04DD:  MOVLB  00
04DE:  CALL   1F8
04DF:  MOVF   77,W
04E0:  MOVLB  0C
04E1:  MOVWF  20
04E2:  MOVF   7A,W
04E3:  MOVWF  21
04E4:  MOVF   21,F
04E5:  BTFSS  03.2
04E6:  GOTO   4FF
04E7:  MOVF   20,W
04E8:  SUBLW  02
04E9:  BTFSS  03.0
04EA:  GOTO   4FF
....................             ShiftRight(color_set); 
04EB:  MOVLB  0B
04EC:  MOVF   6C,W
04ED:  MOVLB  0C
04EE:  MOVWF  27
04EF:  MOVLB  0B
04F0:  MOVF   6B,W
04F1:  MOVLB  0C
04F2:  MOVWF  26
04F3:  MOVLB  0B
04F4:  MOVF   6A,W
04F5:  MOVLB  0C
04F6:  MOVWF  25
04F7:  MOVLB  0B
04F8:  MOVF   69,W
04F9:  MOVLB  0C
04FA:  MOVWF  24
04FB:  MOVLB  00
04FC:  CALL   451
....................         } else { 
04FD:  GOTO   517
04FE:  MOVLB  0C
....................             ShiftRight(color(0, 0, 0)); 
04FF:  CLRF   26
0500:  CLRF   27
0501:  CLRF   28
0502:  MOVLB  00
0503:  CALL   1AE
0504:  MOVF   7A,W
0505:  MOVLB  0C
0506:  MOVWF  23
0507:  MOVF   79,W
0508:  MOVWF  22
0509:  MOVF   78,W
050A:  MOVWF  21
050B:  MOVF   77,W
050C:  MOVWF  20
050D:  MOVF   23,W
050E:  MOVWF  27
050F:  MOVF   22,W
0510:  MOVWF  26
0511:  MOVF   21,W
0512:  MOVWF  25
0513:  MOVF   20,W
0514:  MOVWF  24
0515:  MOVLB  00
0516:  CALL   451
....................         } 
....................         send_frame(); 
0517:  CALL   233
....................         pattern_position[0]++; 
0518:  INCF   2E,F
0519:  BTFSC  03.2
051A:  INCF   2F,F
....................         Timer_Clear_Timer(0); 
051B:  MOVLB  0C
051C:  CLRF   20
051D:  MOVLB  00
051E:  CALL   3C3
051F:  MOVLB  0C
....................     } 
0520:  MOVLB  00
0521:  RETURN
.................... } 
....................  
.................... //push in 1 leds of color selected than shift it 1 led each time, 1 blank 
.................... void ShiftOneColorOneBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
0C67:  MOVLB  0C
0C68:  CLRF   20
0C69:  MOVLP  00
0C6A:  MOVLB  00
0C6B:  CALL   33E
0C6C:  MOVLP  08
0C6D:  MOVF   7A,W
0C6E:  MOVLB  0C
0C6F:  MOVWF  23
0C70:  MOVF   79,W
0C71:  MOVWF  22
0C72:  MOVF   78,W
0C73:  MOVWF  21
0C74:  MOVF   77,W
0C75:  MOVWF  20
0C76:  MOVF   23,F
0C77:  BTFSS  03.2
0C78:  GOTO   48C
0C79:  MOVF   22,F
0C7A:  BTFSS  03.2
0C7B:  GOTO   48C
0C7C:  MOVLB  00
0C7D:  MOVF   3B,W
0C7E:  MOVLB  0C
0C7F:  SUBWF  21,W
0C80:  BTFSS  03.0
0C81:  GOTO   4E0
0C82:  BTFSS  03.2
0C83:  GOTO   48C
0C84:  MOVF   20,W
0C85:  MOVLB  00
0C86:  SUBWF  3A,W
0C87:  BTFSS  03.0
0C88:  GOTO   48B
0C89:  MOVLB  0C
0C8A:  GOTO   4E0
0C8B:  MOVLB  0C
....................         if (pattern_position[0] >= 2) { 
0C8C:  MOVLB  00
0C8D:  MOVF   2F,F
0C8E:  BTFSS  03.2
0C8F:  GOTO   494
0C90:  MOVF   2E,W
0C91:  SUBLW  01
0C92:  BTFSC  03.0
0C93:  GOTO   496
....................             pattern_position[0] = 0; 
0C94:  CLRF   2F
0C95:  CLRF   2E
....................         } 
....................         if (pattern_position[0] % 2 < 1) { 
0C96:  MOVF   2E,W
0C97:  ANDLW  01
0C98:  MOVLB  0C
0C99:  MOVWF  20
0C9A:  CLRF   21
0C9B:  MOVF   20,F
0C9C:  BTFSS  03.2
0C9D:  GOTO   4B7
0C9E:  MOVF   21,F
0C9F:  BTFSS  03.2
0CA0:  GOTO   4B7
....................             ShiftRight(color_set); 
0CA1:  MOVLB  0B
0CA2:  MOVF   6C,W
0CA3:  MOVLB  0C
0CA4:  MOVWF  27
0CA5:  MOVLB  0B
0CA6:  MOVF   6B,W
0CA7:  MOVLB  0C
0CA8:  MOVWF  26
0CA9:  MOVLB  0B
0CAA:  MOVF   6A,W
0CAB:  MOVLB  0C
0CAC:  MOVWF  25
0CAD:  MOVLB  0B
0CAE:  MOVF   69,W
0CAF:  MOVLB  0C
0CB0:  MOVWF  24
0CB1:  MOVLP  00
0CB2:  MOVLB  00
0CB3:  CALL   451
0CB4:  MOVLP  08
....................         } else { 
0CB5:  GOTO   4D3
0CB6:  MOVLB  0C
....................             ShiftRight(color(0, 0, 0)); 
0CB7:  CLRF   26
0CB8:  CLRF   27
0CB9:  CLRF   28
0CBA:  MOVLP  00
0CBB:  MOVLB  00
0CBC:  CALL   1AE
0CBD:  MOVLP  08
0CBE:  MOVF   7A,W
0CBF:  MOVLB  0C
0CC0:  MOVWF  23
0CC1:  MOVF   79,W
0CC2:  MOVWF  22
0CC3:  MOVF   78,W
0CC4:  MOVWF  21
0CC5:  MOVF   77,W
0CC6:  MOVWF  20
0CC7:  MOVF   23,W
0CC8:  MOVWF  27
0CC9:  MOVF   22,W
0CCA:  MOVWF  26
0CCB:  MOVF   21,W
0CCC:  MOVWF  25
0CCD:  MOVF   20,W
0CCE:  MOVWF  24
0CCF:  MOVLP  00
0CD0:  MOVLB  00
0CD1:  CALL   451
0CD2:  MOVLP  08
....................         } 
....................         send_frame(); 
0CD3:  MOVLP  00
0CD4:  CALL   233
0CD5:  MOVLP  08
....................         pattern_position[0]++; 
0CD6:  INCF   2E,F
0CD7:  BTFSC  03.2
0CD8:  INCF   2F,F
....................         Timer_Clear_Timer(0); 
0CD9:  MOVLB  0C
0CDA:  CLRF   20
0CDB:  MOVLP  00
0CDC:  MOVLB  00
0CDD:  CALL   3C3
0CDE:  MOVLP  08
0CDF:  MOVLB  0C
....................     } 
.................... } 
....................  
.................... //push in 1 leds of color selected than shift it 1 led each time, 1 blank 
.................... void ShiftOneColorTwoBlank(int32 color_set) { 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
0CFE:  MOVLB  0C
0CFF:  CLRF   20
0D00:  MOVLP  00
0D01:  MOVLB  00
0D02:  CALL   33E
0D03:  MOVLP  08
0D04:  MOVF   7A,W
0D05:  MOVLB  0C
0D06:  MOVWF  23
0D07:  MOVF   79,W
0D08:  MOVWF  22
0D09:  MOVF   78,W
0D0A:  MOVWF  21
0D0B:  MOVF   77,W
0D0C:  MOVWF  20
0D0D:  MOVF   23,F
0D0E:  BTFSS  03.2
0D0F:  GOTO   523
0D10:  MOVF   22,F
0D11:  BTFSS  03.2
0D12:  GOTO   523
0D13:  MOVLB  00
0D14:  MOVF   3B,W
0D15:  MOVLB  0C
0D16:  SUBWF  21,W
0D17:  BTFSS  03.0
0D18:  GOTO   585
0D19:  BTFSS  03.2
0D1A:  GOTO   523
0D1B:  MOVF   20,W
0D1C:  MOVLB  00
0D1D:  SUBWF  3A,W
0D1E:  BTFSS  03.0
0D1F:  GOTO   522
0D20:  MOVLB  0C
0D21:  GOTO   585
0D22:  MOVLB  0C
....................         if (pattern_position[0] >= 3) { 
0D23:  MOVLB  00
0D24:  MOVF   2F,F
0D25:  BTFSS  03.2
0D26:  GOTO   52B
0D27:  MOVF   2E,W
0D28:  SUBLW  02
0D29:  BTFSC  03.0
0D2A:  GOTO   52D
....................             pattern_position[0] = 0; 
0D2B:  CLRF   2F
0D2C:  CLRF   2E
....................         } 
....................         if (pattern_position[0] % 3 < 1) { 
0D2D:  MOVF   2F,W
0D2E:  MOVLB  0C
0D2F:  MOVWF  2B
0D30:  MOVLB  00
0D31:  MOVF   2E,W
0D32:  MOVLB  0C
0D33:  MOVWF  2A
0D34:  CLRF   2D
0D35:  MOVLW  03
0D36:  MOVWF  2C
0D37:  MOVLP  00
0D38:  MOVLB  00
0D39:  CALL   1F8
0D3A:  MOVLP  08
0D3B:  MOVF   77,W
0D3C:  MOVLB  0C
0D3D:  MOVWF  20
0D3E:  MOVF   7A,W
0D3F:  MOVWF  21
0D40:  MOVF   20,F
0D41:  BTFSS  03.2
0D42:  GOTO   55C
0D43:  MOVF   21,F
0D44:  BTFSS  03.2
0D45:  GOTO   55C
....................             ShiftRight(color_set); 
0D46:  MOVLB  0B
0D47:  MOVF   6C,W
0D48:  MOVLB  0C
0D49:  MOVWF  27
0D4A:  MOVLB  0B
0D4B:  MOVF   6B,W
0D4C:  MOVLB  0C
0D4D:  MOVWF  26
0D4E:  MOVLB  0B
0D4F:  MOVF   6A,W
0D50:  MOVLB  0C
0D51:  MOVWF  25
0D52:  MOVLB  0B
0D53:  MOVF   69,W
0D54:  MOVLB  0C
0D55:  MOVWF  24
0D56:  MOVLP  00
0D57:  MOVLB  00
0D58:  CALL   451
0D59:  MOVLP  08
....................         } else { 
0D5A:  GOTO   578
0D5B:  MOVLB  0C
....................             ShiftRight(Color(0, 0, 0)); 
0D5C:  CLRF   26
0D5D:  CLRF   27
0D5E:  CLRF   28
0D5F:  MOVLP  00
0D60:  MOVLB  00
0D61:  CALL   1AE
0D62:  MOVLP  08
0D63:  MOVF   7A,W
0D64:  MOVLB  0C
0D65:  MOVWF  23
0D66:  MOVF   79,W
0D67:  MOVWF  22
0D68:  MOVF   78,W
0D69:  MOVWF  21
0D6A:  MOVF   77,W
0D6B:  MOVWF  20
0D6C:  MOVF   23,W
0D6D:  MOVWF  27
0D6E:  MOVF   22,W
0D6F:  MOVWF  26
0D70:  MOVF   21,W
0D71:  MOVWF  25
0D72:  MOVF   20,W
0D73:  MOVWF  24
0D74:  MOVLP  00
0D75:  MOVLB  00
0D76:  CALL   451
0D77:  MOVLP  08
....................         } 
....................         send_frame(); 
0D78:  MOVLP  00
0D79:  CALL   233
0D7A:  MOVLP  08
....................         pattern_position[0]++; 
0D7B:  INCF   2E,F
0D7C:  BTFSC  03.2
0D7D:  INCF   2F,F
....................         Timer_Clear_Timer(0); 
0D7E:  MOVLB  0C
0D7F:  CLRF   20
0D80:  MOVLP  00
0D81:  MOVLB  00
0D82:  CALL   3C3
0D83:  MOVLP  08
0D84:  MOVLB  0C
....................     } 
.................... } 
....................  
.................... /* work in progress 
.................... void Random_Color_Cross() { 
.................... //pattern_position[0] tracks the location of dot 1 
.................... //pattern_position[1] tracks the location of dot 2 
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
....................         if 
....................  
....................  
....................     } 
....................  
....................     RandomColor(); 
....................  
.................... } 
.................... */ 
....................  
....................  
.................... void BMP_Play(int32 *PPattern, int Pattern_Size) { 
....................  
....................     //pattern_position[0] is the location to pull the color information 
....................     //pattern_position[1] tracks if we are moving up (0) or down (1) 
....................  
....................     if (Timer_Get_Timer(0) > delay_time_ms) { 
*
0522:  MOVLB  0C
0523:  CLRF   20
0524:  MOVLB  00
0525:  CALL   33E
0526:  MOVF   7A,W
0527:  MOVLB  0B
0528:  MOVWF  6B
0529:  MOVF   79,W
052A:  MOVWF  6A
052B:  MOVF   78,W
052C:  MOVWF  69
052D:  MOVF   77,W
052E:  MOVWF  68
052F:  MOVF   6B,F
0530:  BTFSS  03.2
0531:  GOTO   545
0532:  MOVF   6A,F
0533:  BTFSS  03.2
0534:  GOTO   545
0535:  MOVLB  00
0536:  MOVF   3B,W
0537:  MOVLB  0B
0538:  SUBWF  69,W
0539:  BTFSS  03.0
053A:  GOTO   5F3
053B:  BTFSS  03.2
053C:  GOTO   545
053D:  MOVF   68,W
053E:  MOVLB  00
053F:  SUBWF  3A,W
0540:  BTFSS  03.0
0541:  GOTO   544
0542:  MOVLB  0B
0543:  GOTO   5F3
0544:  MOVLB  0B
....................         //check if we are moving up and at the end upwards, if so turn around 
....................         if (pattern_position[1] == 0 && pattern_position[0] + 1 >= Pattern_Size) { 
0545:  MOVLB  00
0546:  MOVF   30,F
0547:  BTFSS  03.2
0548:  GOTO   567
0549:  MOVF   31,F
054A:  BTFSS  03.2
054B:  GOTO   567
054C:  MOVLW  01
054D:  ADDWF  2E,W
054E:  MOVLB  0B
054F:  MOVWF  68
0550:  MOVLW  00
0551:  MOVLB  00
0552:  ADDWFC 2F,W
0553:  MOVLB  0B
0554:  MOVWF  69
0555:  MOVF   69,F
0556:  BTFSS  03.2
0557:  GOTO   55E
0558:  MOVF   67,W
0559:  SUBWF  68,W
055A:  BTFSC  03.0
055B:  GOTO   55E
055C:  MOVLB  00
055D:  GOTO   567
....................             pattern_position[1] = 1; 
055E:  MOVLB  00
055F:  CLRF   31
0560:  MOVLW  01
0561:  MOVWF  30
....................             pattern_position[0]--; 
0562:  MOVF   2E,W
0563:  BTFSC  03.2
0564:  DECF   2F,F
0565:  DECF   2E,F
....................         } else { 
0566:  GOTO   58B
....................             //check if we are moving down and at the bottom 
....................             if (pattern_position[1] == 1 && pattern_position[0] == 0) { 
0567:  DECFSZ 30,W
0568:  GOTO   578
0569:  MOVF   31,F
056A:  BTFSS  03.2
056B:  GOTO   578
056C:  MOVF   2E,F
056D:  BTFSS  03.2
056E:  GOTO   578
056F:  MOVF   2F,F
0570:  BTFSS  03.2
0571:  GOTO   578
....................                 pattern_position[1] = 0; 
0572:  CLRF   31
0573:  CLRF   30
....................                 pattern_position[0]++; 
0574:  INCF   2E,F
0575:  BTFSC  03.2
0576:  INCF   2F,F
....................             } else { 
0577:  GOTO   58B
....................                 // see if we are just moving up 
....................                 if (pattern_position[1] == 0) { 
0578:  MOVF   30,F
0579:  BTFSS  03.2
057A:  GOTO   582
057B:  MOVF   31,F
057C:  BTFSS  03.2
057D:  GOTO   582
....................                     pattern_position[0]++; 
057E:  INCF   2E,F
057F:  BTFSC  03.2
0580:  INCF   2F,F
....................                 } else { 
0581:  GOTO   58B
....................                     //see if we are just moving down 
....................                     if (pattern_position[1] == 1) { 
0582:  DECFSZ 30,W
0583:  GOTO   58B
0584:  MOVF   31,F
0585:  BTFSS  03.2
0586:  GOTO   58B
....................                         pattern_position[0]--; 
0587:  MOVF   2E,W
0588:  BTFSC  03.2
0589:  DECF   2F,F
058A:  DECF   2E,F
....................                     } 
....................                 } 
....................             } 
....................         } 
....................         ShiftRight(*(PPattern + pattern_position[0])); 
058B:  RLF    2E,W
058C:  MOVWF  79
058D:  RLF    2F,W
058E:  MOVWF  7A
058F:  RLF    79,F
0590:  RLF    7A,F
0591:  MOVLW  FC
0592:  ANDWF  79,F
0593:  MOVF   79,W
0594:  MOVLB  0B
0595:  ADDWF  65,W
0596:  MOVWF  78
0597:  MOVF   66,W
0598:  ADDWFC 7A,F
0599:  MOVF   78,W
059A:  MOVWF  04
059B:  MOVF   7A,W
059C:  MOVWF  05
059D:  MOVF   00,W
059E:  MOVWF  68
059F:  ADDFSR 01,FSR0
05A0:  MOVF   00,W
05A1:  MOVWF  69
05A2:  ADDFSR 01,FSR0
05A3:  MOVF   00,W
05A4:  MOVWF  6A
05A5:  ADDFSR 01,FSR0
05A6:  MOVF   00,W
05A7:  MOVWF  6B
05A8:  ADDFSR 3D,FSR0
05A9:  MOVF   6B,W
05AA:  MOVLB  0C
05AB:  MOVWF  27
05AC:  MOVLB  0B
05AD:  MOVF   6A,W
05AE:  MOVLB  0C
05AF:  MOVWF  26
05B0:  MOVLB  0B
05B1:  MOVF   69,W
05B2:  MOVLB  0C
05B3:  MOVWF  25
05B4:  MOVLB  0B
05B5:  MOVF   68,W
05B6:  MOVLB  0C
05B7:  MOVWF  24
05B8:  MOVLB  00
05B9:  CALL   451
....................         #ifdef DEBUG_SERIAL 
....................             printf("Pattern Position 0,1  = %Lu,%lu\n\r", pattern_position[0],pattern_position[1]); 
05BA:  MOVLW  61
05BB:  MOVLB  03
05BC:  MOVWF  11
05BD:  MOVLW  00
05BE:  MOVWF  12
05BF:  BCF    03.0
05C0:  MOVLW  18
05C1:  MOVLB  0B
05C2:  MOVWF  6B
05C3:  MOVLB  00
05C4:  CALL   0F2
05C5:  MOVLW  10
05C6:  MOVWF  04
05C7:  MOVF   2F,W
05C8:  MOVLB  0B
05C9:  MOVWF  6C
05CA:  MOVLB  00
05CB:  MOVF   2E,W
05CC:  MOVLB  0B
05CD:  MOVWF  6B
05CE:  MOVLB  00
05CF:  CALL   149
05D0:  MOVLW  2C
05D1:  BTFSS  11.4
05D2:  GOTO   5D1
05D3:  MOVLB  03
05D4:  MOVWF  1A
05D5:  MOVLW  10
05D6:  MOVWF  04
05D7:  MOVLB  00
05D8:  MOVF   31,W
05D9:  MOVLB  0B
05DA:  MOVWF  6C
05DB:  MOVLB  00
05DC:  MOVF   30,W
05DD:  MOVLB  0B
05DE:  MOVWF  6B
05DF:  MOVLB  00
05E0:  CALL   149
05E1:  MOVLW  0A
05E2:  BTFSS  11.4
05E3:  GOTO   5E2
05E4:  MOVLB  03
05E5:  MOVWF  1A
05E6:  MOVLW  0D
05E7:  MOVLB  00
05E8:  BTFSS  11.4
05E9:  GOTO   5E8
05EA:  MOVLB  03
05EB:  MOVWF  1A
....................         #endif 
....................         send_frame(); 
05EC:  MOVLB  00
05ED:  CALL   233
....................         Timer_Clear_Timer(0); 
05EE:  MOVLB  0C
05EF:  CLRF   20
05F0:  MOVLB  00
05F1:  CALL   3C3
05F2:  MOVLB  0B
....................     } 
05F3:  MOVLB  00
05F4:  RETURN
.................... } 
....................  
....................  
.................... void Clear_Pattern_Positions() { 
....................     int i; 
....................     for (i = 0; i < NUM_PATTERN_POSITION; i++) { 
*
00A4:  MOVLB  0B
00A5:  CLRF   65
00A6:  MOVF   65,W
00A7:  SUBLW  01
00A8:  BTFSS  03.0
00A9:  GOTO   0B7
....................         pattern_position[i] = 0; 
00AA:  BCF    03.0
00AB:  RLF    65,W
00AC:  ADDLW  0E
00AD:  MOVWF  04
00AE:  MOVLW  20
00AF:  MOVWF  05
00B0:  BTFSC  03.0
00B1:  INCF   05,F
00B2:  CLRF   00
00B3:  ADDFSR 01,FSR0
00B4:  CLRF   00
00B5:  INCF   65,F
00B6:  GOTO   0A6
....................     } 
00B7:  MOVLB  00
00B8:  RETURN
.................... } 
....................  
.................... void Next_Pattern() { 
....................     if ((current_pattern + 1) >= NUM_PATTERNS) { 
*
10FB:  MOVLW  01
10FC:  MOVLB  00
10FD:  ADDWF  32,W
10FE:  MOVLB  0B
10FF:  MOVWF  65
1100:  MOVLW  00
1101:  MOVLB  00
1102:  ADDWFC 33,W
1103:  MOVLB  0B
1104:  MOVWF  66
1105:  MOVF   66,F
1106:  BTFSS  03.2
1107:  GOTO   10C
1108:  MOVF   65,W
1109:  SUBLW  15
110A:  BTFSC  03.0
110B:  GOTO   114
....................         Clear_Pattern_Positions(); 
110C:  MOVLP  00
110D:  MOVLB  00
110E:  CALL   0A4
110F:  MOVLP  10
....................         current_pattern = 0; 
1110:  CLRF   33
1111:  CLRF   32
....................     }else{ 
1112:  GOTO   11B
1113:  MOVLB  0B
....................         Clear_Pattern_Positions(); 
1114:  MOVLP  00
1115:  MOVLB  00
1116:  CALL   0A4
1117:  MOVLP  10
....................         current_pattern++; 
1118:  INCF   32,F
1119:  BTFSC  03.2
111A:  INCF   33,F
....................     } 
....................     pattern_set = 0; 
111B:  BCF    34.0
.................... } 
....................  
.................... void Previous_Pattern() { 
....................     if (current_pattern == 0){ 
*
112A:  MOVLB  00
112B:  MOVF   32,F
112C:  BTFSS  03.2
112D:  GOTO   138
112E:  MOVF   33,F
112F:  BTFSS  03.2
1130:  GOTO   138
....................         Clear_Pattern_Positions(); 
1131:  MOVLP  00
1132:  CALL   0A4
1133:  MOVLP  10
....................         current_pattern = NUM_PATTERNS - 1; 
1134:  CLRF   33
1135:  MOVLW  15
1136:  MOVWF  32
....................     }else{ 
1137:  GOTO   13F
....................         Clear_Pattern_Positions(); 
1138:  MOVLP  00
1139:  CALL   0A4
113A:  MOVLP  10
....................         current_pattern--; 
113B:  MOVF   32,W
113C:  BTFSC  03.2
113D:  DECF   33,F
113E:  DECF   32,F
....................     } 
....................     pattern_set = 0; 
113F:  BCF    34.0
.................... } 
....................  
.................... void Speed_Up_Pattern() { 
....................     if(delay_time_ms < 1000){ 
*
1156:  MOVF   3B,W
1157:  SUBLW  03
1158:  BTFSS  03.0
1159:  GOTO   164
115A:  BTFSS  03.2
115B:  GOTO   160
115C:  MOVF   3A,W
115D:  SUBLW  E7
115E:  BTFSS  03.0
115F:  GOTO   164
....................         delay_time_ms = delay_time_ms + DELAY_TIME_MS_JUMP; 
1160:  MOVLW  0A
1161:  ADDWF  3A,F
1162:  MOVLW  00
1163:  ADDWFC 3B,F
....................     } 
.................... #ifdef DEBUG_SERIAL 
....................     printf("Delay Time ms = %lu\n\r", delay_time_ms); 
1164:  MOVLW  72
1165:  MOVLB  03
1166:  MOVWF  11
1167:  MOVLW  00
1168:  MOVWF  12
1169:  BCF    03.0
116A:  MOVLW  10
116B:  MOVLB  0B
116C:  MOVWF  6B
116D:  MOVLP  00
116E:  MOVLB  00
116F:  CALL   0F2
1170:  MOVLP  10
1171:  MOVLW  10
1172:  MOVWF  04
1173:  MOVF   3B,W
1174:  MOVLB  0B
1175:  MOVWF  6C
1176:  MOVLB  00
1177:  MOVF   3A,W
1178:  MOVLB  0B
1179:  MOVWF  6B
117A:  MOVLP  00
117B:  MOVLB  00
117C:  CALL   149
117D:  MOVLP  10
117E:  MOVLW  0A
117F:  BTFSS  11.4
1180:  GOTO   17F
1181:  MOVLB  03
1182:  MOVWF  1A
1183:  MOVLW  0D
1184:  MOVLB  00
1185:  BTFSS  11.4
1186:  GOTO   185
1187:  MOVLB  03
1188:  MOVWF  1A
.................... #endif 
.................... } 
....................  
.................... void Slow_Down_Pattern() { 
....................     if(delay_time_ms > DELAY_TIME_MS_JUMP){ 
*
11AC:  MOVF   3B,F
11AD:  BTFSS  03.2
11AE:  GOTO   1B3
11AF:  MOVF   3A,W
11B0:  SUBLW  0A
11B1:  BTFSC  03.0
11B2:  GOTO   1B7
....................         delay_time_ms = delay_time_ms - DELAY_TIME_MS_JUMP; 
11B3:  MOVLW  0A
11B4:  SUBWF  3A,F
11B5:  MOVLW  00
11B6:  SUBWFC 3B,F
....................     } 
.................... #ifdef DEBUG_SERIAL 
....................     printf("Delay Time ms = %lu\n\r", delay_time_ms); 
11B7:  MOVLW  7D
11B8:  MOVLB  03
11B9:  MOVWF  11
11BA:  MOVLW  00
11BB:  MOVWF  12
11BC:  BCF    03.0
11BD:  MOVLW  10
11BE:  MOVLB  0B
11BF:  MOVWF  6B
11C0:  MOVLP  00
11C1:  MOVLB  00
11C2:  CALL   0F2
11C3:  MOVLP  10
11C4:  MOVLW  10
11C5:  MOVWF  04
11C6:  MOVF   3B,W
11C7:  MOVLB  0B
11C8:  MOVWF  6C
11C9:  MOVLB  00
11CA:  MOVF   3A,W
11CB:  MOVLB  0B
11CC:  MOVWF  6B
11CD:  MOVLP  00
11CE:  MOVLB  00
11CF:  CALL   149
11D0:  MOVLP  10
11D1:  MOVLW  0A
11D2:  BTFSS  11.4
11D3:  GOTO   1D2
11D4:  MOVLB  03
11D5:  MOVWF  1A
11D6:  MOVLW  0D
11D7:  MOVLB  00
11D8:  BTFSS  11.4
11D9:  GOTO   1D8
11DA:  MOVLB  03
11DB:  MOVWF  1A
.................... #endif 
.................... } 
....................  
.................... void Blink_Brightness() { 
....................     int i; 
....................     pattern_set = 1; 
*
0666:  BSF    34.0
....................     continue_pattern_calling = 0; 
0667:  BCF    34.1
....................     MakeAllColor(Color(0, 0, 0)); 
0668:  MOVLB  0C
0669:  CLRF   26
066A:  CLRF   27
066B:  CLRF   28
066C:  MOVLB  00
066D:  CALL   1AE
066E:  MOVF   7A,W
066F:  MOVLB  0B
0670:  MOVWF  69
0671:  MOVF   79,W
0672:  MOVWF  68
0673:  MOVF   78,W
0674:  MOVWF  67
0675:  MOVF   77,W
0676:  MOVWF  66
0677:  MOVF   69,W
0678:  MOVWF  6D
0679:  MOVF   68,W
067A:  MOVWF  6C
067B:  MOVF   67,W
067C:  MOVWF  6B
067D:  MOVF   66,W
067E:  MOVWF  6A
067F:  MOVLB  00
0680:  CALL   320
....................     delay_ms(100); 
0681:  MOVLW  64
0682:  MOVLB  0B
0683:  MOVWF  67
0684:  MOVLB  00
0685:  CALL   651
....................     for (i=0; i < brightness_value; i++){ 
0686:  MOVLB  0B
0687:  CLRF   65
0688:  MOVLB  00
0689:  MOVF   3C,W
068A:  MOVLB  0B
068B:  SUBWF  65,W
068C:  BTFSC  03.0
068D:  GOTO   6B4
....................         node_list[i] = Color(0,0,255); 
068E:  RLF    65,W
068F:  MOVWF  77
0690:  RLF    77,F
0691:  MOVLW  FC
0692:  ANDWF  77,F
0693:  MOVF   77,W
0694:  ADDLW  06
0695:  MOVWF  78
0696:  MOVLW  20
0697:  MOVWF  7A
0698:  BTFSC  03.0
0699:  INCF   7A,F
069A:  MOVF   78,W
069B:  MOVWF  66
069C:  MOVF   7A,W
069D:  MOVWF  67
069E:  MOVLB  0C
069F:  CLRF   26
06A0:  CLRF   27
06A1:  MOVLW  FF
06A2:  MOVWF  28
06A3:  MOVLB  00
06A4:  CALL   1AE
06A5:  MOVLB  0B
06A6:  MOVF   67,W
06A7:  MOVWF  05
06A8:  MOVF   66,W
06A9:  MOVWF  04
06AA:  MOVF   77,W
06AB:  MOVWF  00
06AC:  MOVF   78,W
06AD:  MOVWI  W,[FSR0+01]
06AE:  MOVF   79,W
06AF:  MOVWI  W,[FSR0+02]
06B0:  MOVF   7A,W
06B1:  MOVWI  W,[FSR0+03]
06B2:  INCF   65,F
06B3:  GOTO   688
....................     } 
....................     send_frame(); 
06B4:  MOVLB  00
06B5:  CALL   233
....................     delay_ms(300); 
06B6:  MOVLW  02
06B7:  MOVLB  0B
06B8:  MOVWF  66
06B9:  MOVLW  96
06BA:  MOVWF  67
06BB:  MOVLB  00
06BC:  CALL   651
06BD:  MOVLB  0B
06BE:  DECFSZ 66,F
06BF:  GOTO   6B9
....................     pattern_set = 0; 
06C0:  MOVLB  00
06C1:  BCF    34.0
....................     continue_pattern_calling = 1; 
06C2:  BSF    34.1
06C3:  RETURN
.................... } 
....................  
.................... void Increase_Brightness() { 
....................     if (brightness_value < MAX_BRIGHTNESS){ 
*
118A:  MOVF   3C,W
118B:  SUBLW  09
118C:  BTFSC  03.0
....................         brightness_value++; 
118D:  INCF   3C,F
....................     } 
....................     Blink_Brightness(); 
118E:  MOVLP  00
118F:  CALL   666
1190:  MOVLP  10
.................... } 
....................  
.................... void Decrease_Brightness() { 
....................     if (brightness_value > MIN_BRIGHTNESS){ 
*
11DD:  MOVF   3C,W
11DE:  SUBLW  01
11DF:  BTFSS  03.0
....................         brightness_value--; 
11E0:  DECF   3C,F
....................     } 
....................     Blink_Brightness(); 
11E1:  MOVLP  00
11E2:  CALL   666
11E3:  MOVLP  10
.................... } 
....................  
....................  
....................  
....................  
.................... void Toggle_Autochange_Pattern() { 
....................     if (autochange_pattern == 0) { 
*
11F7:  MOVLB  00
11F8:  MOVF   39,F
11F9:  BTFSS  03.2
11FA:  GOTO   2A9
....................         //turn on the autochange pattern 
....................         //blink green twice 
....................         pattern_set = 1; 
11FB:  BSF    34.0
....................         continue_pattern_calling = 0; 
11FC:  BCF    34.1
....................         //make all green 
....................         MakeAllColor(Color(0, 255, 0)); 
11FD:  MOVLB  0C
11FE:  CLRF   26
11FF:  MOVLW  FF
1200:  MOVWF  27
1201:  CLRF   28
1202:  MOVLP  00
1203:  MOVLB  00
1204:  CALL   1AE
1205:  MOVLP  10
1206:  MOVF   7A,W
1207:  MOVLB  0B
1208:  MOVWF  68
1209:  MOVF   79,W
120A:  MOVWF  67
120B:  MOVF   78,W
120C:  MOVWF  66
120D:  MOVF   77,W
120E:  MOVWF  65
120F:  MOVF   68,W
1210:  MOVWF  6D
1211:  MOVF   67,W
1212:  MOVWF  6C
1213:  MOVF   66,W
1214:  MOVWF  6B
1215:  MOVF   65,W
1216:  MOVWF  6A
1217:  MOVLP  00
1218:  MOVLB  00
1219:  CALL   320
121A:  MOVLP  10
....................         delay_ms(500); 
121B:  MOVLW  02
121C:  MOVLB  0B
121D:  MOVWF  65
121E:  MOVLW  FA
121F:  MOVWF  67
1220:  MOVLP  00
1221:  MOVLB  00
1222:  CALL   651
1223:  MOVLP  10
1224:  MOVLB  0B
1225:  DECFSZ 65,F
1226:  GOTO   21E
....................         MakeAllColor(Color(0, 0, 0)); 
1227:  MOVLB  0C
1228:  CLRF   26
1229:  CLRF   27
122A:  CLRF   28
122B:  MOVLP  00
122C:  MOVLB  00
122D:  CALL   1AE
122E:  MOVLP  10
122F:  MOVF   7A,W
1230:  MOVLB  0B
1231:  MOVWF  68
1232:  MOVF   79,W
1233:  MOVWF  67
1234:  MOVF   78,W
1235:  MOVWF  66
1236:  MOVF   77,W
1237:  MOVWF  65
1238:  MOVF   68,W
1239:  MOVWF  6D
123A:  MOVF   67,W
123B:  MOVWF  6C
123C:  MOVF   66,W
123D:  MOVWF  6B
123E:  MOVF   65,W
123F:  MOVWF  6A
1240:  MOVLP  00
1241:  MOVLB  00
1242:  CALL   320
1243:  MOVLP  10
....................         delay_ms(500); 
1244:  MOVLW  02
1245:  MOVLB  0B
1246:  MOVWF  65
1247:  MOVLW  FA
1248:  MOVWF  67
1249:  MOVLP  00
124A:  MOVLB  00
124B:  CALL   651
124C:  MOVLP  10
124D:  MOVLB  0B
124E:  DECFSZ 65,F
124F:  GOTO   247
....................         MakeAllColor(Color(0, 255, 0)); 
1250:  MOVLB  0C
1251:  CLRF   26
1252:  MOVLW  FF
1253:  MOVWF  27
1254:  CLRF   28
1255:  MOVLP  00
1256:  MOVLB  00
1257:  CALL   1AE
1258:  MOVLP  10
1259:  MOVF   7A,W
125A:  MOVLB  0B
125B:  MOVWF  68
125C:  MOVF   79,W
125D:  MOVWF  67
125E:  MOVF   78,W
125F:  MOVWF  66
1260:  MOVF   77,W
1261:  MOVWF  65
1262:  MOVF   68,W
1263:  MOVWF  6D
1264:  MOVF   67,W
1265:  MOVWF  6C
1266:  MOVF   66,W
1267:  MOVWF  6B
1268:  MOVF   65,W
1269:  MOVWF  6A
126A:  MOVLP  00
126B:  MOVLB  00
126C:  CALL   320
126D:  MOVLP  10
....................         delay_ms(500); 
126E:  MOVLW  02
126F:  MOVLB  0B
1270:  MOVWF  65
1271:  MOVLW  FA
1272:  MOVWF  67
1273:  MOVLP  00
1274:  MOVLB  00
1275:  CALL   651
1276:  MOVLP  10
1277:  MOVLB  0B
1278:  DECFSZ 65,F
1279:  GOTO   271
....................         MakeAllColor(Color(0, 0, 0)); 
127A:  MOVLB  0C
127B:  CLRF   26
127C:  CLRF   27
127D:  CLRF   28
127E:  MOVLP  00
127F:  MOVLB  00
1280:  CALL   1AE
1281:  MOVLP  10
1282:  MOVF   7A,W
1283:  MOVLB  0B
1284:  MOVWF  68
1285:  MOVF   79,W
1286:  MOVWF  67
1287:  MOVF   78,W
1288:  MOVWF  66
1289:  MOVF   77,W
128A:  MOVWF  65
128B:  MOVF   68,W
128C:  MOVWF  6D
128D:  MOVF   67,W
128E:  MOVWF  6C
128F:  MOVF   66,W
1290:  MOVWF  6B
1291:  MOVF   65,W
1292:  MOVWF  6A
1293:  MOVLP  00
1294:  MOVLB  00
1295:  CALL   320
1296:  MOVLP  10
....................         delay_ms(500); 
1297:  MOVLW  02
1298:  MOVLB  0B
1299:  MOVWF  65
129A:  MOVLW  FA
129B:  MOVWF  67
129C:  MOVLP  00
129D:  MOVLB  00
129E:  CALL   651
129F:  MOVLP  10
12A0:  MOVLB  0B
12A1:  DECFSZ 65,F
12A2:  GOTO   29A
....................         autochange_pattern = 1; 
12A3:  MOVLW  01
12A4:  MOVLB  00
12A5:  MOVWF  39
....................         pattern_set = 0; 
12A6:  BCF    34.0
....................         continue_pattern_calling = 1; 
12A7:  BSF    34.1
....................     } else { 
12A8:  GOTO   355
....................         //red green twice 
....................         pattern_set = 1; 
12A9:  BSF    34.0
....................         continue_pattern_calling = 0; 
12AA:  BCF    34.1
....................         //make all red 
....................         MakeAllColor(Color(255, 0, 0)); 
12AB:  MOVLW  FF
12AC:  MOVLB  0C
12AD:  MOVWF  26
12AE:  CLRF   27
12AF:  CLRF   28
12B0:  MOVLP  00
12B1:  MOVLB  00
12B2:  CALL   1AE
12B3:  MOVLP  10
12B4:  MOVF   7A,W
12B5:  MOVLB  0B
12B6:  MOVWF  68
12B7:  MOVF   79,W
12B8:  MOVWF  67
12B9:  MOVF   78,W
12BA:  MOVWF  66
12BB:  MOVF   77,W
12BC:  MOVWF  65
12BD:  MOVF   68,W
12BE:  MOVWF  6D
12BF:  MOVF   67,W
12C0:  MOVWF  6C
12C1:  MOVF   66,W
12C2:  MOVWF  6B
12C3:  MOVF   65,W
12C4:  MOVWF  6A
12C5:  MOVLP  00
12C6:  MOVLB  00
12C7:  CALL   320
12C8:  MOVLP  10
....................         delay_ms(500); 
12C9:  MOVLW  02
12CA:  MOVLB  0B
12CB:  MOVWF  65
12CC:  MOVLW  FA
12CD:  MOVWF  67
12CE:  MOVLP  00
12CF:  MOVLB  00
12D0:  CALL   651
12D1:  MOVLP  10
12D2:  MOVLB  0B
12D3:  DECFSZ 65,F
12D4:  GOTO   2CC
....................         MakeAllColor(Color(0, 0, 0)); 
12D5:  MOVLB  0C
12D6:  CLRF   26
12D7:  CLRF   27
12D8:  CLRF   28
12D9:  MOVLP  00
12DA:  MOVLB  00
12DB:  CALL   1AE
12DC:  MOVLP  10
12DD:  MOVF   7A,W
12DE:  MOVLB  0B
12DF:  MOVWF  68
12E0:  MOVF   79,W
12E1:  MOVWF  67
12E2:  MOVF   78,W
12E3:  MOVWF  66
12E4:  MOVF   77,W
12E5:  MOVWF  65
12E6:  MOVF   68,W
12E7:  MOVWF  6D
12E8:  MOVF   67,W
12E9:  MOVWF  6C
12EA:  MOVF   66,W
12EB:  MOVWF  6B
12EC:  MOVF   65,W
12ED:  MOVWF  6A
12EE:  MOVLP  00
12EF:  MOVLB  00
12F0:  CALL   320
12F1:  MOVLP  10
....................         delay_ms(500); 
12F2:  MOVLW  02
12F3:  MOVLB  0B
12F4:  MOVWF  65
12F5:  MOVLW  FA
12F6:  MOVWF  67
12F7:  MOVLP  00
12F8:  MOVLB  00
12F9:  CALL   651
12FA:  MOVLP  10
12FB:  MOVLB  0B
12FC:  DECFSZ 65,F
12FD:  GOTO   2F5
....................         MakeAllColor(Color(255, 0, 0)); 
12FE:  MOVLW  FF
12FF:  MOVLB  0C
1300:  MOVWF  26
1301:  CLRF   27
1302:  CLRF   28
1303:  MOVLP  00
1304:  MOVLB  00
1305:  CALL   1AE
1306:  MOVLP  10
1307:  MOVF   7A,W
1308:  MOVLB  0B
1309:  MOVWF  68
130A:  MOVF   79,W
130B:  MOVWF  67
130C:  MOVF   78,W
130D:  MOVWF  66
130E:  MOVF   77,W
130F:  MOVWF  65
1310:  MOVF   68,W
1311:  MOVWF  6D
1312:  MOVF   67,W
1313:  MOVWF  6C
1314:  MOVF   66,W
1315:  MOVWF  6B
1316:  MOVF   65,W
1317:  MOVWF  6A
1318:  MOVLP  00
1319:  MOVLB  00
131A:  CALL   320
131B:  MOVLP  10
....................         delay_ms(500); 
131C:  MOVLW  02
131D:  MOVLB  0B
131E:  MOVWF  65
131F:  MOVLW  FA
1320:  MOVWF  67
1321:  MOVLP  00
1322:  MOVLB  00
1323:  CALL   651
1324:  MOVLP  10
1325:  MOVLB  0B
1326:  DECFSZ 65,F
1327:  GOTO   31F
....................         MakeAllColor(Color(0, 0, 0)); 
1328:  MOVLB  0C
1329:  CLRF   26
132A:  CLRF   27
132B:  CLRF   28
132C:  MOVLP  00
132D:  MOVLB  00
132E:  CALL   1AE
132F:  MOVLP  10
1330:  MOVF   7A,W
1331:  MOVLB  0B
1332:  MOVWF  68
1333:  MOVF   79,W
1334:  MOVWF  67
1335:  MOVF   78,W
1336:  MOVWF  66
1337:  MOVF   77,W
1338:  MOVWF  65
1339:  MOVF   68,W
133A:  MOVWF  6D
133B:  MOVF   67,W
133C:  MOVWF  6C
133D:  MOVF   66,W
133E:  MOVWF  6B
133F:  MOVF   65,W
1340:  MOVWF  6A
1341:  MOVLP  00
1342:  MOVLB  00
1343:  CALL   320
1344:  MOVLP  10
....................         delay_ms(500); 
1345:  MOVLW  02
1346:  MOVLB  0B
1347:  MOVWF  65
1348:  MOVLW  FA
1349:  MOVWF  67
134A:  MOVLP  00
134B:  MOVLB  00
134C:  CALL   651
134D:  MOVLP  10
134E:  MOVLB  0B
134F:  DECFSZ 65,F
1350:  GOTO   348
....................         autochange_pattern = 0; 
1351:  MOVLB  00
1352:  CLRF   39
....................         pattern_set = 0; 
1353:  BCF    34.0
....................         continue_pattern_calling = 1; 
1354:  BSF    34.1
....................     } 
.................... } 
....................  
....................  
....................  
.................... #include "Buttons.c" 
.................... //FILE NAME = Buttons.h 
.................... //Functions to deal with buttons being pressed 
....................  
.................... void Power_Button_Function() { 
....................     if (led_power_status == 0) { //turning on 
*
1081:  MOVLB  00
1082:  BTFSC  34.2
1083:  GOTO   09E
.................... #ifdef DEBUG_SERIAL 
....................         printf("Turning on Power to LEDs\n\r"); 
1084:  MOVLW  88
1085:  MOVLB  03
1086:  MOVWF  11
1087:  MOVLW  00
1088:  MOVWF  12
1089:  MOVLP  00
108A:  MOVLB  00
108B:  CALL   602
108C:  MOVLP  10
.................... #endif 
....................         OUTPUT_LOW(LED_ON_PIN); 
108D:  MOVLB  01
108E:  BCF    0C.7
108F:  MOVLB  02
1090:  BCF    0C.7
....................         led_power_status = 1; //LED IS ON 
1091:  MOVLB  00
1092:  BSF    34.2
....................         delay_us(100); 
1093:  MOVLW  64
1094:  MOVLB  0C
1095:  MOVWF  29
1096:  MOVLP  00
1097:  MOVLB  00
1098:  CALL   21F
1099:  MOVLP  10
....................         send_frame(); 
109A:  MOVLP  00
109B:  CALL   233
109C:  MOVLP  10
....................     } else { //turning off 
109D:  GOTO   0ED
....................         OUTPUT_HIGH(LED_ON_PIN); 
109E:  MOVLB  01
109F:  BCF    0C.7
10A0:  MOVLB  02
10A1:  BSF    0C.7
....................         led_power_status = 0; //LEDS are off 
10A2:  MOVLB  00
10A3:  BCF    34.2
....................         disable_interrupts(GLOBAL); 
10A4:  BCF    0B.6
10A5:  BCF    0B.7
10A6:  BTFSC  0B.7
10A7:  GOTO   0A5
....................  
....................         clear_interrupt(INT_IOC_A0_L2H); 
10A8:  MOVLB  07
10A9:  BCF    13.0
....................         delay_us(200); 
10AA:  MOVLW  C8
10AB:  MOVLB  0C
10AC:  MOVWF  29
10AD:  MOVLP  00
10AE:  MOVLB  00
10AF:  CALL   21F
10B0:  MOVLP  10
....................         enable_interrupts(INT_IOC_A0_L2H); 
10B1:  BSF    0B.3
10B2:  MOVLB  07
10B3:  BSF    11.0
10B4:  BCF    12.0
....................  
.................... #ifdef DEBUG_SERIAL 
....................         printf("Going to Sleep\n\r"); 
10B5:  MOVLW  96
10B6:  MOVLB  03
10B7:  MOVWF  11
10B8:  MOVLW  00
10B9:  MOVWF  12
10BA:  MOVLP  00
10BB:  MOVLB  00
10BC:  CALL   602
10BD:  MOVLP  10
.................... #endif 
....................         sleep(); 
10BE:  SLEEP
....................  
....................         restart_wdt(); 
10BF:  CLRWDT
.................... #ifdef DEBUG_SERIAL 
....................         printf("Wake Up\n\r"); 
10C0:  MOVLW  9F
10C1:  MOVLB  03
10C2:  MOVWF  11
10C3:  MOVLW  00
10C4:  MOVWF  12
10C5:  MOVLP  00
10C6:  MOVLB  00
10C7:  CALL   602
10C8:  MOVLP  10
.................... #endif 
....................  
....................         delay_cycles(1); 
10C9:  NOP
....................         disable_interrupts(INT_IOC_A0_L2H); 
10CA:  MOVLB  07
10CB:  BCF    11.0
....................          
....................         rtos_disable(Button_Checker); 
10CC:  MOVLB  0A
10CD:  BSF    5A.7
....................         OUTPUT_LOW(LED_ON_PIN); 
10CE:  MOVLB  01
10CF:  BCF    0C.7
10D0:  MOVLB  02
10D1:  BCF    0C.7
....................         led_power_status = 1; //LED IS ON 
10D2:  MOVLB  00
10D3:  BSF    34.2
....................         delay_ms(50); 
10D4:  MOVLW  32
10D5:  MOVLB  0B
10D6:  MOVWF  67
10D7:  MOVLP  00
10D8:  MOVLB  00
10D9:  CALL   651
10DA:  MOVLP  10
....................         send_frame(); 
10DB:  MOVLP  00
10DC:  CALL   233
10DD:  MOVLP  10
....................         delay_ms(300); 
10DE:  MOVLW  02
10DF:  MOVLB  0B
10E0:  MOVWF  65
10E1:  MOVLW  96
10E2:  MOVWF  67
10E3:  MOVLP  00
10E4:  MOVLB  00
10E5:  CALL   651
10E6:  MOVLP  10
10E7:  MOVLB  0B
10E8:  DECFSZ 65,F
10E9:  GOTO   0E1
....................         rtos_enable(Button_Checker); 
10EA:  MOVLB  0A
10EB:  BCF    5A.7
10EC:  MOVLB  00
....................     } 
.................... } 
....................  
.................... void Up_Button_Function() { 
....................     Next_Pattern(); 
.................... } 
....................  
.................... void Down_Button_Function() { 
....................     Previous_Pattern(); 
.................... } 
....................  
.................... void Left_Button_Function() { 
....................     switch (autochange_pattern) { 
*
114E:  MOVLB  00
114F:  MOVF   39,W
1150:  BTFSC  03.2
1151:  GOTO   156
1152:  XORLW  01
1153:  BTFSC  03.2
1154:  GOTO   18A
1155:  GOTO   194
....................         case 0: 
....................             Speed_Up_Pattern(); 
....................             break; 
*
1189:  GOTO   195
....................         case 1: 
....................             Increase_Brightness(); 
....................             break; 
*
1191:  MOVLB  03
1192:  GOTO   195
1193:  MOVLB  00
....................         default: 
....................             break; 
1194:  MOVLB  03
....................     } 
.................... } 
....................  
.................... void Right_Button_Function() { 
....................     switch (autochange_pattern) { 
*
11A4:  MOVLB  00
11A5:  MOVF   39,W
11A6:  BTFSC  03.2
11A7:  GOTO   1AC
11A8:  XORLW  01
11A9:  BTFSC  03.2
11AA:  GOTO   1DD
11AB:  GOTO   1E7
....................         case 0: 
....................             Slow_Down_Pattern(); 
....................             break; 
*
11DC:  GOTO   1E8
....................         case 1: 
....................             Decrease_Brightness(); 
....................             break; 
*
11E4:  MOVLB  03
11E5:  GOTO   1E8
11E6:  MOVLB  00
....................         default: 
....................             break; 
11E7:  MOVLB  03
....................     } 
.................... } 
....................  
.................... void Center_Button_Function() { 
....................     Toggle_Autochange_Pattern(); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include "RTOS_Functions.c" 
.................... //FILE NAME = LED_Patterns.h 
.................... // A Collection of functions to be called by the RTOS 
....................  
.................... void Pattern_Selector() { 
....................     switch (autochange_pattern) { 
*
00B9:  MOVF   39,W
00BA:  XORLW  00
00BB:  BTFSC  03.2
00BC:  GOTO   0C1
00BD:  XORLW  01
00BE:  BTFSC  03.2
00BF:  GOTO   0C4
00C0:  GOTO   0C8
....................         case 0: 
....................             rtos_disable(Pattern_Selector); 
00C1:  MOVLB  0A
00C2:  BSF    4C.7
....................             break; 
00C3:  GOTO   0C9
....................         case 1: 
....................             rtos_enable(Pattern_Selector); 
00C4:  MOVLB  0A
00C5:  BCF    4C.7
....................             break; 
00C6:  GOTO   0C9
00C7:  MOVLB  00
....................         default: 
....................             break; 
00C8:  MOVLB  0A
....................     } 
....................     if (autochange_pattern) { 
00C9:  MOVLB  00
00CA:  MOVF   39,F
00CB:  BTFSC  03.2
00CC:  GOTO   0E9
....................         if ((current_pattern + 1) >= NUM_PATTERNS) { 
00CD:  MOVLW  01
00CE:  ADDWF  32,W
00CF:  MOVLB  0B
00D0:  MOVWF  65
00D1:  MOVLW  00
00D2:  MOVLB  00
00D3:  ADDWFC 33,W
00D4:  MOVLB  0B
00D5:  MOVWF  66
00D6:  MOVF   66,F
00D7:  BTFSS  03.2
00D8:  GOTO   0DD
00D9:  MOVF   65,W
00DA:  SUBLW  15
00DB:  BTFSC  03.0
00DC:  GOTO   0E3
....................             current_pattern = 0; 
00DD:  MOVLB  00
00DE:  CLRF   33
00DF:  CLRF   32
....................             Clear_Pattern_Positions(); 
00E0:  CALL   0A4
....................         } else { 
00E1:  GOTO   0E8
00E2:  MOVLB  0B
....................             current_pattern++; 
00E3:  MOVLB  00
00E4:  INCF   32,F
00E5:  BTFSC  03.2
00E6:  INCF   33,F
....................             Clear_Pattern_Positions(); 
00E7:  CALL   0A4
....................         } 
....................         pattern_set = 0; 
00E8:  BCF    34.0
....................         //rtos_disable(Pattern_Selector); 
....................     } 
00E9:  MOVLW  B9
00EA:  MOVLB  0A
00EB:  MOVWF  51
00EC:  MOVLW  00
00ED:  MOVWF  52
00EE:  MOVLP  10
00EF:  MOVLB  00
00F0:  GOTO   7A8
00F1:  RETURN
.................... } 
....................  
.................... void Update_Pattern() { 
....................     restart_wdt(); 
*
0800:  CLRWDT
.................... #ifdef DEBUG_SERIAL 
....................     if (pattern_set == 0) { 
0801:  BTFSC  34.0
0802:  GOTO   029
....................         printf("Changing Pattern to %Lu\n\r", current_pattern); 
0803:  MOVLW  F5
0804:  MOVLB  03
0805:  MOVWF  11
0806:  MOVLW  05
0807:  MOVWF  12
0808:  BCF    03.0
0809:  MOVLW  14
080A:  MOVLB  0B
080B:  MOVWF  6B
080C:  MOVLP  00
080D:  MOVLB  00
080E:  CALL   0F2
080F:  MOVLP  08
0810:  MOVLW  10
0811:  MOVWF  04
0812:  MOVF   33,W
0813:  MOVLB  0B
0814:  MOVWF  6C
0815:  MOVLB  00
0816:  MOVF   32,W
0817:  MOVLB  0B
0818:  MOVWF  6B
0819:  MOVLP  00
081A:  MOVLB  00
081B:  CALL   149
081C:  MOVLP  08
081D:  MOVLW  0A
081E:  BTFSS  11.4
081F:  GOTO   01E
0820:  MOVLB  03
0821:  MOVWF  1A
0822:  MOVLW  0D
0823:  MOVLB  00
0824:  BTFSS  11.4
0825:  GOTO   024
0826:  MOVLB  03
0827:  MOVWF  1A
0828:  MOVLB  00
....................     } 
.................... #endif 
....................  
....................     switch (autochange_pattern) { 
0829:  MOVF   39,W
082A:  BTFSC  03.2
082B:  GOTO   030
082C:  XORLW  01
082D:  BTFSC  03.2
082E:  GOTO   033
082F:  GOTO   037
....................         case 0: 
....................             rtos_disable(Pattern_Selector); 
0830:  MOVLB  0A
0831:  BSF    4C.7
....................             break; 
0832:  GOTO   038
....................         case 1: 
....................             rtos_enable(Pattern_Selector); 
0833:  MOVLB  0A
0834:  BCF    4C.7
....................             break; 
0835:  GOTO   038
0836:  MOVLB  00
....................         default: 
....................             break; 
0837:  MOVLB  0A
....................     } 
....................      
....................     if (pattern_set == 0 || continue_pattern_calling == 1) { 
0838:  MOVLB  00
0839:  BTFSS  34.0
083A:  GOTO   03D
083B:  BTFSS  34.1
083C:  GOTO   62A
....................         switch (current_pattern) { 
083D:  MOVF   32,W
083E:  MOVWF  77
083F:  MOVF   33,W
0840:  MOVWF  7A
0841:  MOVF   7A,W
0842:  BTFSS  03.2
0843:  GOTO   047
0844:  MOVF   77,F
0845:  BTFSC  03.2
0846:  GOTO   0DB
0847:  MOVF   7A,W
0848:  BTFSS  03.2
0849:  GOTO   04E
084A:  MOVLW  01
084B:  SUBWF  77,W
084C:  BTFSC  03.2
084D:  GOTO   0FC
084E:  MOVF   7A,W
084F:  BTFSS  03.2
0850:  GOTO   055
0851:  MOVLW  02
0852:  SUBWF  77,W
0853:  BTFSC  03.2
0854:  GOTO   11D
0855:  MOVF   7A,W
0856:  BTFSS  03.2
0857:  GOTO   05C
0858:  MOVLW  03
0859:  SUBWF  77,W
085A:  BTFSC  03.2
085B:  GOTO   13E
085C:  MOVF   7A,W
085D:  BTFSS  03.2
085E:  GOTO   063
085F:  MOVLW  04
0860:  SUBWF  77,W
0861:  BTFSC  03.2
0862:  GOTO   1B7
0863:  MOVF   7A,W
0864:  BTFSS  03.2
0865:  GOTO   06A
0866:  MOVLW  05
0867:  SUBWF  77,W
0868:  BTFSC  03.2
0869:  GOTO   28B
086A:  MOVF   7A,W
086B:  BTFSS  03.2
086C:  GOTO   071
086D:  MOVLW  06
086E:  SUBWF  77,W
086F:  BTFSC  03.2
0870:  GOTO   30D
0871:  MOVF   7A,W
0872:  BTFSS  03.2
0873:  GOTO   078
0874:  MOVLW  07
0875:  SUBWF  77,W
0876:  BTFSC  03.2
0877:  GOTO   3CF
0878:  MOVF   7A,W
0879:  BTFSS  03.2
087A:  GOTO   07F
087B:  MOVLW  08
087C:  SUBWF  77,W
087D:  BTFSC  03.2
087E:  GOTO   3F0
087F:  MOVF   7A,W
0880:  BTFSS  03.2
0881:  GOTO   086
0882:  MOVLW  09
0883:  SUBWF  77,W
0884:  BTFSC  03.2
0885:  GOTO   411
0886:  MOVF   7A,W
0887:  BTFSS  03.2
0888:  GOTO   08D
0889:  MOVLW  0A
088A:  SUBWF  77,W
088B:  BTFSC  03.2
088C:  GOTO   44C
088D:  MOVF   7A,W
088E:  BTFSS  03.2
088F:  GOTO   094
0890:  MOVLW  0B
0891:  SUBWF  77,W
0892:  BTFSC  03.2
0893:  GOTO   4E3
0894:  MOVF   7A,W
0895:  BTFSS  03.2
0896:  GOTO   09B
0897:  MOVLW  0C
0898:  SUBWF  77,W
0899:  BTFSC  03.2
089A:  GOTO   588
089B:  MOVF   7A,W
089C:  BTFSS  03.2
089D:  GOTO   0A2
089E:  MOVLW  0D
089F:  SUBWF  77,W
08A0:  BTFSC  03.2
08A1:  GOTO   597
08A2:  MOVF   7A,W
08A3:  BTFSS  03.2
08A4:  GOTO   0A9
08A5:  MOVLW  0E
08A6:  SUBWF  77,W
08A7:  BTFSC  03.2
08A8:  GOTO   5A7
08A9:  MOVF   7A,W
08AA:  BTFSS  03.2
08AB:  GOTO   0B0
08AC:  MOVLW  0F
08AD:  SUBWF  77,W
08AE:  BTFSC  03.2
08AF:  GOTO   5B7
08B0:  MOVF   7A,W
08B1:  BTFSS  03.2
08B2:  GOTO   0B7
08B3:  MOVLW  10
08B4:  SUBWF  77,W
08B5:  BTFSC  03.2
08B6:  GOTO   5C5
08B7:  MOVF   7A,W
08B8:  BTFSS  03.2
08B9:  GOTO   0BE
08BA:  MOVLW  11
08BB:  SUBWF  77,W
08BC:  BTFSC  03.2
08BD:  GOTO   5D2
08BE:  MOVF   7A,W
08BF:  BTFSS  03.2
08C0:  GOTO   0C5
08C1:  MOVLW  12
08C2:  SUBWF  77,W
08C3:  BTFSC  03.2
08C4:  GOTO   5E0
08C5:  MOVF   7A,W
08C6:  BTFSS  03.2
08C7:  GOTO   0CC
08C8:  MOVLW  13
08C9:  SUBWF  77,W
08CA:  BTFSC  03.2
08CB:  GOTO   5EE
08CC:  MOVF   7A,W
08CD:  BTFSS  03.2
08CE:  GOTO   0D3
08CF:  MOVLW  14
08D0:  SUBWF  77,W
08D1:  BTFSC  03.2
08D2:  GOTO   5FC
08D3:  MOVF   7A,W
08D4:  BTFSS  03.2
08D5:  GOTO   0DA
08D6:  MOVLW  15
08D7:  SUBWF  77,W
08D8:  BTFSC  03.2
08D9:  GOTO   60A
08DA:  GOTO   62A
....................             case 0: // All Red 
....................                 MakeAllRed(); 
....................                 pattern_set = 1; 
*
08F9:  BSF    34.0
....................                 continue_pattern_calling = 0; 
08FA:  BCF    34.1
....................                 break; 
08FB:  GOTO   62A
....................             case 1: //All Green 
....................                 MakeAllGreen(); 
....................                 pattern_set = 1; 
*
091A:  BSF    34.0
....................                 continue_pattern_calling = 0; 
091B:  BCF    34.1
....................                 break; 
091C:  GOTO   62A
....................             case 2: //All Blue 
....................                 MakeAllBlue(); 
....................                 pattern_set = 1; 
*
093B:  BSF    34.0
....................                 continue_pattern_calling = 0; 
093C:  BCF    34.1
....................                 break; 
093D:  GOTO   62A
....................             case 3: //Slow Rainbow Fade on all Leds 
....................                 continue_pattern_calling = 1; 
093E:  BSF    34.1
....................                 All_Rainbow_Fade_200ms(); 
....................                 pattern_set = 1; 
*
09B4:  MOVLB  00
09B5:  BSF    34.0
....................                 break; 
09B6:  GOTO   62A
....................             case 4: 
....................                 continue_pattern_calling = 1; 
09B7:  BSF    34.1
....................                 Dot_Rainbow_Fade(); 
....................                 pattern_set = 1; 
*
0A88:  MOVLB  00
0A89:  BSF    34.0
....................                 break; 
0A8A:  GOTO   62A
....................             case 5: 
....................                 continue_pattern_calling = 1; 
0A8B:  BSF    34.1
....................                 All_Rainbow_Fade(); 
....................                 pattern_set = 1; 
*
0B0A:  MOVLB  00
0B0B:  BSF    34.0
....................                 break; 
0B0C:  GOTO   62A
....................             case 6: 
....................                 continue_pattern_calling = 1; 
0B0D:  BSF    34.1
....................                 Random_Chain(); 
....................                 pattern_set = 1; 
*
0BCC:  MOVLB  00
0BCD:  BSF    34.0
....................                 break; 
0BCE:  GOTO   62A
....................             case 7: 
....................                 continue_pattern_calling = 1; 
0BCF:  BSF    34.1
....................                 ShiftThreeColorThreeBlank(Color(255,0,0)); 
0BD0:  MOVLW  FF
0BD1:  MOVLB  0C
0BD2:  MOVWF  26
0BD3:  CLRF   27
0BD4:  CLRF   28
0BD5:  MOVLP  00
0BD6:  MOVLB  00
0BD7:  CALL   1AE
0BD8:  MOVLP  08
0BD9:  MOVF   7A,W
0BDA:  MOVLB  0B
0BDB:  MOVWF  68
0BDC:  MOVF   79,W
0BDD:  MOVWF  67
0BDE:  MOVF   78,W
0BDF:  MOVWF  66
0BE0:  MOVF   77,W
0BE1:  MOVWF  65
0BE2:  MOVF   68,W
0BE3:  MOVWF  6C
0BE4:  MOVF   67,W
0BE5:  MOVWF  6B
0BE6:  MOVF   66,W
0BE7:  MOVWF  6A
0BE8:  MOVF   65,W
0BE9:  MOVWF  69
0BEA:  MOVLP  00
0BEB:  MOVLB  00
0BEC:  CALL   4A6
0BED:  MOVLP  08
....................                 pattern_set = 1; 
0BEE:  BSF    34.0
....................                 break; 
0BEF:  GOTO   62A
....................             case 8: 
....................                 continue_pattern_calling = 1; 
0BF0:  BSF    34.1
....................                 ShiftThreeColorThreeBlank(Color(0,255,255)); 
0BF1:  MOVLB  0C
0BF2:  CLRF   26
0BF3:  MOVLW  FF
0BF4:  MOVWF  27
0BF5:  MOVWF  28
0BF6:  MOVLP  00
0BF7:  MOVLB  00
0BF8:  CALL   1AE
0BF9:  MOVLP  08
0BFA:  MOVF   7A,W
0BFB:  MOVLB  0B
0BFC:  MOVWF  68
0BFD:  MOVF   79,W
0BFE:  MOVWF  67
0BFF:  MOVF   78,W
0C00:  MOVWF  66
0C01:  MOVF   77,W
0C02:  MOVWF  65
0C03:  MOVF   68,W
0C04:  MOVWF  6C
0C05:  MOVF   67,W
0C06:  MOVWF  6B
0C07:  MOVF   66,W
0C08:  MOVWF  6A
0C09:  MOVF   65,W
0C0A:  MOVWF  69
0C0B:  MOVLP  00
0C0C:  MOVLB  00
0C0D:  CALL   4A6
0C0E:  MOVLP  08
....................                 pattern_set = 1; 
0C0F:  BSF    34.0
....................                 break; 
0C10:  GOTO   62A
....................             case 9: 
....................                 continue_pattern_calling = 1; 
0C11:  BSF    34.1
....................                 ShiftThreeColorThreeBlank(Wheel(rand()%767)); 
0C12:  MOVLP  00
0C13:  CALL   3DC
0C14:  MOVLP  08
0C15:  MOVF   79,W
0C16:  MOVLB  0B
0C17:  MOVWF  66
0C18:  MOVF   78,W
0C19:  MOVWF  65
0C1A:  MOVF   66,W
0C1B:  MOVLB  0C
0C1C:  MOVWF  2B
0C1D:  MOVLB  0B
0C1E:  MOVF   65,W
0C1F:  MOVLB  0C
0C20:  MOVWF  2A
0C21:  MOVLW  02
0C22:  MOVWF  2D
0C23:  MOVLW  FF
0C24:  MOVWF  2C
0C25:  MOVLP  00
0C26:  MOVLB  00
0C27:  CALL   1F8
0C28:  MOVLP  08
0C29:  MOVF   77,W
0C2A:  MOVLB  0B
0C2B:  MOVWF  65
0C2C:  MOVF   7A,W
0C2D:  MOVWF  66
0C2E:  MOVWF  6E
0C2F:  MOVF   65,W
0C30:  MOVWF  6D
0C31:  MOVLP  00
0C32:  MOVLB  00
0C33:  CALL   362
0C34:  MOVLP  08
0C35:  MOVF   7A,W
0C36:  MOVLB  0B
0C37:  MOVWF  68
0C38:  MOVF   79,W
0C39:  MOVWF  67
0C3A:  MOVF   78,W
0C3B:  MOVWF  66
0C3C:  MOVF   77,W
0C3D:  MOVWF  65
0C3E:  MOVF   68,W
0C3F:  MOVWF  6C
0C40:  MOVF   67,W
0C41:  MOVWF  6B
0C42:  MOVF   66,W
0C43:  MOVWF  6A
0C44:  MOVF   65,W
0C45:  MOVWF  69
0C46:  MOVLP  00
0C47:  MOVLB  00
0C48:  CALL   4A6
0C49:  MOVLP  08
....................                 pattern_set = 1; 
0C4A:  BSF    34.0
....................                 break; 
0C4B:  GOTO   62A
....................             case 10: 
....................                 continue_pattern_calling = 1; 
0C4C:  BSF    34.1
....................                 ShiftOneColorOneBlank(Color(0,0,255)); 
0C4D:  MOVLB  0C
0C4E:  CLRF   26
0C4F:  CLRF   27
0C50:  MOVLW  FF
0C51:  MOVWF  28
0C52:  MOVLP  00
0C53:  MOVLB  00
0C54:  CALL   1AE
0C55:  MOVLP  08
0C56:  MOVF   7A,W
0C57:  MOVLB  0B
0C58:  MOVWF  68
0C59:  MOVF   79,W
0C5A:  MOVWF  67
0C5B:  MOVF   78,W
0C5C:  MOVWF  66
0C5D:  MOVF   77,W
0C5E:  MOVWF  65
0C5F:  MOVF   68,W
0C60:  MOVWF  6C
0C61:  MOVF   67,W
0C62:  MOVWF  6B
0C63:  MOVF   66,W
0C64:  MOVWF  6A
0C65:  MOVF   65,W
0C66:  MOVWF  69
....................                 pattern_set = 1; 
*
0CE0:  MOVLB  00
0CE1:  BSF    34.0
....................                 break; 
0CE2:  GOTO   62A
....................             case 11: 
....................                 continue_pattern_calling = 1; 
0CE3:  BSF    34.1
....................                 ShiftOneColorTwoBlank(Color(0,0,255)); 
0CE4:  MOVLB  0C
0CE5:  CLRF   26
0CE6:  CLRF   27
0CE7:  MOVLW  FF
0CE8:  MOVWF  28
0CE9:  MOVLP  00
0CEA:  MOVLB  00
0CEB:  CALL   1AE
0CEC:  MOVLP  08
0CED:  MOVF   7A,W
0CEE:  MOVLB  0B
0CEF:  MOVWF  68
0CF0:  MOVF   79,W
0CF1:  MOVWF  67
0CF2:  MOVF   78,W
0CF3:  MOVWF  66
0CF4:  MOVF   77,W
0CF5:  MOVWF  65
0CF6:  MOVF   68,W
0CF7:  MOVWF  6C
0CF8:  MOVF   67,W
0CF9:  MOVWF  6B
0CFA:  MOVF   66,W
0CFB:  MOVWF  6A
0CFC:  MOVF   65,W
0CFD:  MOVWF  69
....................                 pattern_set = 1; 
*
0D85:  MOVLB  00
0D86:  BSF    34.0
....................                 break; 
0D87:  GOTO   62A
....................             case 12: 
....................                 continue_pattern_calling = 1; 
0D88:  BSF    34.1
....................                 BMP_Play(&Pattern1, Pattern1_Size); 
0D89:  MOVLW  20
0D8A:  MOVLB  0B
0D8B:  MOVWF  66
0D8C:  MOVWF  65
0D8D:  MOVLB  00
0D8E:  MOVF   3D,W
0D8F:  MOVLB  0B
0D90:  MOVWF  67
0D91:  MOVLP  00
0D92:  MOVLB  00
0D93:  CALL   522
0D94:  MOVLP  08
....................                 pattern_set = 1; 
0D95:  BSF    34.0
....................                 break; 
0D96:  GOTO   62A
....................             case 13: 
....................                 continue_pattern_calling = 1; 
0D97:  BSF    34.1
....................                 BMP_Play(&Pattern2, Pattern2_Size); 
0D98:  MOVLW  20
0D99:  MOVLB  0B
0D9A:  MOVWF  66
0D9B:  MOVLW  48
0D9C:  MOVWF  65
0D9D:  MOVLB  00
0D9E:  MOVF   3E,W
0D9F:  MOVLB  0B
0DA0:  MOVWF  67
0DA1:  MOVLP  00
0DA2:  MOVLB  00
0DA3:  CALL   522
0DA4:  MOVLP  08
....................                 pattern_set = 1; 
0DA5:  BSF    34.0
....................                 break; 
0DA6:  GOTO   62A
....................             case 14: 
....................                 continue_pattern_calling = 1; 
0DA7:  BSF    34.1
....................                 BMP_Play(&Pattern3, Pattern3_Size); 
0DA8:  MOVLW  20
0DA9:  MOVLB  0B
0DAA:  MOVWF  66
0DAB:  MOVLW  70
0DAC:  MOVWF  65
0DAD:  MOVLB  00
0DAE:  MOVF   3F,W
0DAF:  MOVLB  0B
0DB0:  MOVWF  67
0DB1:  MOVLP  00
0DB2:  MOVLB  00
0DB3:  CALL   522
0DB4:  MOVLP  08
....................                 pattern_set = 1; 
0DB5:  BSF    34.0
....................                 break; 
0DB6:  GOTO   62A
....................             case 15: 
....................                 continue_pattern_calling = 1; 
0DB7:  BSF    34.1
....................                 BMP_Play(&Pattern4, Pattern4_Size); 
0DB8:  MOVLW  21
0DB9:  MOVLB  0B
0DBA:  MOVWF  66
0DBB:  MOVLW  10
0DBC:  MOVWF  65
0DBD:  MOVF   70,W
0DBE:  MOVWF  67
0DBF:  MOVLP  00
0DC0:  MOVLB  00
0DC1:  CALL   522
0DC2:  MOVLP  08
....................                 pattern_set = 1; 
0DC3:  BSF    34.0
....................                 break; 
0DC4:  GOTO   62A
....................             case 16: 
....................                 continue_pattern_calling = 1; 
0DC5:  BSF    34.1
....................                 BMP_Play(&Pattern5, Pattern5_Size); 
0DC6:  MOVLW  22
0DC7:  MOVLB  0B
0DC8:  MOVWF  66
0DC9:  CLRF   65
0DCA:  MOVF   71,W
0DCB:  MOVWF  67
0DCC:  MOVLP  00
0DCD:  MOVLB  00
0DCE:  CALL   522
0DCF:  MOVLP  08
....................                 pattern_set = 1; 
0DD0:  BSF    34.0
....................                 break; 
0DD1:  GOTO   62A
....................             case 17: 
....................                 continue_pattern_calling = 1; 
0DD2:  BSF    34.1
....................                 BMP_Play(&Pattern6, Pattern6_Size); 
0DD3:  MOVLW  22
0DD4:  MOVLB  0B
0DD5:  MOVWF  66
0DD6:  MOVLW  D0
0DD7:  MOVWF  65
0DD8:  MOVF   72,W
0DD9:  MOVWF  67
0DDA:  MOVLP  00
0DDB:  MOVLB  00
0DDC:  CALL   522
0DDD:  MOVLP  08
....................                 pattern_set = 1; 
0DDE:  BSF    34.0
....................                 break; 
0DDF:  GOTO   62A
....................             case 18: 
....................                 continue_pattern_calling = 1; 
0DE0:  BSF    34.1
....................                 BMP_Play(&Pattern7, Pattern7_Size); 
0DE1:  MOVLW  23
0DE2:  MOVLB  0B
0DE3:  MOVWF  66
0DE4:  MOVLW  28
0DE5:  MOVWF  65
0DE6:  MOVF   73,W
0DE7:  MOVWF  67
0DE8:  MOVLP  00
0DE9:  MOVLB  00
0DEA:  CALL   522
0DEB:  MOVLP  08
....................                 pattern_set = 1; 
0DEC:  BSF    34.0
....................                 break; 
0DED:  GOTO   62A
....................             case 19: 
....................                 continue_pattern_calling = 1; 
0DEE:  BSF    34.1
....................                 BMP_Play(&Pattern8, Pattern8_Size); 
0DEF:  MOVLW  23
0DF0:  MOVLB  0B
0DF1:  MOVWF  66
0DF2:  MOVLW  34
0DF3:  MOVWF  65
0DF4:  MOVF   74,W
0DF5:  MOVWF  67
0DF6:  MOVLP  00
0DF7:  MOVLB  00
0DF8:  CALL   522
0DF9:  MOVLP  08
....................                 pattern_set = 1; 
0DFA:  BSF    34.0
....................                 break; 
0DFB:  GOTO   62A
....................             case 20: 
....................                 continue_pattern_calling = 1; 
0DFC:  BSF    34.1
....................                 BMP_Play(&Pattern9, Pattern9_Size); 
0DFD:  MOVLW  23
0DFE:  MOVLB  0B
0DFF:  MOVWF  66
0E00:  MOVLW  40
0E01:  MOVWF  65
0E02:  MOVF   75,W
0E03:  MOVWF  67
0E04:  MOVLP  00
0E05:  MOVLB  00
0E06:  CALL   522
0E07:  MOVLP  08
....................                 pattern_set = 1; 
0E08:  BSF    34.0
....................                 break; 
0E09:  GOTO   62A
....................             case 21: // All White for Tent Light 
....................                 MakeAllWhite(); 
....................                 pattern_set = 1; 
*
0E28:  BSF    34.0
....................                 continue_pattern_calling = 0; 
0E29:  BCF    34.1
....................                 break; 
....................         } 
....................     } 
0E2A:  MOVLW  00
0E2B:  MOVLB  0A
0E2C:  MOVWF  58
0E2D:  MOVLW  08
0E2E:  MOVWF  59
0E2F:  MOVLP  10
0E30:  MOVLB  00
0E31:  GOTO   7A8
0E32:  RETURN
.................... } 
....................  
.................... void Button_Checker() { 
....................     //check if any button is pressed 
....................     if (button_status == 0) { //no buttons have been pressed 
*
1000:  MOVF   37,F
1001:  BTFSS  03.2
1002:  GOTO   02E
....................  
....................         //Power Button 
....................         if (input(POWER_BUTTON_PIN) == 0) { //button is pressed 
1003:  MOVLB  01
1004:  BSF    0C.0
1005:  MOVLB  00
1006:  BTFSC  0C.0
1007:  GOTO   00A
....................             bit_set(button_status, POWER_BUTTON_BIT); 
1008:  BSF    37.0
....................             button_counter = 0; 
1009:  CLRF   38
....................         } 
....................  
....................         //Up Button 
....................         if (input(UP_BUTTON_PIN) == 0) { //button is pressed 
100A:  MOVLB  01
100B:  BSF    0C.1
100C:  MOVLB  00
100D:  BTFSC  0C.1
100E:  GOTO   011
....................             bit_set(button_status, UP_BUTTON_BIT); 
100F:  BSF    37.1
....................             button_counter = 0; 
1010:  CLRF   38
....................         } 
....................  
....................         //Down Button 
....................         if (input(DOWN_BUTTON_PIN) == 0) { //button is pressed 
1011:  MOVLB  01
1012:  BSF    0C.2
1013:  MOVLB  00
1014:  BTFSC  0C.2
1015:  GOTO   018
....................             bit_set(button_status, DOWN_BUTTON_BIT); 
1016:  BSF    37.2
....................             button_counter = 0; 
1017:  CLRF   38
....................         } 
....................  
....................         //Left Button 
....................         if (input(LEFT_BUTTON_PIN) == 0) { //button is pressed 
1018:  MOVLB  01
1019:  BSF    0C.3
101A:  MOVLB  00
101B:  BTFSC  0C.3
101C:  GOTO   01F
....................             bit_set(button_status, LEFT_BUTTON_BIT); 
101D:  BSF    37.3
....................             button_counter = 0; 
101E:  CLRF   38
....................         }       
....................          
....................         //Right Button 
....................         if (input(RIGHT_BUTTON_PIN) == 0) { //button is pressed 
101F:  MOVLB  01
1020:  BSF    0C.4
1021:  MOVLB  00
1022:  BTFSC  0C.4
1023:  GOTO   026
....................             bit_set(button_status, RIGHT_BUTTON_BIT); 
1024:  BSF    37.4
....................             button_counter = 0; 
1025:  CLRF   38
....................         } 
....................  
....................         //Center Button 
....................         if (input(CENTER_BUTTON_PIN) == 0) { //button is pressed 
1026:  MOVLB  01
1027:  BSF    0C.5
1028:  MOVLB  00
1029:  BTFSC  0C.5
102A:  GOTO   02D
....................             bit_set(button_status, CENTER_BUTTON_BIT); 
102B:  BSF    37.5
....................             button_counter = 0; 
102C:  CLRF   38
....................         } 
....................  
....................  
....................  
....................     } else { //a button has been pressed, lets see if it's still pressed 
102D:  GOTO   070
....................  
....................         //Power Button 
....................         if (bit_test(button_status, POWER_BUTTON_BIT)) { 
102E:  BTFSS  37.0
102F:  GOTO   039
....................             if (input(POWER_BUTTON_PIN) == 0) { 
1030:  MOVLB  01
1031:  BSF    0C.0
1032:  MOVLB  00
1033:  BTFSC  0C.0
1034:  GOTO   037
....................                 button_counter++; 
1035:  INCF   38,F
....................             } else { 
1036:  GOTO   039
....................                 button_counter = 0; 
1037:  CLRF   38
....................                 bit_clear(button_status, POWER_BUTTON_BIT); 
1038:  BCF    37.0
....................             } 
....................         } 
....................  
....................         //Up Button 
....................         if (bit_test(button_status, UP_BUTTON_BIT)) { 
1039:  BTFSS  37.1
103A:  GOTO   044
....................             if (input(UP_BUTTON_PIN) == 0) { 
103B:  MOVLB  01
103C:  BSF    0C.1
103D:  MOVLB  00
103E:  BTFSC  0C.1
103F:  GOTO   042
....................                 button_counter++; 
1040:  INCF   38,F
....................             } else { 
1041:  GOTO   044
....................                 button_counter = 0; 
1042:  CLRF   38
....................                 bit_clear(button_status, UP_BUTTON_BIT); 
1043:  BCF    37.1
....................             } 
....................         } 
....................  
....................         //Down Button 
....................         if (bit_test(button_status, DOWN_BUTTON_BIT)) { 
1044:  BTFSS  37.2
1045:  GOTO   04F
....................             if (input(DOWN_BUTTON_PIN) == 0) { 
1046:  MOVLB  01
1047:  BSF    0C.2
1048:  MOVLB  00
1049:  BTFSC  0C.2
104A:  GOTO   04D
....................                 button_counter++; 
104B:  INCF   38,F
....................             } else { 
104C:  GOTO   04F
....................                 button_counter = 0; 
104D:  CLRF   38
....................                 bit_clear(button_status, DOWN_BUTTON_BIT); 
104E:  BCF    37.2
....................             } 
....................         } 
....................  
....................         //Left Button 
....................         if (bit_test(button_status, LEFT_BUTTON_BIT)) { 
104F:  BTFSS  37.3
1050:  GOTO   05A
....................             if (input(LEFT_BUTTON_PIN) == 0) { 
1051:  MOVLB  01
1052:  BSF    0C.3
1053:  MOVLB  00
1054:  BTFSC  0C.3
1055:  GOTO   058
....................                 button_counter++; 
1056:  INCF   38,F
....................             } else { 
1057:  GOTO   05A
....................                 button_counter = 0; 
1058:  CLRF   38
....................                 bit_clear(button_status, LEFT_BUTTON_BIT); 
1059:  BCF    37.3
....................             } 
....................         } 
....................  
....................         //Right Button 
....................         if (bit_test(button_status, RIGHT_BUTTON_BIT)) { 
105A:  BTFSS  37.4
105B:  GOTO   065
....................             if (input(RIGHT_BUTTON_PIN) == 0) { 
105C:  MOVLB  01
105D:  BSF    0C.4
105E:  MOVLB  00
105F:  BTFSC  0C.4
1060:  GOTO   063
....................                 button_counter++; 
1061:  INCF   38,F
....................             } else { 
1062:  GOTO   065
....................                 button_counter = 0; 
1063:  CLRF   38
....................                 bit_clear(button_status, RIGHT_BUTTON_BIT); 
1064:  BCF    37.4
....................             } 
....................         } 
....................  
....................         //Center Button 
....................         if (bit_test(button_status, CENTER_BUTTON_BIT)) { 
1065:  BTFSS  37.5
1066:  GOTO   070
....................             if (input(CENTER_BUTTON_PIN) == 0) { 
1067:  MOVLB  01
1068:  BSF    0C.5
1069:  MOVLB  00
106A:  BTFSC  0C.5
106B:  GOTO   06E
....................                 button_counter++; 
106C:  INCF   38,F
....................             } else { 
106D:  GOTO   070
....................                 button_counter = 0; 
106E:  CLRF   38
....................                 bit_clear(button_status, CENTER_BUTTON_BIT); 
106F:  BCF    37.5
....................             } 
....................         } 
....................  
....................     } 
....................  
....................     if (button_counter > 5) { 
1070:  MOVF   38,W
1071:  SUBLW  05
1072:  BTFSC  03.0
1073:  GOTO   356
....................  
....................         //Power Button 
....................         if (bit_test(button_status, POWER_BUTTON_BIT)) { 
1074:  BTFSS  37.0
1075:  GOTO   0EE
....................             while (input(POWER_BUTTON_PIN) == 0) { //wait untill the button is released 
1076:  MOVLB  01
1077:  BSF    0C.0
1078:  MOVLB  00
1079:  BTFSC  0C.0
107A:  GOTO   07F
....................                 rtos_disable(Button_Checker); 
107B:  MOVLB  0A
107C:  BSF    5A.7
107D:  MOVLB  00
107E:  GOTO   076
....................             } 
....................             rtos_enable(Button_Checker); 
107F:  MOVLB  0A
1080:  BCF    5A.7
....................             Power_Button_Function(); 
....................             button_status = 0; 
*
10ED:  CLRF   37
....................         } 
....................  
....................         //Up Button 
....................         if (bit_test(button_status, UP_BUTTON_BIT)) { 
10EE:  BTFSS  37.1
10EF:  GOTO   11D
....................             while (input(UP_BUTTON_PIN) == 0) { //wait untill the button is released 
10F0:  MOVLB  01
10F1:  BSF    0C.1
10F2:  MOVLB  00
10F3:  BTFSC  0C.1
10F4:  GOTO   0F9
....................                 rtos_disable(Button_Checker); 
10F5:  MOVLB  0A
10F6:  BSF    5A.7
10F7:  MOVLB  00
10F8:  GOTO   0F0
....................             } 
....................             rtos_enable(Button_Checker); 
10F9:  MOVLB  0A
10FA:  BCF    5A.7
....................             Up_Button_Function(); 
....................             button_status = 0; 
*
111C:  CLRF   37
....................         } 
....................  
....................         //Down Button 
....................         if (bit_test(button_status, DOWN_BUTTON_BIT)) { 
111D:  BTFSS  37.2
111E:  GOTO   141
....................             while (input(DOWN_BUTTON_PIN) == 0) { //wait untill the button is released 
111F:  MOVLB  01
1120:  BSF    0C.2
1121:  MOVLB  00
1122:  BTFSC  0C.2
1123:  GOTO   128
....................                 rtos_disable(Button_Checker); 
1124:  MOVLB  0A
1125:  BSF    5A.7
1126:  MOVLB  00
1127:  GOTO   11F
....................             } 
....................             rtos_enable(Button_Checker); 
1128:  MOVLB  0A
1129:  BCF    5A.7
....................             Down_Button_Function(); 
....................             button_status = 0; 
*
1140:  CLRF   37
....................         } 
....................  
....................         //Left Button 
....................         if (bit_test(button_status, LEFT_BUTTON_BIT)) { 
1141:  BTFSS  37.3
1142:  GOTO   197
....................             while (input(LEFT_BUTTON_PIN) == 0) { //wait untill the button is released 
1143:  MOVLB  01
1144:  BSF    0C.3
1145:  MOVLB  00
1146:  BTFSC  0C.3
1147:  GOTO   14C
....................                 rtos_disable(Button_Checker); 
1148:  MOVLB  0A
1149:  BSF    5A.7
114A:  MOVLB  00
114B:  GOTO   143
....................             } 
....................             rtos_enable(Button_Checker); 
114C:  MOVLB  0A
114D:  BCF    5A.7
....................             Left_Button_Function(); 
....................             button_status = 0; 
*
1195:  MOVLB  00
1196:  CLRF   37
....................         } 
....................  
....................         //Right Button 
....................         if (bit_test(button_status, RIGHT_BUTTON_BIT)) { 
1197:  BTFSS  37.4
1198:  GOTO   1EA
....................             while (input(RIGHT_BUTTON_PIN) == 0) { //wait untill the button is released 
1199:  MOVLB  01
119A:  BSF    0C.4
119B:  MOVLB  00
119C:  BTFSC  0C.4
119D:  GOTO   1A2
....................                 rtos_disable(Button_Checker); 
119E:  MOVLB  0A
119F:  BSF    5A.7
11A0:  MOVLB  00
11A1:  GOTO   199
....................             } 
....................             rtos_enable(Button_Checker); 
11A2:  MOVLB  0A
11A3:  BCF    5A.7
....................             Right_Button_Function(); 
....................             button_status = 0; 
*
11E8:  MOVLB  00
11E9:  CLRF   37
....................         } 
....................  
....................         //Center Button 
....................         if (bit_test(button_status, CENTER_BUTTON_BIT)) { 
11EA:  BTFSS  37.5
11EB:  GOTO   356
....................             while (input(CENTER_BUTTON_PIN) == 0) { //wait untill the button is released 
11EC:  MOVLB  01
11ED:  BSF    0C.5
11EE:  MOVLB  00
11EF:  BTFSC  0C.5
11F0:  GOTO   1F5
....................                 rtos_disable(Button_Checker); 
11F1:  MOVLB  0A
11F2:  BSF    5A.7
11F3:  MOVLB  00
11F4:  GOTO   1EC
....................             } 
....................             rtos_enable(Button_Checker); 
11F5:  MOVLB  0A
11F6:  BCF    5A.7
....................             Center_Button_Function(); 
....................             button_status = 0; 
*
1355:  CLRF   37
....................         } 
....................  
....................     } 
1356:  MOVLW  00
1357:  MOVLB  0A
1358:  MOVWF  5F
1359:  MOVLW  10
135A:  MOVWF  60
135B:  MOVLP  10
135C:  MOVLB  00
135D:  GOTO   7A8
135E:  RETURN
.................... } 
....................  
....................  
.................... /*MAIN FUNCTION*/ 
.................... void main(int argc, char** argv) { 
135F:  MOVLW  0A
1360:  MOVWF  3D
1361:  MOVWF  3E
1362:  MOVLW  28
1363:  MOVWF  3F
1364:  MOVLW  3C
1365:  MOVWF  70
1366:  MOVLW  34
1367:  MOVWF  71
1368:  MOVLW  16
1369:  MOVWF  72
136A:  MOVLW  03
136B:  MOVWF  73
136C:  MOVWF  74
136D:  MOVWF  75
136E:  MOVLW  F0
136F:  MOVLB  01
1370:  MOVWF  19
1371:  MOVLB  03
1372:  BSF    1F.3
1373:  BSF    1F.4
1374:  MOVLW  8A
1375:  MOVWF  1B
1376:  MOVLW  00
1377:  MOVWF  1C
1378:  MOVLW  A6
1379:  MOVWF  1E
137A:  MOVLW  90
137B:  MOVWF  1D
137C:  CLRF   0C
137D:  CLRF   0D
137E:  CLRF   0E
137F:  MOVLB  02
1380:  CLRF   12
1381:  CLRF   11
1382:  GOTO   6C9
1383:  DATA 02,34
1384:  DATA 00,34
1385:  DATA 20,34
1386:  DATA 00,34
1387:  DATA 00,34
1388:  DATA 29,34
1389:  DATA 00,34
138A:  DATA 40,34
138B:  DATA FF,34
138C:  DATA 5C,34
138D:  DATA E0,34
138E:  DATA 00,34
138F:  DATA FF,34
1390:  DATA 53,34
1391:  DATA CA,34
1392:  DATA 00,34
1393:  DATA FF,34
1394:  DATA 4A,34
1395:  DATA B4,34
1396:  DATA 00,34
1397:  DATA FF,34
1398:  DATA 40,34
1399:  DATA 9C,34
139A:  DATA 00,34
139B:  DATA FF,34
139C:  DATA 37,34
139D:  DATA 86,34
139E:  DATA 00,34
139F:  DATA FF,34
13A0:  DATA 2E,34
13A1:  DATA 70,34
13A2:  DATA 00,34
13A3:  DATA FF,34
13A4:  DATA 25,34
13A5:  DATA 5A,34
13A6:  DATA 00,34
13A7:  DATA FF,34
13A8:  DATA 1B,34
13A9:  DATA 42,34
13AA:  DATA 00,34
13AB:  DATA FF,34
13AC:  DATA 12,34
13AD:  DATA 2C,34
13AE:  DATA 00,34
13AF:  DATA FF,34
13B0:  DATA 09,34
13B1:  DATA 16,34
13B2:  DATA 00,34
13B3:  DATA FF,34
13B4:  DATA 04,34
13B5:  DATA C0,34
13B6:  DATA 00,34
13B7:  DATA 03,34
13B8:  DATA 80,34
13B9:  DATA FF,34
13BA:  DATA 00,34
13BB:  DATA 00,34
13BC:  DATA 01,34
13BD:  DATA 00,34
13BE:  DATA A0,34
13BF:  DATA FF,34
13C0:  DATA 04,34
13C1:  DATA C0,34
13C2:  DATA 00,34
13C3:  DATA 04,34
13C4:  DATA 80,34
13C5:  DATA FF,34
13C6:  DATA 00,34
13C7:  DATA 00,34
13C8:  DATA FF,34
13C9:  DATA 04,34
13CA:  DATA C0,34
13CB:  DATA 00,34
13CC:  DATA 04,34
13CD:  DATA 80,34
13CE:  DATA FF,34
13CF:  DATA 00,34
13D0:  DATA 00,34
13D1:  DATA FF,34
13D2:  DATA 04,34
13D3:  DATA C0,34
13D4:  DATA 00,34
13D5:  DATA 04,34
13D6:  DATA 80,34
13D7:  DATA FF,34
13D8:  DATA 00,34
13D9:  DATA 00,34
13DA:  DATA FF,34
13DB:  DATA 04,34
13DC:  DATA C0,34
13DD:  DATA 00,34
13DE:  DATA 33,34
13DF:  DATA 80,34
13E0:  DATA FF,34
13E1:  DATA 00,34
13E2:  DATA 00,34
13E3:  DATA FC,34
13E4:  DATA FF,34
13E5:  DATA 35,34
13E6:  DATA 00,34
13E7:  DATA FA,34
13E8:  DATA FC,34
13E9:  DATA 38,34
13EA:  DATA 00,34
13EB:  DATA F8,34
13EC:  DATA F9,34
13ED:  DATA 3B,34
13EE:  DATA 00,34
13EF:  DATA F6,34
13F0:  DATA F5,34
13F1:  DATA 3E,34
13F2:  DATA 00,34
13F3:  DATA F4,34
13F4:  DATA F1,34
13F5:  DATA 42,34
13F6:  DATA 00,34
13F7:  DATA F1,34
13F8:  DATA ED,34
13F9:  DATA 46,34
13FA:  DATA 00,34
13FB:  DATA EE,34
13FC:  DATA E8,34
13FD:  DATA 4A,34
13FE:  DATA 00,34
13FF:  DATA EB,34
1400:  DATA E3,34
1401:  DATA 4F,34
1402:  DATA 00,34
1403:  DATA E8,34
1404:  DATA DE,34
1405:  DATA 54,34
1406:  DATA 00,34
1407:  DATA E5,34
1408:  DATA D8,34
1409:  DATA 59,34
140A:  DATA 00,34
140B:  DATA E1,34
140C:  DATA D2,34
140D:  DATA 5E,34
140E:  DATA 00,34
140F:  DATA DE,34
1410:  DATA CC,34
1411:  DATA 63,34
1412:  DATA 00,34
1413:  DATA 50,34
1414:  DATA 01,34
1415:  DATA 20,34
1416:  DATA DA,34
1417:  DATA C6,34
1418:  DATA 69,34
1419:  DATA 00,34
141A:  DATA D6,34
141B:  DATA C0,34
141C:  DATA 6F,34
141D:  DATA 00,34
141E:  DATA D3,34
141F:  DATA B9,34
1420:  DATA 75,34
1421:  DATA 00,34
1422:  DATA CF,34
1423:  DATA B3,34
1424:  DATA 7B,34
1425:  DATA 00,34
1426:  DATA CB,34
1427:  DATA AC,34
1428:  DATA 81,34
1429:  DATA 00,34
142A:  DATA C7,34
142B:  DATA A6,34
142C:  DATA 87,34
142D:  DATA 00,34
142E:  DATA C3,34
142F:  DATA 9F,34
1430:  DATA 8D,34
1431:  DATA 00,34
1432:  DATA BF,34
1433:  DATA 98,34
1434:  DATA 94,34
1435:  DATA 00,34
1436:  DATA BB,34
1437:  DATA 91,34
1438:  DATA 9A,34
1439:  DATA 00,34
143A:  DATA B6,34
143B:  DATA 8A,34
143C:  DATA A0,34
143D:  DATA 00,34
143E:  DATA B2,34
143F:  DATA 83,34
1440:  DATA A7,34
1441:  DATA 00,34
1442:  DATA AE,34
1443:  DATA 7C,34
1444:  DATA AD,34
1445:  DATA 00,34
1446:  DATA AA,34
1447:  DATA 76,34
1448:  DATA B3,34
1449:  DATA 00,34
144A:  DATA A6,34
144B:  DATA 6F,34
144C:  DATA B9,34
144D:  DATA 00,34
144E:  DATA A2,34
144F:  DATA 69,34
1450:  DATA BF,34
1451:  DATA 00,34
1452:  DATA 9F,34
1453:  DATA 62,34
1454:  DATA C5,34
1455:  DATA 00,34
1456:  DATA 9B,34
1457:  DATA 5C,34
1458:  DATA CB,34
1459:  DATA 00,34
145A:  DATA 97,34
145B:  DATA 56,34
145C:  DATA D1,34
145D:  DATA 00,34
145E:  DATA 94,34
145F:  DATA 50,34
1460:  DATA D6,34
1461:  DATA 00,34
1462:  DATA 90,34
1463:  DATA 4A,34
1464:  DATA DB,34
1465:  DATA 00,34
1466:  DATA 50,34
1467:  DATA 01,34
1468:  DATA A0,34
1469:  DATA 8D,34
146A:  DATA 44,34
146B:  DATA E0,34
146C:  DATA 00,34
146D:  DATA 8A,34
146E:  DATA 3F,34
146F:  DATA E5,34
1470:  DATA 00,34
1471:  DATA 87,34
1472:  DATA 3A,34
1473:  DATA EA,34
1474:  DATA 00,34
1475:  DATA 84,34
1476:  DATA 35,34
1477:  DATA EE,34
1478:  DATA 00,34
1479:  DATA 81,34
147A:  DATA 31,34
147B:  DATA F2,34
147C:  DATA 00,34
147D:  DATA 7F,34
147E:  DATA 2D,34
147F:  DATA F6,34
1480:  DATA 00,34
1481:  DATA 7D,34
1482:  DATA 29,34
1483:  DATA F9,34
1484:  DATA 00,34
1485:  DATA 7B,34
1486:  DATA 26,34
1487:  DATA FC,34
1488:  DATA 00,34
1489:  DATA 4F,34
148A:  DATA FF,34
148B:  DATA FF,34
148C:  DATA 00,34
148D:  DATA 4F,34
148E:  DATA FF,34
148F:  DATA FF,34
1490:  DATA 00,34
1491:  DATA 4F,34
1492:  DATA FF,34
1493:  DATA FF,34
1494:  DATA 00,34
1495:  DATA 4F,34
1496:  DATA FF,34
1497:  DATA FF,34
1498:  DATA 00,34
1499:  DATA 4F,34
149A:  DATA FF,34
149B:  DATA FF,34
149C:  DATA 00,34
149D:  DATA 4F,34
149E:  DATA FF,34
149F:  DATA FF,34
14A0:  DATA 00,34
14A1:  DATA 4F,34
14A2:  DATA FF,34
14A3:  DATA FF,34
14A4:  DATA 00,34
14A5:  DATA 4F,34
14A6:  DATA FF,34
14A7:  DATA FF,34
14A8:  DATA 00,34
14A9:  DATA 4F,34
14AA:  DATA FF,34
14AB:  DATA FF,34
14AC:  DATA 00,34
14AD:  DATA 4F,34
14AE:  DATA FF,34
14AF:  DATA FF,34
14B0:  DATA 00,34
14B1:  DATA 4F,34
14B2:  DATA FF,34
14B3:  DATA FF,34
14B4:  DATA 00,34
14B5:  DATA 50,34
14B6:  DATA FE,34
14B7:  DATA FE,34
14B8:  DATA 00,34
14B9:  DATA 50,34
14BA:  DATA 02,34
14BB:  DATA 20,34
14BC:  DATA 57,34
14BD:  DATA F4,34
14BE:  DATA F4,34
14BF:  DATA 00,34
14C0:  DATA 60,34
14C1:  DATA E7,34
14C2:  DATA E7,34
14C3:  DATA 00,34
14C4:  DATA 6B,34
14C5:  DATA D8,34
14C6:  DATA D8,34
14C7:  DATA 00,34
14C8:  DATA 77,34
14C9:  DATA C7,34
14CA:  DATA C7,34
14CB:  DATA 00,34
14CC:  DATA 85,34
14CD:  DATA B4,34
14CE:  DATA B4,34
14CF:  DATA 00,34
14D0:  DATA 93,34
14D1:  DATA A0,34
14D2:  DATA A0,34
14D3:  DATA 00,34
14D4:  DATA A2,34
14D5:  DATA 8B,34
14D6:  DATA 8B,34
14D7:  DATA 00,34
14D8:  DATA B1,34
14D9:  DATA 76,34
14DA:  DATA 76,34
14DB:  DATA 00,34
14DC:  DATA C0,34
14DD:  DATA 61,34
14DE:  DATA 61,34
14DF:  DATA 00,34
14E0:  DATA CE,34
14E1:  DATA 4D,34
14E2:  DATA 4D,34
14E3:  DATA 00,34
14E4:  DATA DB,34
14E5:  DATA 3B,34
14E6:  DATA 3B,34
14E7:  DATA 00,34
14E8:  DATA E6,34
14E9:  DATA 2A,34
14EA:  DATA 2A,34
14EB:  DATA 00,34
14EC:  DATA F0,34
14ED:  DATA 1B,34
14EE:  DATA 1B,34
14EF:  DATA 00,34
14F0:  DATA F8,34
14F1:  DATA 0F,34
14F2:  DATA 0F,34
14F3:  DATA 00,34
14F4:  DATA FD,34
14F5:  DATA 06,34
14F6:  DATA 06,34
14F7:  DATA 00,34
14F8:  DATA FF,34
14F9:  DATA 01,34
14FA:  DATA 01,34
14FB:  DATA 00,34
14FC:  DATA FF,34
14FD:  DATA 00,34
14FE:  DATA 00,34
14FF:  DATA 00,34
1500:  DATA FB,34
1501:  DATA 02,34
1502:  DATA 02,34
1503:  DATA 00,34
1504:  DATA F6,34
1505:  DATA 07,34
1506:  DATA 07,34
1507:  DATA 00,34
1508:  DATA EF,34
1509:  DATA 0E,34
150A:  DATA 0E,34
150B:  DATA 00,34
150C:  DATA 50,34
150D:  DATA 02,34
150E:  DATA A0,34
150F:  DATA E6,34
1510:  DATA 18,34
1511:  DATA 18,34
1512:  DATA 00,34
1513:  DATA DB,34
1514:  DATA 23,34
1515:  DATA 23,34
1516:  DATA 00,34
1517:  DATA CF,34
1518:  DATA 30,34
1519:  DATA 30,34
151A:  DATA 00,34
151B:  DATA C2,34
151C:  DATA 3E,34
151D:  DATA 3E,34
151E:  DATA 00,34
151F:  DATA B4,34
1520:  DATA 4E,34
1521:  DATA 4E,34
1522:  DATA 00,34
1523:  DATA A5,34
1524:  DATA 5E,34
1525:  DATA 5E,34
1526:  DATA 00,34
1527:  DATA 96,34
1528:  DATA 6F,34
1529:  DATA 6F,34
152A:  DATA 00,34
152B:  DATA 87,34
152C:  DATA 80,34
152D:  DATA 80,34
152E:  DATA 00,34
152F:  DATA 77,34
1530:  DATA 91,34
1531:  DATA 91,34
1532:  DATA 00,34
1533:  DATA 68,34
1534:  DATA A2,34
1535:  DATA A2,34
1536:  DATA 00,34
1537:  DATA 5A,34
1538:  DATA B3,34
1539:  DATA B3,34
153A:  DATA 00,34
153B:  DATA 4C,34
153C:  DATA C3,34
153D:  DATA C3,34
153E:  DATA 00,34
153F:  DATA 3F,34
1540:  DATA D1,34
1541:  DATA D1,34
1542:  DATA 00,34
1543:  DATA 33,34
1544:  DATA DF,34
1545:  DATA DF,34
1546:  DATA 00,34
1547:  DATA 28,34
1548:  DATA EB,34
1549:  DATA EB,34
154A:  DATA 00,34
154B:  DATA 1F,34
154C:  DATA F5,34
154D:  DATA F5,34
154E:  DATA 00,34
154F:  DATA 18,34
1550:  DATA FD,34
1551:  DATA FD,34
1552:  DATA 00,34
1553:  DATA 16,34
1554:  DATA FF,34
1555:  DATA FF,34
1556:  DATA 00,34
1557:  DATA 16,34
1558:  DATA FF,34
1559:  DATA FF,34
155A:  DATA 00,34
155B:  DATA 16,34
155C:  DATA FF,34
155D:  DATA FF,34
155E:  DATA 00,34
155F:  DATA 50,34
1560:  DATA 03,34
1561:  DATA 20,34
1562:  DATA 16,34
1563:  DATA FF,34
1564:  DATA FF,34
1565:  DATA 00,34
1566:  DATA 16,34
1567:  DATA FF,34
1568:  DATA FF,34
1569:  DATA 00,34
156A:  DATA 16,34
156B:  DATA FF,34
156C:  DATA FF,34
156D:  DATA 00,34
156E:  DATA 16,34
156F:  DATA FF,34
1570:  DATA FF,34
1571:  DATA 00,34
1572:  DATA 16,34
1573:  DATA FF,34
1574:  DATA FF,34
1575:  DATA 00,34
1576:  DATA 16,34
1577:  DATA FF,34
1578:  DATA FF,34
1579:  DATA 00,34
157A:  DATA 16,34
157B:  DATA FF,34
157C:  DATA FF,34
157D:  DATA 00,34
157E:  DATA 16,34
157F:  DATA FF,34
1580:  DATA FF,34
1581:  DATA 00,34
1582:  DATA DE,34
1583:  DATA 21,34
1584:  DATA 10,34
1585:  DATA 00,34
1586:  DATA EE,34
1587:  DATA 11,34
1588:  DATA 41,34
1589:  DATA 00,34
158A:  DATA EE,34
158B:  DATA 11,34
158C:  DATA 85,34
158D:  DATA 00,34
158E:  DATA EE,34
158F:  DATA 11,34
1590:  DATA C6,34
1591:  DATA 00,34
1592:  DATA E9,34
1593:  DATA 11,34
1594:  DATA EA,34
1595:  DATA 00,34
1596:  DATA C7,34
1597:  DATA 11,34
1598:  DATA EE,34
1599:  DATA 00,34
159A:  DATA 8E,34
159B:  DATA 11,34
159C:  DATA EE,34
159D:  DATA 00,34
159E:  DATA 51,34
159F:  DATA 11,34
15A0:  DATA EE,34
15A1:  DATA 00,34
15A2:  DATA 1C,34
15A3:  DATA 11,34
15A4:  DATA EE,34
15A5:  DATA 00,34
15A6:  DATA 02,34
15A7:  DATA 19,34
15A8:  DATA EE,34
15A9:  DATA 00,34
15AA:  DATA 00,34
15AB:  DATA 42,34
15AC:  DATA EE,34
15AD:  DATA 00,34
15AE:  DATA 00,34
15AF:  DATA 80,34
15B0:  DATA EE,34
15B1:  DATA 00,34
15B2:  DATA 50,34
15B3:  DATA 03,34
15B4:  DATA A0,34
15B5:  DATA 00,34
15B6:  DATA C0,34
15B7:  DATA EE,34
15B8:  DATA 00,34
15B9:  DATA 00,34
15BA:  DATA F1,34
15BB:  DATA EE,34
15BC:  DATA 00,34
15BD:  DATA 00,34
15BE:  DATA FF,34
15BF:  DATA D9,34
15C0:  DATA 00,34
15C1:  DATA 00,34
15C2:  DATA FF,34
15C3:  DATA A1,34
15C4:  DATA 00,34
15C5:  DATA 00,34
15C6:  DATA FF,34
15C7:  DATA 5B,34
15C8:  DATA 00,34
15C9:  DATA 00,34
15CA:  DATA FF,34
15CB:  DATA 1D,34
15CC:  DATA 00,34
15CD:  DATA 00,34
15CE:  DATA FF,34
15CF:  DATA 00,34
15D0:  DATA 00,34
15D1:  DATA 00,34
15D2:  DATA FF,34
15D3:  DATA 00,34
15D4:  DATA 00,34
15D5:  DATA 00,34
15D6:  DATA FF,34
15D7:  DATA 00,34
15D8:  DATA 00,34
15D9:  DATA 00,34
15DA:  DATA FF,34
15DB:  DATA 00,34
15DC:  DATA 00,34
15DD:  DATA 00,34
15DE:  DATA FF,34
15DF:  DATA 00,34
15E0:  DATA 00,34
15E1:  DATA 00,34
15E2:  DATA FF,34
15E3:  DATA 00,34
15E4:  DATA 00,34
15E5:  DATA 00,34
15E6:  DATA FF,34
15E7:  DATA 00,34
15E8:  DATA 00,34
15E9:  DATA 00,34
15EA:  DATA FF,34
15EB:  DATA 00,34
15EC:  DATA 00,34
15ED:  DATA 00,34
15EE:  DATA FF,34
15EF:  DATA 00,34
15F0:  DATA 00,34
15F1:  DATA 00,34
15F2:  DATA FF,34
15F3:  DATA 00,34
15F4:  DATA 00,34
15F5:  DATA 00,34
15F6:  DATA FF,34
15F7:  DATA 00,34
15F8:  DATA 00,34
15F9:  DATA 00,34
15FA:  DATA FF,34
15FB:  DATA 00,34
15FC:  DATA 00,34
15FD:  DATA 00,34
15FE:  DATA FF,34
15FF:  DATA 00,34
1600:  DATA 00,34
1601:  DATA 00,34
1602:  DATA FF,34
1603:  DATA 00,34
1604:  DATA 00,34
1605:  DATA 50,34
1606:  DATA 04,34
1607:  DATA 20,34
1608:  DATA 00,34
1609:  DATA FF,34
160A:  DATA 00,34
160B:  DATA 00,34
160C:  DATA 00,34
160D:  DATA FF,34
160E:  DATA 00,34
160F:  DATA 00,34
1610:  DATA 00,34
1611:  DATA FF,34
1612:  DATA 1F,34
1613:  DATA 00,34
1614:  DATA 00,34
1615:  DATA FF,34
1616:  DATA 61,34
1617:  DATA 00,34
1618:  DATA 00,34
1619:  DATA FF,34
161A:  DATA AC,34
161B:  DATA 00,34
161C:  DATA 00,34
161D:  DATA FF,34
161E:  DATA E9,34
161F:  DATA 00,34
1620:  DATA 00,34
1621:  DATA F0,34
1622:  DATA FF,34
1623:  DATA 00,34
1624:  DATA 00,34
1625:  DATA BB,34
1626:  DATA FF,34
1627:  DATA 00,34
1628:  DATA 00,34
1629:  DATA 77,34
162A:  DATA FF,34
162B:  DATA 00,34
162C:  DATA 00,34
162D:  DATA 34,34
162E:  DATA FF,34
162F:  DATA 00,34
1630:  DATA 02,34
1631:  DATA 09,34
1632:  DATA FF,34
1633:  DATA 00,34
1634:  DATA 1E,34
1635:  DATA 00,34
1636:  DATA FF,34
1637:  DATA 00,34
1638:  DATA 57,34
1639:  DATA 00,34
163A:  DATA FF,34
163B:  DATA 00,34
163C:  DATA 98,34
163D:  DATA 00,34
163E:  DATA FF,34
163F:  DATA 00,34
1640:  DATA D5,34
1641:  DATA 00,34
1642:  DATA FF,34
1643:  DATA 00,34
1644:  DATA FA,34
1645:  DATA 00,34
1646:  DATA FB,34
1647:  DATA 00,34
1648:  DATA FF,34
1649:  DATA 00,34
164A:  DATA D4,34
164B:  DATA 00,34
164C:  DATA FF,34
164D:  DATA 00,34
164E:  DATA 8E,34
164F:  DATA 00,34
1650:  DATA FF,34
1651:  DATA 00,34
1652:  DATA 46,34
1653:  DATA 00,34
1654:  DATA FF,34
1655:  DATA 00,34
1656:  DATA 12,34
1657:  DATA 00,34
1658:  DATA 50,34
1659:  DATA 04,34
165A:  DATA A0,34
165B:  DATA F9,34
165C:  DATA F9,34
165D:  DATA F9,34
165E:  DATA 00,34
165F:  DATA F1,34
1660:  DATA F0,34
1661:  DATA F1,34
1662:  DATA 00,34
1663:  DATA E5,34
1664:  DATA E2,34
1665:  DATA E4,34
1666:  DATA 00,34
1667:  DATA F3,34
1668:  DATA EF,34
1669:  DATA F1,34
166A:  DATA 00,34
166B:  DATA A2,34
166C:  DATA 9C,34
166D:  DATA 9E,34
166E:  DATA 00,34
166F:  DATA 20,34
1670:  DATA 1B,34
1671:  DATA 1E,34
1672:  DATA 00,34
1673:  DATA 1D,34
1674:  DATA 1A,34
1675:  DATA 1B,34
1676:  DATA 00,34
1677:  DATA 2D,34
1678:  DATA 2C,34
1679:  DATA 2C,34
167A:  DATA 00,34
167B:  DATA 62,34
167C:  DATA 62,34
167D:  DATA 62,34
167E:  DATA 00,34
167F:  DATA B3,34
1680:  DATA B3,34
1681:  DATA B3,34
1682:  DATA 00,34
1683:  DATA F3,34
1684:  DATA ED,34
1685:  DATA F0,34
1686:  DATA 00,34
1687:  DATA F3,34
1688:  DATA D9,34
1689:  DATA E6,34
168A:  DATA 00,34
168B:  DATA C8,34
168C:  DATA 80,34
168D:  DATA A4,34
168E:  DATA 00,34
168F:  DATA B3,34
1690:  DATA 2D,34
1691:  DATA 6F,34
1692:  DATA 00,34
1693:  DATA C3,34
1694:  DATA 0A,34
1695:  DATA 66,34
1696:  DATA 00,34
1697:  DATA C8,34
1698:  DATA 03,34
1699:  DATA 65,34
169A:  DATA 00,34
169B:  DATA A4,34
169C:  DATA 06,34
169D:  DATA 55,34
169E:  DATA 00,34
169F:  DATA 79,34
16A0:  DATA 1B,34
16A1:  DATA 4A,34
16A2:  DATA 00,34
16A3:  DATA 77,34
16A4:  DATA 4F,34
16A5:  DATA 63,34
16A6:  DATA 00,34
16A7:  DATA 9C,34
16A8:  DATA 90,34
16A9:  DATA 96,34
16AA:  DATA 00,34
16AB:  DATA 0B,34
16AC:  DATA 05,34
16AD:  DATA 20,34
16AE:  DATA B4,34
16AF:  DATA B1,34
16B0:  DATA B2,34
16B1:  DATA 00,34
16B2:  DATA 9F,34
16B3:  DATA A0,34
16B4:  DATA 9F,34
16B5:  DATA 00,34
16B6:  DATA 00,34
16B7:  DATA 00,34
16B8:  DATA FF,34
16B9:  DATA 0A,34
16BA:  DATA C0,34
16BB:  DATA 00,34
16BC:  DATA 01,34
16BD:  DATA 80,34
16BE:  DATA FF,34
16BF:  DATA 0A,34
16C0:  DATA C0,34
16C1:  DATA 00,34
16C2:  DATA 01,34
16C3:  DATA 80,34
16C4:  DATA FF,34
16C5:  DATA 0B,34
16C6:  DATA C0,34
16C7:  DATA 00,34
16C8:  DATA 00,34
16C9:  MOVLW  13
16CA:  MOVWF  05
16CB:  MOVLW  83
16CC:  MOVWF  04
16CD:  BSF    05.7
16CE:  MOVIW  [FSR0++],W
16CF:  MOVWF  77
16D0:  XORLW  00
16D1:  BTFSC  03.2
16D2:  GOTO   6E3
16D3:  MOVIW  [FSR0++],W
16D4:  MOVWF  78
16D5:  BTFSC  78.7
16D6:  GOTO   6DB
16D7:  ANDLW  0F
16D8:  MOVWF  07
16D9:  MOVIW  [FSR0++],W
16DA:  MOVWF  06
16DB:  BTFSC  78.6
16DC:  MOVIW  [FSR0++],W
16DD:  BTFSS  78.6
16DE:  MOVIW  [FSR0++],W
16DF:  MOVWI  W,[FSR1++]
16E0:  DECFSZ 77,F
16E1:  GOTO   6DD
16E2:  GOTO   6CE
....................     //setup the IC 
....................     setup_oscillator(OSC_8MHZ | OSC_PLL_ON); //32MHZ 
16E3:  MOVLW  F0
16E4:  MOVLB  01
16E5:  MOVWF  19
....................     //set_tris_a(0b01111111); 
....................     //set_tris_b(0b00000000); 
....................     setup_wdt(WDT_16S); 
16E6:  MOVLW  1D
16E7:  MOVWF  17
....................     PORT_A_PULLUPS(0b01111111); 
16E8:  MOVLW  7F
16E9:  MOVLB  04
16EA:  MOVWF  0C
16EB:  MOVLB  01
16EC:  BCF    15.7
....................     PORT_B_PULLUPS(0b00000000); 
16ED:  MOVLB  04
16EE:  CLRF   0D
....................  
.................... #ifdef BOARD_V1_1 
....................     #ifdef WS2801 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_16 | SPI_DO_B5 | SPI_SCK_B7 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
....................     #endif 
....................     #ifdef WS2811 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_DO_B5 | SPI_SCK_B7 | SPI_L_TO_H | SPI_SCK_IDLE_LOW); 
....................     #endif 
.................... #endif 
....................  
.................... #ifdef BOARD_V1_2 
....................     #ifdef WS2801 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_16 | SPI_DO_C5 | SPI_SCK_C3 | SPI_SCK_IDLE_LOW | SPI_XMIT_L_TO_H); 
16EF:  MOVLB  02
16F0:  BCF    1D.3
16F1:  BCF    1D.4
16F2:  BCF    1D.5
16F3:  BCF    1C.1
16F4:  BCF    1C.2
16F5:  MOVLB  04
16F6:  BCF    15.5
16F7:  MOVLB  01
16F8:  BCF    0E.5
16F9:  BSF    0E.4
16FA:  BCF    0E.3
16FB:  MOVLW  21
16FC:  MOVLB  04
16FD:  MOVWF  15
16FE:  MOVLW  40
16FF:  MOVWF  14
....................     #endif 
....................     #ifdef WS2811 
....................         setup_spi(SPI_MASTER | SPI_CLK_DIV_4 | SPI_DO_C5 | SPI_SCK_C3 | SPI_L_TO_H | SPI_SCK_IDLE_LOW); 
....................     #endif 
.................... #endif 
....................  
....................     //turn on the leds 
....................     OUTPUT_LOW(LED_ON_PIN); 
1700:  MOVLB  01
1701:  BCF    0C.7
1702:  MOVLB  02
1703:  BCF    0C.7
....................     led_power_status = 1; //LED IS ON 
1704:  MOVLB  00
1705:  BSF    34.2
....................      
....................     //clear the led_strup_colors variable 
....................     setup(); 
1706:  MOVLP  00
1707:  GOTO   6D5
1708:  MOVLP  10
....................     send_frame(); 
1709:  MOVLP  00
170A:  CALL   233
170B:  MOVLP  10
....................     delay_ms(100); 
170C:  MOVLW  64
170D:  MOVLB  0B
170E:  MOVWF  67
170F:  MOVLP  00
1710:  MOVLB  00
1711:  CALL   651
1712:  MOVLP  10
....................  
....................     //setup global variables 
....................     autochange_pattern = 0; 
1713:  CLRF   39
....................     current_pattern = 5; 
1714:  CLRF   33
1715:  MOVLW  05
1716:  MOVWF  32
....................     //current_pattern = 21; //used for tent light 
....................     button_status = 0; 
1717:  CLRF   37
....................     timer_flags_counter = 0; 
1718:  CLRF   36
1719:  CLRF   35
....................     pattern_set = 0; 
171A:  BCF    34.0
....................     continue_pattern_calling = 0; 
171B:  BCF    34.1
....................     delay_time_ms = 1; 
171C:  CLRF   3B
171D:  MOVLW  01
171E:  MOVWF  3A
....................     Clear_Pattern_Positions(); 
171F:  MOVLP  00
1720:  CALL   0A4
1721:  MOVLP  10
....................     brightness_value = 10; //out of MAX_BRIGHTNESS 
1722:  MOVLW  0A
1723:  MOVWF  3C
....................              
....................  
.................... #ifdef DEBUG_SERIAL 
....................     printf("System Started\n\r"); 
1724:  MOVLW  C4
1725:  MOVLB  03
1726:  MOVWF  11
1727:  MOVLW  06
1728:  MOVWF  12
1729:  MOVLP  00
172A:  MOVLB  00
172B:  CALL   602
172C:  MOVLP  10
.................... #endif 
....................  
.................... //Test code when checking LED programs 
....................         //startup test of all colors 
....................         //make all red 
.................... /* 
....................         MakeAllColor(Color(255, 0, 0)); 
....................         delay_ms(1000); 
....................         //make all green 
....................         MakeAllColor(Color(0, 255, 0)); 
....................         delay_ms(1000); 
....................         //make all blue 
....................         MakeAllColor(Color(0, 0, 255)); 
....................         delay_ms(1000); 
....................  
....................  */ 
....................  
....................     Timer_Clear_All_Timer(); 
172D:  MOVLP  00
172E:  GOTO   6F3
172F:  MOVLP  10
....................              
.................... #ifdef DEBUG_SERIAL 
....................     printf("Starting RTOS\n\r"); 
1730:  MOVLW  CD
1731:  MOVLB  03
1732:  MOVWF  11
1733:  MOVLW  06
1734:  MOVWF  12
1735:  MOVLP  00
1736:  MOVLB  00
1737:  CALL   602
1738:  MOVLP  10
.................... #endif 
....................      
....................     rtos_run(); 
1739:  MOVLB  0A
173A:  CLRF   4C
173B:  MOVLW  75
173C:  MOVWF  4E
173D:  MOVLW  30
173E:  MOVWF  4D
173F:  CLRF   50
1740:  MOVLW  02
1741:  MOVWF  4F
1742:  MOVLW  B9
1743:  MOVWF  51
1744:  MOVLW  00
1745:  MOVWF  52
1746:  CLRF   53
1747:  CLRF   55
1748:  MOVLW  0A
1749:  MOVWF  54
174A:  CLRF   57
174B:  CLRF   56
174C:  MOVLW  00
174D:  MOVWF  58
174E:  MOVLW  08
174F:  MOVWF  59
1750:  CLRF   5A
1751:  CLRF   5C
1752:  MOVLW  0A
1753:  MOVWF  5B
1754:  CLRF   5E
1755:  MOVLW  01
1756:  MOVWF  5D
1757:  MOVLW  00
1758:  MOVWF  5F
1759:  MOVLW  10
175A:  MOVWF  60
175B:  CLRF   61
175C:  CLRF   63
175D:  MOVLW  01
175E:  MOVWF  62
175F:  CLRF   65
1760:  CLRF   64
1761:  MOVLW  0C
1762:  MOVWF  66
1763:  MOVLW  00
1764:  MOVWF  67
1765:  CLRF   76
1766:  MOVLW  05
1767:  MOVLB  00
1768:  MOVWF  18
1769:  CLRF   19
176A:  CLRF   16
176B:  MOVLW  E0
176C:  MOVWF  17
176D:  MOVLW  C0
176E:  MOVWF  16
176F:  BCF    11.0
1770:  BCF    03.0
1771:  RLF    76,W
1772:  MOVWF  77
1773:  MOVLP  00
1774:  CALL   003
1775:  MOVLP  10
1776:  MOVWF  79
1777:  MOVLW  01
1778:  ADDWF  77,W
1779:  MOVLP  00
177A:  CALL   003
177B:  MOVLP  10
177C:  MOVWF  7A
177D:  MOVF   7A,W
177E:  MOVWF  05
177F:  MOVF   79,W
1780:  MOVWF  04
1781:  MOVF   00,W
1782:  MOVWF  79
1783:  INCF   04,F
1784:  MOVF   00,W
1785:  MOVWF  77
1786:  INCF   04,F
1787:  MOVF   00,W
1788:  MOVWF  78
1789:  INCF   04,F
178A:  INCF   00,F
178B:  MOVF   00,W
178C:  MOVWF  7A
178D:  BTFSS  03.2
178E:  GOTO   792
178F:  INCF   04,F
1790:  INCF   00,F
1791:  DECF   04,F
1792:  INCF   04,F
1793:  MOVF   00,W
1794:  SUBWF  78,W
1795:  BTFSS  03.2
1796:  GOTO   7A9
1797:  MOVF   77,W
1798:  SUBWF  7A,W
1799:  BTFSS  03.2
179A:  GOTO   7A9
179B:  DECF   04,F
179C:  CLRF   00
179D:  INCF   04,F
179E:  CLRF   00
179F:  INCF   04,F
17A0:  BTFSC  79.7
17A1:  GOTO   7A9
17A2:  ADDFSR 01,FSR0
17A3:  MOVF   00,W
17A4:  MOVWF  0A
17A5:  ADDFSR 3F,FSR0
17A6:  MOVF   00,W
17A7:  MOVWF  02
17A8:  MOVLB  00
17A9:  INCF   76,F
17AA:  MOVLW  04
17AB:  SUBWF  76,W
17AC:  BTFSS  03.2
17AD:  GOTO   770
17AE:  CLRF   76
17AF:  BTFSC  11.0
17B0:  GOTO   76A
17B1:  GOTO   7AF
17B2:  MOVLW  FF
17B3:  MOVWF  76
.................... } 
17B4:  SLEEP

Configuration Fuses:
   Word  1: 3994   INTRC_IO WDT_NOSL PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NOLPBOR NODEBUG NOLVP
